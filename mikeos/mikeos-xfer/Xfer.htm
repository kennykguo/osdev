<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Xmodem based utility for MikeOS</title>
</head>

<body>

<p align="left"><b><font color="#FF0000"><font size="6">Xmodem</font><font size="6"> 
based utility for MikeOS</font></font></b></p>
<p align="left"><img border="0" src="Xfer1.jpg" width="419" height="150"></p>
<p align="left"><u><b><font size="4" color="#FF0000">About</font></b></u></p>
<p align="left">Xfer.bin is an application to allow the transfer of compiled 
MikeOS programs<br>
from a development machine to another computer running MikeOS.<br>
Xfer.bin requires a null modem cable connected to the serial ports of both<br>
machines running at 9600 8 N 1 and uses the original Xmodem protocol for the 
transfer.</p>
<p align="left">The baud rate can also be set to 1200 if preferred.</p>
<p align="left">Although MikeOS can be put onto floppy, cd-rom, USB key or run 
in a <br>
virtual machine, to test real hardware it needs to be run on a dedicated 
computer<br>
or maybe you just want to quickly test your new software masterpiece.</p>
<p align="left"><u><font size="4" color="#FF0000"><b>Connecting two computers 
together</b></font></u></p>
<p align="left">&nbsp;Simply use a null modem cable with the following 
connections:</p>
<p align="left">
<img border="0" src="NullModemCable.jpg" width="377" height="336"><br>
<br>
<u><b><font size="4" color="#FF0000">How to use Xfer.bin</font></b></u><br>
<br>
On your development machine, write your program you wish to test in the usual 
way, with one exception:<br>
Set the ORG directive to 36864 instead of the usual 32768.<br>
(The reason being that Xfer.bin is loaded at 32768 and when it downloads your<br>
newly compiled program, it's loaded and run in RAM at 36864).<br>
<br>
Now compile your program as usual using NASM.<br>
<br>
The address of 36864 was also chosen as MikeOS already uses this address to load<br>
pcx files to view.<br>
<br>
Start up Xfer.bin on the MikeOS computer and on the development computer<br>
start up HyperTerminal if you are using Windows or the equivalent in which ever<br>
distro of Linux you happen to be using.<br>
<br>
Make sure you set the transmission parameters to 9600bps, 8 bits, no parity and 
1 stop bit.<br>
You can alternatively use 1200 baud.<br>
<br>
Also ensure you have selected Xmodem with 128 byte packets and checksum and not 
another<br>
variant of the protocol such as Xmodem1K with CRC.<br>
<br>
Ensure that the sending computer is listening and ready to send <u><b>before 
selecting option 1 or 2 on Xfer.bin<br>
</b></u>The transfer to the MikeOS computer will commence.<br>
<br>
Once the download is complete, you can run your new program immediately by 
selecting option 3.<br>
Note however that the newly downloaded program exists only in RAM so if<br>
you reboot or switch off it's gone.<br>
<br>
If you're happy with your new program, simply go back to the source on the 
development<br>
machine and change ORG back to 32768.<br>
Recompile and it can now be included in your next MikeOS image.<br>
<br>
<u><font size="4" color="#FF0000"><b>Limitations, bugs and improvements.<br>
<br>
</b></font></u>- The size limit of the program to be downloaded is 16KB.<br>
&nbsp;&nbsp; Considering that the average size for a MikeOS program (excluding 
the kernel)<br>
&nbsp;&nbsp; is around 1KB, if your program is nearing the 16KB limit, it's 
probably &quot;bloatware&quot; ;-)<br>
&nbsp;&nbsp; Please note that I have not included any checks for size over-runs.<br>
&nbsp;&nbsp; If you do, it will over write code and crash and you will have to 
reboot.<br>
<br>
- Speed. <br>
&nbsp;&nbsp; At about 1 second/KB, it's not the fastest of transfer apps due to 
the fact that MikeOS is limited to 9600bps<br>
&nbsp; and Xmodem is not exactly the most efficient of protocols, but it's easy 
to code and gets the job done.<br>
<br>
Actually most modern serial ports can operate at up to 115K, but that creates a 
whole new range of problems and pitfalls.</p>
<p align="left">
-&nbsp; Since the transfer is not being done via modems but via a null modem 
cable, error checking is not really required.<br>
&nbsp;&nbsp; I've never had a single transfer error as yet.<br>
&nbsp;&nbsp; If&nbsp; however you want to add error checking/correction then proceed as 
follows:<br>
<br>
&nbsp;&nbsp; Store each of the 128 data bytes belonging to a&nbsp; packet into 
temp_store<br>
&nbsp;&nbsp; Save the received checksum byte that follows each packet into 
header_checksum<br>
&nbsp;&nbsp; Now add up all of the 128 bytes and save the result.<br>
&nbsp;&nbsp; Keep subtracting 256 from the result until you get 255 or less.<br>
&nbsp;&nbsp; Now compare this to the header_checksum saved earlier.<br>
&nbsp;&nbsp; If they are the same then all the data is OK and proceed to get the 
next packet by transmitting a ACK to the sending computer.<br>
&nbsp;&nbsp; If not the same then request the last packet to be re-sent by 
transmitting a NAK to the sending computer.<br>
<br>
The program could also benefit from having a routine that periodically checks 
for a key press should the sending computer stop<br>
transmitting data &quot;mid-stream&quot; for any reason.<br>
Due to time constraints, I haven't included these features into the program.<br>
It however greatly simplifies the compiling and testing of new programs for 
MikeOS especially if access to ports is required.<br>
(Normally a problem when running under a Virtual Machine in a non real time OS 
such as Linux or Windows).<br>
As time permits, I will improve on the program.<br>
<br>
- If you find any bugs, then please let me know via the MikeOS mailing list or 
via email: paulovalongo(-at-)rocketmail.com<br>
or even better, improve on the program and post it back so we can all benefit.</p>
<p align="left">
I release Xfer under the same terms and conditions as MikeOS.<br>
<br>
<u><font size="4" color="#FF0000"><b>Details about serial ports:</b></font></u></p>
<p align="left">
Depending on the age of the computer you are using, it will have one of these 
UART chips for the serial port:<br>
<br>
1) 8250 ,very old computer....consider donating to a museum, using as a door 
stop or boat anchor!!<br>
2) 16550/60, you will still come across these in computers older than about 8 
years.<br>
3) 16750, the newer computers use these.<br>
<br>
Actually newer computers don't have any of these chips, but instead use a chip 
called Super I/O<br>
which emulates the UART (Universal Asynchronous Receiver Transmitter)&nbsp; 
amongst other ports.<br>
This also applies to USB to Serial adapters.<br>
<br>
The key difference between these chips is the existence and size of a FIFO 
buffer.<br>
The 8250 only has a 1 byte&nbsp; buffer while the 16550 has 16 bytes and the 16750 has 64 bytes.<br>
<br>
Not having a buffer is OK if you are receiving the occasional ascii character 
followed by relatively<br>
long pauses in the order of tens of milliseconds such as when emulating a VT100 
terminal.<br>
But the situation quickly changes when receiving lots of consecutive bytes such 
as when using Xmodem<br>
or other protocols.<br>
Over-runs and lost data is guaranteed as the UART has no place to store 
received data until the program<br>
gets round to retrieving them.</p>
<p align="left">
You could always use an interrupt driven routine to alleviate this to a certain 
extent, but it's an unpleasant task.<br>
Also if you are receiving lots of data, then too many interrupts will be 
generated which actually becomes counter productive.<br>
So it's always better to stick to a polled based routine unless interrupts are 
absolutely required.</p>
<p align="left">
The FIFO buffer is deactivated by default and must be activated by writing to 
the appropriate registers.<br>
It is also good practise to clear the buffers of any residual data before using 
them and disabling the UART generated interrupts.<br>
The standard MikeOS os_serial_port_enable makes no provision for this so I have 
used direct register access instead (see code).<br>
Also some BIOS' can take up to 200uS to access the UART when using INT 14h which 
MikeOS relies on for os_get_via_serial.<br>
Again I have used my own routines.</p>
<p align="left">
Finally, I have assumed that your computer has either the 16550/650 or 750 UART 
and have set up the FIFO for 16 bytes.<br>
The 8250 is not supported nor is it tested for.<br>
&nbsp;</p>
<p align="left"><u><b><font size="4" color="#FF0000">Some Xmodem history:</font></b></u><br>
<br>
Xmodem&nbsp; was invented by Ward Christensen back in the mid-70's as a simple 
protocol<br>
which would enable almost any type of computer to transfer data using modems 
connected to telephone lines.</p>
<p align="left">There have been many changes and variants of the original 
protocol, but the original Xmodem is still<br>
widely used today especially in embedded systems where RAM and CPU power/speed 
is limited.<br>
Xmodem is perfectly suited to these systems due to it's small CPU demand.</p>
<p align="left">Ward Christensen developed Xmodem on the CP/M system in which 
all files are multiples of 128 bytes.<br>
The Xmodem protocol carries this particularity.<br>
This means that if you upload a file of say 120 bytes, the remaining 8 bytes 
will be padded. (normally with 1Ah).<br>
This is not a problem as the last byte of your compiled bin file should be a RET 
 so any data after that is ignored.</p>
<p align="left">Below is the structure of a Xmodem packet:</p>
<p align="left"><b><font size="4">&lt;</font></b>SOH<b><font size="4">&gt;&lt;</font></b>packet 
#<b><font size="4">&gt;&lt;</font></b>complement of packet #<b><font size="4">&gt;&lt;</font></b>128 
bytes of actual data<b><font size="4">&gt;&lt;</font></b>check sum<b><font size="4">&gt;</font></b></p>
<p align="left">The SOH byte is simply a start of packet marker (01h).<br>
Packet # is the packet number (1 to 255)<br>
Complement of packet # (255 - packet #)<br>
Then follows 128 bytes of actual data<br>
Then a 1 byte checksum.</p>
<p align="left">Total bytes per packet 132.<br>
<br>
To get the sending computer to transmit the next packet, the receiving computer 
sends it a ACK (06h)<br>
To get the sending computer to resend the last packet again, the receiving 
computer sends it a NAK (15h)<br>
Note that a NAK is also sent to the transmitting computer once at the beginning 
to initiate a transfer.<br>
If there are no more packets to send, the sending computer sends a EOT (04h) 
instead of SOH etc.<br>
The receiving computer then responds with a ACK (06h) and the transfer is 
complete.</p>
<p align="left">&nbsp;</p>
</body>

</html>