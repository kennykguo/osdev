     1                                  ; ------------------------------------------------------------------
     2                                  ; MichalOS Kernel
     3                                  ; ------------------------------------------------------------------
     4                                  
     5                                  	BITS 16
     6                                  	
     7                                  	ORG 32768
     8                                  	
     9                                  ; ------------------------------------------------------------------
    10                                  ; MACROS
    11                                  ; ------------------------------------------------------------------
    12                                  	
    13                                  %macro clr 1
    14                                  	xor %1, %1
    15                                  %endmacro
    16                                  
    17                                  %macro mov16 3
    18                                  	mov %1, (%2 + %3 * 256)
    19                                  %endmacro
    20                                  
    21                                  %define ADLIB_BUFFER 0500h
    22                                  %define DESKTOP_BACKGROUND 0600h
    23                                  %define SYSTEM_FONT 1600h
    24                                  %define FILE_MANAGER 2600h
    25                                  %define disk_buffer 0E000h
    26                                  
    27                                  ; ------------------------------------------------------------------
    28                                  ; MichalOS memory map:
    29                                  ; Segment 0000h:
    30                                  ;   - 0000h - 03FFh = Interrupt vector table
    31                                  ;   - 0400h - 04FFh = BIOS data area
    32                                  ;   - 0500h - 05FFh = AdLib register buffer
    33                                  ;   - 0600h - 15FFh = Desktop background (BG.ASC)
    34                                  ;   - 1600h - 25FFh = System font (FONT.SYS)
    35                                  ;   - 2600h - 35FFh = File manager (FILEMAN.APP)
    36                                  ; Segment 0360h:
    37                                  ;   - 0000h - 00FFh = System variables
    38                                  ;      - 0000h = RET instruction
    39                                  ;      - 0001h - 0050h = Footer buffer
    40                                  ;      - 0051h - 0081h = File selector filter buffer
    41                                  ;      - 0082h = System state (byte)
    42                                  ;         - 0 if a GUI application is running
    43                                  ;         - 1 if a non-GUI application is running (no header/footer)
    44                                  ;      - 0083h = Sound state (byte)
    45                                  ;         - 0 if sound disabled
    46                                  ;         - 1 if sound enabled
    47                                  ;      - 0084h = Default boot device (byte)
    48                                  ;      - 0085h = Default button for os_dialog_box (0 = OK, 1 = Cancel) (byte)
    49                                  ;      - 0086h = int_filename_convert error status (byte)
    50                                  ;         - 0 if filename too long
    51                                  ;         - 1 if filename empty
    52                                  ;         - 2 if no extension found
    53                                  ;         - 3 if no basename found
    54                                  ;         - 4 if extension too short
    55                                  ;      - 0087h = Flag for os_file_selector input (byte)
    56                                  ;      - 0088h = Maximum number of characters that os_input_string can input (byte)
    57                                  ;      - 0089h = Width of os_list_dialog (word)
    58                                  ;      - 00E0h - 00EFh - parameters for an app (eg. a file to open when an app launches)
    59                                  ;      - 00F0h - 00FFh - temporary buffer for storing apps' filenames
    60                                  ;   - 0100h - 7FFEh = Application
    61                                  ;   - 7FFEh - Application return flag
    62                                  ;      - 0 = return to the desktop after an application quits
    63                                  ;      - 1 = launch another application (00F0h-00FFh) after an application quits
    64                                  ;      (example: when a user opens an app through Terminal, then terminal stores its name to 00F0h-00FFh so it starts after the requested application exits)
    65                                  ;   - 7FFFh - Application launch flag
    66                                  ;      - 0 = return to the desktop after an application quits
    67                                  ;      - 1 = launch another application (filename passed in AX) after an application quits
    68                                  ;         - Note: after launching another application this flag is set to 0
    69                                  ;   - 8000h - DEA7h = MichalOS kernel
    70                                  ;   - DEA8h - DFFFh = Configuration file (SYSTEM.CFG)
    71                                  ;      - described in CONFIG.ASM
    72                                  ;   - E000h - FFFFh = Disk buffer
    73                                  ; End of memory: 2048 bytes stack
    74                                  ; ------------------------------------------------------------------
    75                                  
    76                                  ; ------------------------------------------------------------------
    77                                  ; OS CALL VECTORS
    78                                  
    79                                  os_call_vectors:
    80 00000000 E95601                  	jmp os_main					; 8000h -- Called from bootloader
    81 00000003 E9B018                  	jmp os_print_string			; 8003h
    82 00000006 E91E19                  	jmp os_move_cursor			; 8006h
    83 00000009 E90519                  	jmp os_clear_screen			; 8009h
    84 0000000C E93419                  	jmp os_print_horiz_line		; 800Ch
    85 0000000F E9ED1F                  	jmp os_print_newline		; 800Fh
    86 00000012 E92213                  	jmp os_wait_for_key			; 8012h
    87 00000015 E9C213                  	jmp os_check_for_key		; 8015h
    88 00000018 E9EA2B                  	jmp os_int_to_string		; 8018h
    89 0000001B E9CD26                  	jmp os_speaker_tone			; 801Bh
    90 0000001E E90A27                  	jmp os_speaker_off			; 801Eh
    91 00000021 E9260C                  	jmp os_load_file			; 8021h
    92 00000024 E96215                  	jmp os_pause				; 8024h
    93 00000027 E93316                  	jmp os_fatal_error			; 8027h
    94 0000002A E9051F                  	jmp os_draw_background		; 802Ah
    95 0000002D E9442A                  	jmp os_string_length		; 802Dh
    96 00000030 E99A2A                  	jmp os_string_uppercase		; 8030h
    97 00000033 E9B42A                  	jmp os_string_lowercase		; 8033h
    98 00000036 E93522                  	jmp os_input_string			; 8036h
    99 00000039 E9CB2A                  	jmp os_string_copy			; 8039h
   100 0000003C E9BA20                  	jmp os_dialog_box			; 803Ch
   101 0000003F E9CE2A                  	jmp os_string_join			; 803Fh
   102 00000042 E9D80A                  	jmp os_get_file_list		; 8042h
   103 00000045 E91E2B                  	jmp os_string_compare		; 8045h
   104 00000048 E9DB2A                  	jmp os_string_chomp			; 8048h
   105 0000004B E9702B                  	jmp os_string_to_hex		; 804Bh
   106 0000004E E9A427                  	jmp os_adlib_regwrite		; 804Eh
   107 00000051 E96C14                  	jmp os_bcd_to_int			; 8051h
   108 00000054 E9162C                  	jmp os_get_time_string		; 8054h
   109 00000057 E97224                  	jmp os_draw_logo			; 8057h
   110 0000005A E92C19                  	jmp os_file_selector		; 805Ah
   111 0000005D E9542C                  	jmp os_get_date_string		; 805Dh
   112 00000060 E91C18                  	jmp os_send_via_serial		; 8060h
   113 00000063 E92B18                  	jmp os_get_via_serial		; 8063h
   114 00000066 E9442A                  	jmp os_find_char_in_string	; 8066h
   115 00000069 E9C418                  	jmp os_get_cursor_pos		; 8069h
   116 0000006C E9C121                  	jmp os_print_space			; 806Ch
   117 0000006F E9E924                  	jmp os_option_menu			; 806Fh
   118 00000072 E9C321                  	jmp os_print_digit			; 8072h
   119 00000075 E9D221                  	jmp os_print_1hex			; 8075h
   120 00000078 E9D821                  	jmp os_print_2hex			; 8078h
   121 0000007B E9E321                  	jmp os_print_4hex			; 807Bh
   122 0000007E E90F48                  	jmp os_set_timer_speed		; 807Eh
   123 00000081 E9220A                  	jmp os_report_free_space	; 8081h
   124 00000084 E9DE29                  	jmp os_string_add			; 8084h
   125 00000087 E99326                  	jmp os_speaker_note_length	; 8087h
   126 0000008A E9CF18                  	jmp os_show_cursor			; 808Ah
   127 0000008D E9D718                  	jmp os_hide_cursor			; 808Dh
   128 00000090 E9791F                  	jmp os_dump_registers		; 8090h
   129 00000093 E9A21B                  	jmp os_list_dialog_tooltip	; 8093h
   130 00000096 E9130D                  	jmp os_write_file			; 8096h
   131 00000099 E9F20E                  	jmp os_file_exists			; 8099h
   132 0000009C E9100F                  	jmp os_create_file			; 809Ch
   133 0000009F E9EB0F                  	jmp os_remove_file			; 809Fh
   134 000000A2 E96A10                  	jmp os_rename_file			; 80A2h
   135 000000A5 E99C10                  	jmp os_get_file_size		; 80A5h
   136 000000A8 E9B81F                  	jmp os_input_dialog			; 80A8h
   137 000000AB E9C71B                  	jmp os_list_dialog			; 80ABh
   138 000000AE E9DC29                  	jmp os_string_reverse		; 80AEh
   139 000000B1 E9062B                  	jmp os_string_to_int		; 80B1h
   140 000000B4 E9BA18                  	jmp os_draw_block			; 80B4h
   141 000000B7 E9E113                  	jmp os_get_random			; 80B7h
   142 000000BA E9C82C                  	jmp os_print_32int			; 80BAh
   143 000000BD E9AB17                  	jmp os_serial_port_enable	; 80BDh
   144 000000C0 E9702B                  	jmp os_sint_to_string		; 80C0h
   145 000000C3 E9B72A                  	jmp os_string_parse			; 80C3h
   146 000000C6 E9C92C                  	jmp os_run_basic			; 80C6h
   147 000000C9 E9E428                  	jmp os_adlib_calcfreq		; 80C9h
   148 000000CC E99A47                  	jmp os_attach_app_timer		; 80CCh
   149 000000CF E9262C                  	jmp os_string_tokenize		; 80CFh
   150 000000D2 E9F414                  	jmp os_clear_registers		; 80D2h
   151 000000D5 E90818                  	jmp os_format_string		; 80D5h
   152 000000D8 E9C717                  	jmp os_putchar				; 80D8h
   153 000000DB E95626                  	jmp os_start_adlib			; 80DBh
   154 000000DE E99747                  	jmp os_return_app_timer		; 80DEh
   155 000000E1 E9C423                  	jmp os_reset_font			; 80E1h
   156 000000E4 E9DC17                  	jmp os_print_string_box		; 80E4h
   157 000000E7 E9BF17                  	jmp os_put_chars			; 80E7h
   158 000000EA E9E626                  	jmp os_check_adlib			; 80EAh
   159 000000ED E9AB48                  	jmp os_draw_line			; 80EDh
   160 000000F0 E9BA4A                  	jmp os_draw_polygon			; 80F0h
   161 000000F3 E93A4B                  	jmp os_draw_circle			; 80F3h
   162 000000F6 E9234B                  	jmp os_clear_graphics		; 80F6h
   163 000000F9 E97610                  	jmp os_get_file_datetime	; 80F9h
   164 000000FC E94129                  	jmp os_string_encrypt		; 80FCh
   165 000000FF E97648                  	jmp os_put_pixel			; 80FFh
   166 00000102 E97A48                  	jmp os_get_pixel			; 8102h
   167 00000105 E9DE23                  	jmp os_draw_icon			; 8105h
   168 00000108 E97826                  	jmp os_stop_adlib			; 8108h
   169 0000010B E90E29                  	jmp os_adlib_noteoff		; 810Bh
   170 0000010E E96916                  	jmp os_int_1Ah				; 810Eh
   171 00000111 E9C713                  	jmp os_int_to_bcd			; 8111h
   172 00000114 E9C514                  	jmp os_illegal_call			; 8114h ; FREE!!!!!!!!!!!!!!!!!!!
   173 00000117 E9931F                  	jmp os_password_dialog		; 8117h
   174 0000011A E99527                  	jmp os_adlib_mute			; 811Ah
   175 0000011D E9F949                  	jmp os_draw_rectangle		; 811Dh
   176 00000120 E93816                  	jmp os_get_memory			; 8120h
   177 00000123 E92522                  	jmp os_color_selector		; 8123h
   178 00000126 E9FA46                  	jmp os_modify_int_handler	; 8126h
   179 00000129 E9E52B                  	jmp os_32int_to_string		; 8129h
   180 0000012C E91423                  	jmp os_print_footer			; 812Ch
   181 0000012F E9BF22                  	jmp os_print_8hex			; 812Fh
   182 00000132 E9162C                  	jmp os_string_to_32int		; 8132h
   183 00000135 E9BD13                  	jmp os_math_power			; 8135h
   184 00000138 E9FF13                  	jmp os_math_root			; 8138h
   185 0000013B E99A21                  	jmp os_input_password		; 813Bh
   186 0000013E E9FC46                  	jmp os_get_int_handler		; 813Eh
   187 00000141 E99814                  	jmp os_illegal_call			; 8141h ; FREE!!!!!!!!!!!!!!!!!!!
   188 00000144 E9BD22                  	jmp os_temp_box				; 8144h
   189 00000147 E98C27                  	jmp os_adlib_unmute			; 8147h
   190 0000014A E9A809                  	jmp os_read_root			; 814Ah
   191 0000014D E98C14                  	jmp os_illegal_call			; 814Dh ; FREE!!!!!!!!!!!!!!!!!!!
   192 00000150 E98914                  	jmp os_illegal_call			; 8150h ; FREE!!!!!!!!!!!!!!!!!!!
   193 00000153 E98614                  	jmp os_illegal_call			; 8153h ; FREE!!!!!!!!!!!!!!!!!!!
   194 00000156 E9AE11                  	jmp disk_convert_l2hts		; 8156h
   195                                  	
   196                                  ; ------------------------------------------------------------------
   197                                  ; START OF MAIN KERNEL CODE
   198                                  
   199                                  os_main:
   200 00000159 CD12                    	int 12h						; Get RAM size
   201 0000015B 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   202 0000015C C1E006                  	shl ax, 6					; Convert kB to segments
   203                                  
   204 0000015F FA                      	cli
   205                                  
   206 00000160 2D0010                  	sub ax, 65536 / 16			; Set the stack to the top of the memory
   207 00000163 8ED0                    	mov ss, ax
   208 00000165 BCFEFF                  	mov sp, 0FFFEh
   209                                  
   210                                  ;	xor ax, ax
   211                                  ;	mov ss, ax					; Set stack segment and pointer
   212                                  ;	mov sp, 0FFFEh
   213                                  
   214 00000168 FB                      	sti
   215                                  
   216 00000169 FC                      	cld							; The default direction for string operations
   217                                  								; will be 'up' - incrementing address in RAM
   218                                  
   219 0000016A 8CC8                    	mov ax, cs					; Set all segments to match where kernel is loaded
   220 0000016C 8ED8                    	mov ds, ax			
   221 0000016E 8EC0                    	mov es, ax
   222 00000170 8E26[9405]              	mov fs, [driversgmt]
   223 00000174 050010                  	add ax, 1000h
   224 00000177 8EE8                    	mov gs, ax
   225                                  	
   226 00000179 C6060000C3              	mov byte [0000h], 0xC3
   227 0000017E 88168400                	mov [0084h], dl
   228 00000182 8816[3613]              	mov [bootdev], dl			; Save boot device number
   229 00000186 C6068800FF              	mov byte [0088h], 255
   230 0000018B C70689004C00            	mov word [0089h], 76
   231 00000191 C606E00000              	mov byte [00E0h], 0
   232                                  
   233 00000196 891E[3213]              	mov [Sides], bx
   234 0000019A 890E[3413]              	mov [SecsPerTrack], cx
   235                                  
   236                                  	clr ax
    14 0000019E 31C0                <1>  xor %1, %1
   237 000001A0 E8C816                  	call os_serial_port_enable
   238                                  
   239                                  	; Load the files
   240                                  	
   241 000001A3 06                      	push es
   242 000001A4 8E06[9405]              	mov es, [driversgmt]
   243                                  	
   244 000001A8 B8[2707]                	mov ax, fileman_name
   245 000001AB B90026                  	mov cx, FILE_MANAGER
   246 000001AE E8990A                  	call os_load_file
   247                                  	
   248 000001B1 B8[5407]                	mov ax, bg_name
   249 000001B4 B90006                  	mov cx, DESKTOP_BACKGROUND
   250 000001B7 E8900A                  	call os_load_file
   251 000001BA 7305                    	jnc .background_ok
   252                                  	
   253 000001BC C606000600              	mov byte [DESKTOP_BACKGROUND], 0
   254                                  	
   255                                  .background_ok:	
   256 000001C1 B8[4B07]                	mov ax, font_name
   257 000001C4 B90016                  	mov cx, SYSTEM_FONT
   258 000001C7 E8800A                  	call os_load_file
   259                                  	
   260 000001CA 07                      	pop es
   261                                  	
   262 000001CB FA                      	cli
   263                                  
   264 000001CC 8CCF                    	mov di, cs
   265                                  
   266 000001CE B100                    	mov cl, 00h					; Divide by 0 error handler
   267 000001D0 BE[A348]                	mov si, os_compat_int00
   268 000001D3 E84D46                  	call os_modify_int_handler
   269                                  
   270 000001D6 B10C                    	mov cl, 0Ch					; Stack overflow
   271 000001D8 BE[E048]                	mov si, os_compat_int0C
   272 000001DB E84546                  	call os_modify_int_handler
   273                                  
   274 000001DE B105                    	mov cl, 05h					; Debugger
   275 000001E0 BE[C548]                	mov si, os_compat_int05
   276 000001E3 E83D46                  	call os_modify_int_handler
   277                                  	
   278 000001E6 B106                    	mov cl, 06h					; Bad instruction error handler
   279 000001E8 BE[FA48]                	mov si, os_compat_int06
   280 000001EB E83546                  	call os_modify_int_handler
   281                                  
   282 000001EE B107                    	mov cl, 07h					; Processor extension error handler
   283 000001F0 BE[1449]                	mov si, os_compat_int07
   284 000001F3 E82D46                  	call os_modify_int_handler
   285                                  
   286 000001F6 B11C                    	mov cl, 1Ch					; RTC handler
   287 000001F8 BE[3949]                	mov si, os_compat_int1C
   288 000001FB E82546                  	call os_modify_int_handler
   289                                  	
   290 000001FE FB                      	sti
   291                                  
   292                                  ;	int 5
   293                                  	
   294 000001FF E87912                  	call os_seed_random
   295                                  
   296 00000202 BF0001                  	mov di, 100h
   297 00000205 B000                    	mov al, 0
   298 00000207 B9FF7E                  	mov cx, 7EFFh
   299 0000020A F3AA                    	rep stosb
   300                                  
   301 0000020C E89922                  	call os_reset_font
   302                                  
   303 0000020F B80310                  	mov ax, 1003h				; Set text output with certain attributes
   304 00000212 B300                    	mov bl, 0					; to be bright, and not blinking
   305 00000214 CD10                    	int 10h
   306                                  	
   307 00000216 B80503                  	mov ax, 0305h
   308 00000219 BB0401                  	mov bx, 0104h
   309 0000021C CD16                    	int 16h
   310                                  	
   311 0000021E C606820000              	mov byte [0082h], 0
   312                                  	
   313 00000223 B8[4007]                	mov ax, system_cfg			; Try to load SYSTEM.CFG
   314 00000226 B9A8DE                  	mov cx, 57000
   315 00000229 E81E0A                  	call os_load_file
   316                                  
   317 0000022C A0EDDE                  	mov al, [57069]				; Copy the default sound volume (on/off)
   318 0000022F A28300                  	mov [0083h], al
   319                                  	
   320 00000232 0F828B02                	jc load_demotour			; If failed, it doesn't exist, so the system is run for the first time
   321                                  	
   322                                  logoinput:
   323 00000236 B8[034D]                	mov ax, osname				; Set up the welcome screen
   324 00000239 BB[6F07]                	mov bx, empty_string
   325 0000023C B90700                  	mov cx, 07h					; Colour: black
   326 0000023F E8F01C                  	call os_draw_background
   327                                  
   328 00000242 BA0009                  	mov dx, 9 * 256
   329 00000245 E8DF16                  	call os_move_cursor
   330                                  
   331 00000248 B82009                  	mov ax, 0920h
   332 0000024B BB0400                  	mov bx, 00000100b
   333 0000024E B93002                  	mov cx, 560
   334 00000251 CD10                    	int 10h
   335                                  	
   336 00000253 BE[260A]                	mov si, logo
   337 00000256 E88D22                  	call os_draw_icon
   338                                  
   339 00000259 BA0216                  	mov dx, 22 * 256 + 2
   340 0000025C E8C816                  	call os_move_cursor
   341                                  
   342 0000025F BE[D202]                	mov si, passwordmsg
   343 00000262 E85116                  	call os_print_string
   344 00000265 E8FF16                  	call os_hide_cursor
   345                                  
   346 00000268 B80B02                  	mov ax, 523
   347 0000026B B90200                  	mov cx, 2
   348 0000026E E8AC24                  	call os_speaker_note_length
   349                                  
   350 00000271 E8C310                  	call os_wait_for_key
   351                                  	
   352                                  enterpressed:
   353 00000274 E8E516                  	call os_show_cursor
   354 00000277 803EAADE00              	cmp byte [57002], 0				; Is the password disabled?
   355 0000027C 743D                    	je checkformenu				; If it is, continue
   356                                  
   357                                  .try:	
   358 0000027E BA0016                  	mov dx, 22 * 256					; Clean the text on the screen
   359 00000281 E8A316                  	call os_move_cursor
   360                                  
   361 00000284 B82009                  	mov ax, 0920h
   362 00000287 BB0700                  	mov bx, 7
   363 0000028A B95000                  	mov cx, 80
   364 0000028D CD10                    	int 10h
   365                                  	
   366 0000028F BA0216                  	mov dx, 22 * 256 + 2					; Ask for the password
   367 00000292 E89216                  	call os_move_cursor
   368 00000295 BE[ED02]                	mov si, passentermsg
   369 00000298 E81B16                  	call os_print_string
   370                                  	
   371 0000029B B80001                  	mov ax, 100h
   372 0000029E B307                    	mov bl, 7
   373 000002A0 C606880020              	mov byte [0088h], 32
   374 000002A5 E83020                  	call os_input_password
   375 000002A8 C6068800FF              	mov byte [0088h], 255
   376                                  
   377 000002AD BE0001                  	mov si, 100h
   378 000002B0 E88D27                  	call os_string_encrypt
   379                                  
   380 000002B3 BFABDE                  	mov di, 57003
   381 000002B6 E8AD28                  	call os_string_compare
   382 000002B9 73C3                    	jnc .try
   383                                  	
   384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;end LOGO!
   385                                  	
   386                                  checkformenu:
   387 000002BB E8A916                  	call os_hide_cursor
   388 000002BE E8B102                  	call background
   389                                  
   390                                  checkformenuloop:	
   391 000002C1 E87310                  	call os_wait_for_key
   392 000002C4 3C20                    	cmp al, 32					; Space pressed?
   393 000002C6 0F847F00                	je near option_screen		; Open the menu
   394 000002CA 3C61                    	cmp al, 'a'					; a pressed?
   395 000002CC 0F84DE01                	je near load_fileman		; Open the file manager
   396 000002D0 EBEF                    	jmp checkformenuloop
   397                                  	
   398 000002D2 507265737320616E79-     	passwordmsg			db 'Press any key to log in...', 0
   398 000002DB 206B657920746F206C-
   398 000002E4 6F6720696E2E2E2E00 
   399 000002ED 456E74657220796F75-     	passentermsg		db 'Enter your password: ', 0
   399 000002F6 722070617373776F72-
   399 000002FF 643A2000           
   400                                  
   401 00000303 4D696368616C4F5320-     	os_init_msg			db 'MichalOS Desktop', 0
   401 0000030C 4465736B746F7000   
   402 00000314 5B53706163655D204F-     	os_version_msg		db '[Space] Open the main menu [A] Open the file manager', 0
   402 0000031D 70656E20746865206D-
   402 00000326 61696E206D656E7520-
   402 0000032F 5B415D204F70656E20-
   402 00000338 7468652066696C6520-
   402 00000341 6D616E6167657200   
   403                                  
   404                                  ; TODO: THE FOLLOWING CODE NEEDS TO BE REWRITTEN
   405                                  	
   406                                  option_screen:
   407 00000349 E83502                  	call menu_background
   408                                  
   409 0000034C B8[7007]                	mov ax, menuoptions
   410 0000034F BB0D00                  	mov bx, 13
   411 00000352 E80622                  	call os_option_menu
   412                                  
   413 00000355 0F8262FF                	jc checkformenu
   414                                  	
   415 00000359 83F801                  	cmp ax, 1
   416 0000035C 0F841500                	je near app_selector
   417                                  
   418 00000360 83F802                  	cmp ax, 2
   419 00000363 0F848000                	je near game_selector
   420                                  	
   421 00000367 83F803                  	cmp ax, 3
   422 0000036A 0F84C8FE                	je near logoinput
   423                                  	
   424 0000036E 83F804                  	cmp ax, 4
   425 00000371 0F849B49                	je near os_shutdown
   426                                  
   427                                  app_selector:
   428 00000375 E80902                  	call menu_background
   429                                  
   430 00000378 B8[C808]                	mov ax, progoptions
   431 0000037B BB1400                  	mov bx, 20
   432 0000037E E8DA21                  	call os_option_menu
   433                                  
   434 00000381 72C6                    	jc option_screen
   435                                  
   436 00000383 83F801                  	cmp ax, 1
   437 00000386 0F842401                	je near load_fileman
   438                                  
   439 0000038A 83F80D                  	cmp ax, 13
   440 0000038D 0F842500                	je near debug_stuff
   441                                  	
   442 00000391 89C6                    	mov si, ax
   443 00000393 83EE02                  	sub si, 2
   444 00000396 D1E6                    	shl si, 1
   445 00000398 81C6[CD05]              	add si, appindex1
   446 0000039C AD                      	lodsw
   447 0000039D 89C6                    	mov si, ax
   448 0000039F BF0001                  	mov di, 0100h
   449 000003A2 E86227                  	call os_string_copy
   450                                  	
   451 000003A5 B80001                  	mov ax, 0100h
   452 000003A8 BB[1E07]                	mov bx, app_prefix
   453 000003AB B9F000                  	mov cx, 00F0h
   454 000003AE E85F27                  	call os_string_join
   455                                  	
   456 000003B1 89CB                    	mov bx, cx
   457 000003B3 E93201                  	jmp start_program
   458                                  	
   459                                  debug_stuff:
   460 000003B6 E8C801                  	call menu_background
   461                                  
   462 000003B9 B8[F607]                	mov ax, debugoptions
   463 000003BC BB1F00                  	mov bx, 31
   464 000003BF E89921                  	call os_option_menu
   465                                  	
   466 000003C2 72B1                    	jc app_selector
   467                                  	
   468 000003C4 89C6                    	mov si, ax
   469 000003C6 4E                      	dec si
   470 000003C7 D1E6                    	shl si, 1
   471 000003C9 81C6[E305]              	add si, debugindex1
   472 000003CD AD                      	lodsw
   473 000003CE 89C6                    	mov si, ax
   474 000003D0 BF0001                  	mov di, 0100h
   475 000003D3 E83127                  	call os_string_copy
   476                                  	
   477 000003D6 B80001                  	mov ax, 0100h
   478 000003D9 BB[1E07]                	mov bx, app_prefix
   479 000003DC B9F000                  	mov cx, 00F0h
   480 000003DF E82E27                  	call os_string_join
   481                                  	
   482 000003E2 89CB                    	mov bx, cx
   483 000003E4 E90101                  	jmp start_program
   484                                  	
   485                                  	
   486                                  game_selector:
   487 000003E7 E89701                  	call menu_background
   488                                  
   489 000003EA B8[9107]                	mov ax, gameoptions
   490 000003ED BB1300                  	mov bx, 19
   491 000003F0 E86821                  	call os_option_menu
   492                                  
   493 000003F3 0F8252FF                	jc option_screen
   494                                  
   495 000003F7 89C6                    	mov si, ax
   496 000003F9 4E                      	dec si
   497 000003FA D1E6                    	shl si, 1
   498 000003FC 81C6[FB05]              	add si, gameindex1
   499 00000400 AD                      	lodsw
   500                                  	
   501                                  launch_program:
   502 00000401 C606FF7F00              	mov byte [32767], 0
   503                                  
   504 00000406 E86901                  	call background
   505                                  	
   506 00000409 60                      	pusha
   507 0000040A 89C6                    	mov si, ax
   508 0000040C 89F3                    	mov bx, si
   509 0000040E 89F0                    	mov ax, si
   510 00000410 E86126                  	call os_string_length
   511 00000413 89DE                    	mov si, bx
   512 00000415 01C6                    	add si, ax				; SI now points to end of filename...
   513 00000417 4E                      	dec si
   514 00000418 4E                      	dec si
   515 00000419 4E                      	dec si					; ...and now to start of extension!
   516 0000041A BF[1F07]                	mov di, app_ext
   517 0000041D B90300                  	mov cx, 3
   518 00000420 F3A6                    	rep cmpsb				; Are final 3 chars 'APP'?
   519 00000422 7521                    	jne launch_basic		; If not, try 'BAS'
   520 00000424 61                      	popa
   521                                  	
   522 00000425 B90001                  	mov cx, 100h			; Where to load the program file
   523 00000428 E81F08                  	call os_load_file		; Load filename pointed to by AX
   524                                  
   525 0000042B 0F828CFE                	jc checkformenu
   526                                  	
   527 0000042F 60                      	pusha
   528 00000430 B9FD7E                  	mov cx, 7EFDh
   529 00000433 29D9                    	sub cx, bx
   530 00000435 BF0001                  	mov di, 100h
   531 00000438 01DF                    	add di, bx
   532 0000043A B000                    	mov al, 0
   533 0000043C F3AA                    	rep stosb
   534 0000043E 61                      	popa
   535                                  	
   536 0000043F E81A15                  	call os_show_cursor
   537                                  	
   538 00000442 E9CB00                  	jmp execute_bin_program
   539                                  
   540                                  launch_basic:
   541 00000445 61                      	popa
   542                                  	
   543 00000446 60                      	pusha
   544 00000447 89C6                    	mov si, ax
   545 00000449 89F3                    	mov bx, si
   546 0000044B 89F0                    	mov ax, si
   547 0000044D E82426                  	call os_string_length
   548 00000450 89DE                    	mov si, bx
   549 00000452 01C6                    	add si, ax				; SI now points to end of filename...
   550 00000454 4E                      	dec si
   551 00000455 4E                      	dec si
   552 00000456 4E                      	dec si					; ...and now to start of extension!
   553 00000457 BF[2307]                	mov di, bas_ext
   554 0000045A B90300                  	mov cx, 3
   555 0000045D F3A6                    	rep cmpsb				; Are final 3 chars 'BAS'?
   556 0000045F 753A                    	jne program_error		; If not, error out
   557 00000461 61                      	popa
   558                                  
   559 00000462 B90001                  	mov cx, 100h			; Where to load the program file
   560 00000465 E8E207                  	call os_load_file		; Load filename pointed to by AX
   561                                  
   562 00000468 0F824FFE                	jc checkformenu
   563                                  	
   564 0000046C 60                      	pusha
   565 0000046D B9FD7E                  	mov cx, 7EFDh
   566 00000470 29D9                    	sub cx, bx
   567 00000472 BF0001                  	mov di, 100h
   568 00000475 01DF                    	add di, bx
   569 00000477 B000                    	mov al, 0
   570 00000479 F3AA                    	rep stosb
   571 0000047B 61                      	popa
   572                                  
   573 0000047C E8DD14                  	call os_show_cursor
   574                                  	
   575 0000047F B80001                  	mov ax, 100h
   576                                  	clr si
    14 00000482 31F6                <1>  xor %1, %1
   577 00000484 E80B29                  	call os_run_basic
   578                                  
   579 00000487 BE[5B07]                	mov si, basic_finished_msg
   580 0000048A E82914                  	call os_print_string
   581 0000048D E8A70E                  	call os_wait_for_key
   582                                  
   583 00000490 E87E14                  	call os_clear_screen
   584                                  	
   585 00000493 C606820000              	mov byte [0082h], 0
   586                                  	
   587 00000498 E920FE                  	jmp checkformenu
   588                                  	
   589                                  program_error:
   590 0000049B 61                      	popa
   591 0000049C E8D300                  	call background
   592 0000049F B8[9605]                	mov ax, prog_msg
   593                                  	clr bx
    14 000004A2 31DB                <1>  xor %1, %1
   594                                  	clr cx
    14 000004A4 31C9                <1>  xor %1, %1
   595                                  	clr dx
    14 000004A6 31D2                <1>  xor %1, %1
   596 000004A8 E84E1C                  	call os_dialog_box
   597 000004AB E90DFE                  	jmp checkformenu
   598                                  	
   599                                  load_fileman:
   600 000004AE 1E                      	push ds
   601 000004AF 8E1E[9405]              	mov ds, [driversgmt]
   602 000004B3 BE0026                  	mov si, FILE_MANAGER
   603 000004B6 BF0001                  	mov di, 0100h
   604 000004B9 B90010                  	mov cx, 1000h
   605 000004BC F3A4                    	rep movsb
   606 000004BE 1F                      	pop ds
   607 000004BF EB4F                    	jmp execute_bin_program
   608                                  	
   609                                  load_demotour:
   610 000004C1 C606830001              	mov byte [0083h], 1
   611 000004C6 B8[3307]                	mov ax, demotour_name
   612 000004C9 B90001                  	mov cx, 100h
   613 000004CC E87B07                  	call os_load_file
   614 000004CF E8F710                  	call os_clear_registers
   615 000004D2 E8(0001)                	call 100h
   616 000004D5 E95EFD                  	jmp logoinput
   617                                  	
   618                                  load_command:
   619 000004D8 B8[2606]                	mov ax, cmd_name
   620 000004DB BB[1E07]                	mov bx, app_prefix
   621 000004DE B9F000                  	mov cx, 00F0h
   622 000004E1 E82C26                  	call os_string_join
   623 000004E4 89CB                    	mov bx, cx
   624 000004E6 EB00                    	jmp start_program
   625                                  	
   626                                  start_program:				; BX = program name
   627 000004E8 60                      	pusha
   628 000004E9 B9FD7E                  	mov cx, 7EFDh
   629 000004EC BF0001                  	mov di, 100h
   630 000004EF B000                    	mov al, 0
   631 000004F1 F3AA                    	rep stosb
   632 000004F3 61                      	popa
   633                                  	
   634 000004F4 89D8                    	mov ax, bx
   635 000004F6 B90001                  	mov cx, 100h			; Where to load the program file
   636 000004F9 E84E07                  	call os_load_file		; Load filename pointed to by AX
   637                                  
   638 000004FC 0F828E00                	jc systemfilemissing
   639                                  	
   640 00000500 E85914                  	call os_show_cursor
   641                                  
   642 00000503 EB0B                    	jmp execute_bin_program
   643                                  	
   644                                  return_to_app:
   645 00000505 B8F000                  	mov ax, 00F0h
   646 00000508 B90001                  	mov cx, 100h			; Where to load the program file
   647 0000050B E83C07                  	call os_load_file		; Load filename pointed to by AX
   648                                  
   649 0000050E 727E                    	jc systemfilemissing	
   650                                  
   651                                  execute_bin_program:
   652 00000510 E8FE13                  	call os_clear_screen	; Clear the screen before running
   653                                  
   654 00000513 C606820000              	mov byte [0082h], 0
   655                                  	
   656 00000518 C606[7109]01            	mov byte [app_running], 1
   657                                  
   658 0000051D 8926[6F09]              	mov [origstack], sp
   659                                  	
   660 00000521 E8A510                  	call os_clear_registers
   661                                  	
   662 00000524 E8(0001)                	call 100h	
   663                                  	
   664                                  finish:
   665 00000527 C606[7109]00            	mov byte [app_running], 0
   666                                  	
   667 0000052C E85422                  	call os_stop_adlib		; Reset everything (in case the app crashed or something)
   668 0000052F E8F921                  	call os_speaker_off
   669                                  
   670 00000532 50                      	push ax
   671 00000533 8CC8                    	mov ax, cs
   672 00000535 8ED8                    	mov ds, ax
   673 00000537 8EC0                    	mov es, ax
   674 00000539 58                      	pop ax
   675                                  	
   676 0000053A 60                      	pusha
   677 0000053B B40F                    	mov ah, 0Fh				; Get the current video mode
   678 0000053D CD10                    	int 10h
   679                                  	
   680 0000053F 3C03                    	cmp al, 3
   681 00000541 7405                    	je .skip_gfx
   682                                  	
   683 00000543 B80300                  	mov ax, 3
   684 00000546 CD10                    	int 10h
   685                                  
   686                                  .skip_gfx:
   687 00000548 B80310                  	mov ax, 1003h			; Set text output with certain attributes
   688                                  	clr bx					; to be bright, and not blinking
    14 0000054B 31DB                <1>  xor %1, %1
   689 0000054D CD10                    	int 10h
   690                                  
   691 0000054F C606820000              	mov byte [0082h], 0
   692 00000554 C606850000              	mov byte [0085h], 0
   693                                  	
   694 00000559 E84C1F                  	call os_reset_font
   695 0000055C 61                      	popa
   696                                  	
   697 0000055D 803EFF7F01              	cmp byte [7FFFh], 1
   698 00000562 0F849BFE                	je near launch_program
   699                                  	
   700 00000566 803EFE7F01              	cmp byte [7FFEh], 1
   701 0000056B 0F8496FF                	je near return_to_app
   702                                  	
   703 0000056F E949FD                  	jmp checkformenu		; When finished, go back to the program list
   704                                  
   705                                  	
   706                                  ; TODO: THE CODE ABOVE NEEDS TO BE REWRITTEN
   707                                  	
   708                                  background:
   709 00000572 60                      	pusha
   710 00000573 B8[0303]                	mov ax, os_init_msg		; Draw main screen layout
   711 00000576 BB[1403]                	mov bx, os_version_msg
   712 00000579 B90001                  	mov cx, 256				; Colour: white text on light blue
   713 0000057C E8B319                  	call os_draw_background
   714 0000057F 61                      	popa
   715 00000580 C3                      	ret
   716                                  
   717                                  menu_background:
   718 00000581 60                      	pusha
   719 00000582 803EEFDE01              	cmp byte [57071], 1
   720 00000587 7403                    	je .done
   721                                  	
   722 00000589 E8E6FF                  	call background
   723                                  	
   724                                  .done:
   725 0000058C 61                      	popa
   726 0000058D C3                      	ret
   727                                  	
   728                                  systemfilemissing:
   729 0000058E B8[B705]                	mov ax, noprogerror
   730 00000591 E8C910                  	call os_fatal_error
   731                                  	
   732                                  	; And now data for the above code...
   733                                  
   734 00000594 0000                    	driversgmt				dw 0000h
   735                                  	
   736 00000596 546869732066696C65-     	prog_msg				db 'This file is not an application!', 0
   736 0000059F 206973206E6F742061-
   736 000005A8 6E206170706C696361-
   736 000005B1 74696F6E2100       
   737                                  
   738 000005B7 53797374656D206669-     	noprogerror				db 'System file not found', 0
   738 000005C0 6C65206E6F7420666F-
   738 000005C9 756E6400           
   739                                  
   740 000005CD [0F06][1406][1B06]-     	appindex1				dw edit_name, viewer_name, calc_name, clock_name, cmd_name, config_name, ascii_name, pixel_name, player_name, hwcheck_name, about_name
   740 000005D3 [2006][2606][2F06]-
   740 000005D9 [3606][3F06][4506]-
   740 000005DF [4C06][5406]       
   741 000005E3 [5A06][6306][6B06]-     	debugindex1				dw debug1_name, debug2_name, debug3_name, debug4_name, debug5_name, debug6_name, debug7_name, debug8_name, debug11_name, debug12_name, debug13_name, debug14_name
   741 000005E9 [7206][7A06][8106]-
   741 000005EF [8906][8F06][9406]-
   741 000005F5 [9A06][A006][A506] 
   742 000005FB [AC06][B306][C006]-     	gameindex1				dw cf_name, inkspill_name, spaceinv_name, asmtris_name, sudoku_name, fisher_name, miketron_name, muncher_name, hangman_name, snake_name
   742 00000601 [CD06][D906][E406]-
   742 00000607 [EF06][FC06][0807]-
   742 0000060D [1407]             
   743                                  	
   744 0000060F 4544495400              	edit_name				db 'EDIT', 0
   745 00000614 56494557455200          	viewer_name				db 'VIEWER', 0
   746 0000061B 43414C4300              	calc_name				db 'CALC', 0
   747 00000620 434C4F434B00            	clock_name				db 'CLOCK', 0
   748 00000626 5445524D494E414C00      	cmd_name				db 'TERMINAL', 0
   749 0000062F 434F4E46494700          	config_name				db 'CONFIG', 0
   750 00000636 415343494941525400      	ascii_name				db 'ASCIIART', 0
   751 0000063F 504958454C00            	pixel_name				db 'PIXEL', 0
   752 00000645 504C4159455200          	player_name				db 'PLAYER', 0
   753 0000064C 4857434845434B00        	hwcheck_name			db 'HWCHECK', 0
   754 00000654 41424F555400            	about_name				db 'ABOUT', 0
   755                                  
   756 0000065A 4449534B5445535400      	debug1_name				db 'DISKTEST', 0
   757 00000663 4B42445445535400        	debug2_name				db 'KBDTEST', 0
   758 0000066B 53455249414C00          	debug3_name				db 'SERIAL', 0
   759 00000672 5254435445535400        	debug4_name				db 'RTCTEST', 0
   760 0000067A 534543544F5200          	debug5_name				db 'SECTOR', 0
   761 00000681 4D454D4544495400        	debug6_name				db 'MEMEDIT', 0
   762 00000689 424F58455300            	debug7_name				db 'BOXES', 0
   763 0000068F 444F545300              	debug8_name				db 'DOTS', 0
   764 00000694 434845434B00            	debug11_name			db 'CHECK', 0
   765 0000069A 524454534300            	debug12_name			db 'RDTSC', 0
   766 000006A0 5445535400              	debug13_name			db 'TEST', 0
   767 000006A5 53544154494300          	debug14_name			db 'STATIC', 0
   768                                  	
   769 000006AC 43462E42415300          	cf_name					db 'CF.BAS', 0
   770 000006B3 494E4B5350494C4C2E-     	inkspill_name			db 'INKSPILL.BAS', 0
   770 000006BC 42415300           
   771 000006C0 5350414345494E562E-     	spaceinv_name			db 'SPACEINV.APP', 0
   771 000006C9 41505000           
   772 000006CD 41534D545249532E41-     	asmtris_name			db 'ASMTRIS.APP', 0
   772 000006D6 505000             
   773 000006D9 5355444F4B552E4150-     	sudoku_name				db 'SUDOKU.APP', 0
   773 000006E2 5000               
   774 000006E4 4649534845522E4150-     	fisher_name				db 'FISHER.APP', 0
   774 000006ED 5000               
   775 000006EF 4D494B4554524F4E2E-     	miketron_name			db 'MIKETRON.BAS', 0
   775 000006F8 42415300           
   776 000006FC 4D554E434845522E42-     	muncher_name			db 'MUNCHER.BAS', 0
   776 00000705 415300             
   777 00000708 48414E474D414E2E41-     	hangman_name			db 'HANGMAN.APP', 0
   777 00000711 505000             
   778 00000714 534E414B452E415050-     	snake_name				db 'SNAKE.APP', 0
   778 0000071D 00                 
   779                                  	
   780 0000071E 2E                      	app_prefix				db '.'
   781 0000071F 41505000                	app_ext					db 'APP', 0
   782 00000723 42415300                	bas_ext					db 'BAS', 0
   783                                  
   784 00000727 46494C454D414E2E41-     	fileman_name			db 'FILEMAN.APP', 0
   784 00000730 505000             
   785 00000733 44454D4F544F55522E-     	demotour_name			db 'DEMOTOUR.APP', 0
   785 0000073C 41505000           
   786 00000740 53595354454D2E4346-     	system_cfg				db 'SYSTEM.CFG', 0
   786 00000749 4700               
   787 0000074B 464F4E542E53595300      	font_name				db 'FONT.SYS', 0
   788 00000754 42472E53595300          	bg_name					db 'BG.SYS', 0
   789                                  	
   790 0000075B 42415349432070726F-     	basic_finished_msg		db 'BASIC program ended', 0
   790 00000764 6772616D20656E6465-
   790 0000076D 6400               
   791                                  
   792 0000076F 00                      	empty_string			db 0
   793                                  	
   794 00000770 50726F6772616D732C-     	menuoptions				db 'Programs,Games,Log out,Shut down', 0
   794 00000779 47616D65732C4C6F67-
   794 00000782 206F75742C53687574-
   794 0000078B 20646F776E00       
   795 00000791 436F736D696320466C-     	gameoptions				db 'Cosmic Flight,InkSpill,Space Inventors,aSMtris,Sudoku,Deep Sea Fisher,MikeTron,Muncher,Hangman,Snake', 0
   795 0000079A 696768742C496E6B53-
   795 000007A3 70696C6C2C53706163-
   795 000007AC 6520496E76656E746F-
   795 000007B5 72732C61534D747269-
   795 000007BE 732C5375646F6B752C-
   795 000007C7 446565702053656120-
   795 000007D0 4669736865722C4D69-
   795 000007D9 6B6554726F6E2C4D75-
   795 000007E2 6E636865722C48616E-
   795 000007EB 676D616E2C536E616B-
   795 000007F4 6500               
   796 000007F6 4469736B2064657465-     	debugoptions			db 'Disk detection test,Keyboard tester,Serial communication tester,RTC clock tester,Disk Sector inspector,Memory editor,Boxes,Dots,Disk sector checker,TSC register tester,Simple test app,TV static generator (CGA)', 0
   796 000007FF 6374696F6E20746573-
   796 00000808 742C4B6579626F6172-
   796 00000811 64207465737465722C-
   796 0000081A 53657269616C20636F-
   796 00000823 6D6D756E6963617469-
   796 0000082C 6F6E20746573746572-
   796 00000835 2C52544320636C6F63-
   796 0000083E 6B207465737465722C-
   796 00000847 4469736B2053656374-
   796 00000850 6F7220696E73706563-
   796 00000859 746F722C4D656D6F72-
   796 00000862 7920656469746F722C-
   796 0000086B 426F7865732C446F74-
   796 00000874 732C4469736B207365-
   796 0000087D 63746F722063686563-
   796 00000886 6B65722C5453432072-
   796 0000088F 656769737465722074-
   796 00000898 65737465722C53696D-
   796 000008A1 706C65207465737420-
   796 000008AA 6170702C5456207374-
   796 000008B3 617469632067656E65-
   796 000008BC 7261746F7220284347-
   796 000008C5 412900             
   797 000008C8 46696C65206D616E61-     	progoptions				db 'File manager,Text editor,Image viewer,Calculator,Clock,Terminal,Settings,ASCII art editor,Pixel art editor,Music player,Hardware checker,About MichalOS,Other stuff...', 0
   797 000008D1 6765722C5465787420-
   797 000008DA 656469746F722C496D-
   797 000008E3 616765207669657765-
   797 000008EC 722C43616C63756C61-
   797 000008F5 746F722C436C6F636B-
   797 000008FE 2C5465726D696E616C-
   797 00000907 2C53657474696E6773-
   797 00000910 2C4153434949206172-
   797 00000919 7420656469746F722C-
   797 00000922 506978656C20617274-
   797 0000092B 20656469746F722C4D-
   797 00000934 7573696320706C6179-
   797 0000093D 65722C486172647761-
   797 00000946 726520636865636B65-
   797 0000094F 722C41626F7574204D-
   797 00000958 696368616C4F532C4F-
   797 00000961 746865722073747566-
   797 0000096A 662E2E2E00         
   798                                  	
   799                                  ; ------------------------------------------------------------------
   800                                  ; SYSTEM VARIABLES -- Settings for programs and system calls
   801                                  
   802                                  	; System runtime variables
   803                                  								
   804 0000096F 0000                    	origstack		dw 0		; SP before launching a program
   805                                  
   806 00000971 00                      	app_running		db 0		; Is a program running?
   807                                  	
   808                                  ;	program_drawn	db 0		; Is the program already drawn by os_draw_background?
   809                                  	
   810                                  ; ------------------------------------------------------------------
   811                                  ; FEATURES -- Code to pull into the kernel
   812                                  
   813                                  	%INCLUDE "features/icons.asm"
   814                              <1> ; ==================================================================
   815                              <1> ; MichalOS Icons
   816                              <1> ; ==================================================================
   817                              <1> 
   818 00000972 0910                <1> 	bomblogo	db 9, 16
   819 00000974 000000000020006000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00100000b, 00000000b, 01100000b, 00000000b
   820 0000097D 000000000402018000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000100b, 00000010b, 00000001b, 10000000b, 00000000b
   821 00000986 000000000084800000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 10000100b, 10000000b, 00000000b, 00000000b
   822 0000098F 0000006AA501508880  <1> 				db 00000000b, 00000000b, 00000000b, 01101010b, 10100101b, 00000001b, 01010000b, 10001000b, 10000000b
   823 00000998 0000030000A8004000  <1> 				db 00000000b, 00000000b, 00000011b, 00000000b, 00000000b, 10101000b, 00000000b, 01000000b, 00000000b
   824 000009A1 000057540018202400  <1> 				db 00000000b, 00000000b, 01010111b, 01010100b, 00000000b, 00011000b, 00100000b, 00100100b, 00000000b
   825 000009AA 0000FFFC0080200200  <1> 				db 00000000b, 00000000b, 11111111b, 11111100b, 00000000b, 10000000b, 00100000b, 00000010b, 00000000b
   826 000009B3 005FFFFFD400200000  <1> 				db 00000000b, 01011111b, 11111111b, 11111111b, 11010100b, 00000000b, 00100000b, 00000000b, 00000000b
   827 000009BC 01FFFFFFFD00000000  <1> 				db 00000001b, 11111111b, 11111111b, 11111111b, 11111101b, 00000000b, 00000000b, 00000000b, 00000000b
   828 000009C5 07FFFFFFFF40000000  <1> 				db 00000111b, 11111111b, 11111111b, 11111111b, 11111111b, 01000000b, 00000000b, 00000000b, 00000000b
   829 000009CE 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   830 000009D7 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   831 000009E0 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   832 000009E9 03FFFFFFFF00000000  <1> 				db 00000011b, 11111111b, 11111111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   833 000009F2 00FFFFFFFC00000000  <1> 				db 00000000b, 11111111b, 11111111b, 11111111b, 11111100b, 00000000b, 00000000b, 00000000b, 00000000b
   834 000009FB 000AFFFE8000000000  <1> 				db 00000000b, 00001010b, 11111111b, 11111110b, 10000000b, 00000000b, 00000000b, 00000000b, 00000000b
   835                              <1> 
   836 00000A04 0408                <1> 	filelogo	db 4, 8
   837 00000A06 0EAAD000            <1> 				db 00001110b, 10101010b, 11010000b, 00000000b
   838 00000A0A 0C00C900            <1> 				db 00001100b, 00000000b, 11001001b, 00000000b
   839 00000A0E 0C00AAC0            <1> 				db 00001100b, 00000000b, 10101010b, 11000000b
   840 00000A12 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   841 00000A16 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   842 00000A1A 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   843 00000A1E 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   844 00000A22 0D5555C0            <1> 				db 00001101b, 01010101b, 01010101b, 11000000b
   845                              <1> 	
   846 00000A26 1207                <1> 	logo		db 18, 7
   847 00000A28 00000EEAAAAC400400- <1> 				db 00000000b, 00000000b, 00001110b, 11101010b, 10101010b, 10101100b, 01000000b, 00000100b, 00000000b, 00000000b, 01000000b, 00000000b, 	00000000b, 00010011b, 11101010b, 10111111b, 10101010b, 10110000b
   847 00000A31 0040000013EABFAAB0  <1>
   848 00000A3A 00000CEAAAECE46C00- <1> 				db 00000000b, 00000000b, 00001100b, 11101010b, 10101010b, 11101100b, 11100100b, 01101100b, 00000000b, 00000000b, 11000000b, 00000000b, 00000000b, 00110011b, 00111111b, 11001100b, 11111111b, 11110000b
   848 00000A43 00C00000333FCCFFF0  <1>
   849 00000A4C 00000CC000CCC20C80- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000010b, 00001100b, 10000000b, 00000000b, 11000000b, 00000000b, 00000000b, 00110011b, 00111111b, 11001100b, 11111111b, 11110000b
   849 00000A55 00C00000333FCCFFF0  <1>
   850 00000A5E 00000CC000CCC00CC6- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000000b, 00001100b, 11000110b, 10101000b, 11011010b, 10010010b, 10101001b, 00110011b, 00111111b, 11001111b, 01010101b, 10110000b
   850 00000A67 A8DA92A9333FCF55B0  <1>
   851 00000A70 00000CC000CCC00CCC- <1> 				db 00000000b, 00000000b, 00001100b, 11000000b, 00000000b, 11001100b, 11000000b, 00001100b, 11001100b, 00000000b, 11000000b, 00110001b, 10101011b, 00110011b, 00111111b, 11001111b, 11111111b, 00110000b
   851 00000A79 00C031AB333FCFFF30  <1>
   852 00000A82 00000EAAAACCC00CC9- <1> 				db 00000000b, 00000000b, 00001110b, 10101010b, 10101010b, 11001100b, 11000000b, 00001100b, 11001001b, 01010100b, 11000000b, 00110010b, 01010110b, 00110011b, 01101010b, 10011110b, 10101010b, 01110000b
   852 00000A8B 54C03256336A9EAA70  <1>
   853 00000A94 00000AAAAAA8000000- <1> 				db 00000000b, 00000000b, 00001010b, 10101010b, 10101010b, 10101000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000010b, 10101010b, 10101010b, 10101010b, 10100000b
   853 00000A9D 0000000002AAAAAAA0  <1>
   854                              <1> 			
   814                                   	%INCLUDE "features/disk.asm"
   815                              <1> ; ==================================================================
   816                              <1> ; FAT12 FLOPPY DISK ROUTINES
   817                              <1> ; ==================================================================
   818                              <1> 
   819                              <1> ; os_report_free_space -- Returns the amount of free space on disk
   820                              <1> ; OUT: AX = Number of sectors free
   821                              <1> 
   822                              <1> os_report_free_space:
   823 00000AA6 60                  <1> 	pusha
   824 00000AA7 C706[F10A]0000      <1> 	mov word [.counter], 0
   825 00000AAD C706[F30A]0000      <1> 	mov word [.sectors_read], 0
   826                              <1> 	
   827 00000AB3 E8AE07              <1> 	call disk_read_fat				; Read the FAT into memory
   828 00000AB6 BE00E0              <1> 	mov si, disk_buffer
   829                              <1> 	
   830                              <1> .loop:
   831                              <1> 	; 0 = nothing, 1 = 1st nibble, 2 = 2nd nibble, 3 = 3rd nibble, G = data we don't care about
   832                              <1> 
   833 00000AB9 8B04                <1> 	mov ax, [si]					; AX = 3333GGGG11112222
   834 00000ABB 8A7C01              <1> 	mov bh, [si + 1]				; BX = GGGG111122223333
   835 00000ABE 8A5C02              <1> 	mov bl, [si + 2]
   836                              <1> 	
   837 00000AC1 C1C004              <1> 	rol ax, 4						; AX = GGGG111122223333
   838                              <1> 	
   839 00000AC4 80E40F              <1> 	and ah, 0Fh						; AX = 0000111122223333
   840 00000AC7 80E70F              <1> 	and bh, 0Fh						; BX = 0000111122223333
   841                              <1> 		
   842 00000ACA 83F800              <1> 	cmp ax, 0
   843 00000ACD 7504                <1> 	jne .no_increment_1
   844                              <1> 	
   845 00000ACF FF06[F10A]          <1> 	inc word [.counter]
   846                              <1> 	
   847                              <1> .no_increment_1:
   848 00000AD3 83FB00              <1> 	cmp bx, 0
   849                              <1> 		
   850 00000AD6 7504                <1> 	jne .no_increment_2
   851                              <1> 	
   852 00000AD8 FF06[F10A]          <1> 	inc word [.counter]
   853                              <1> 	
   854                              <1> .no_increment_2:
   855 00000ADC 83C603              <1> 	add si, 3						; Increment the pointer
   856 00000ADF 8306[F30A]02        <1> 	add word [.sectors_read], 2		; Increment the counter of sectors
   857                              <1> 	
   858 00000AE4 813E[F30A]1F0B      <1> 	cmp word [.sectors_read], 2847	; Are we done? (33 of the sectors are the bootloader, FAT and root dir)
   859 00000AEA 7CCD                <1> 	jl .loop
   860                              <1> 	
   861 00000AEC 61                  <1> 	popa
   862 00000AED A1[F10A]            <1> 	mov ax, [.counter]
   863                              <1> 
   864 00000AF0 C3                  <1> 	ret
   865                              <1> 	
   866 00000AF1 0000                <1> 	.counter		dw 0
   867 00000AF3 0000                <1> 	.sectors_read	dw 0
   868                              <1> 	
   869                              <1> ; --------------------------------------------------------------------------
   870                              <1> ; os_read_root -- Get the root directory contents
   871                              <1> ; IN: SI = where to store the root directory; OUT: carry set if error
   872                              <1> 
   873                              <1> os_read_root:
   874 00000AF5 60                  <1> 	pusha
   875                              <1> 
   876 00000AF6 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   877 00000AF9 E80B08              <1> 	call disk_convert_l2hts
   878                              <1> 
   879 00000AFC 8CDB                <1> 	mov bx, ds
   880 00000AFE 8EC3                <1> 	mov es, bx
   881 00000B00 89F3                <1> 	mov bx, si
   882                              <1> 
   883 00000B02 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   884 00000B04 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
   885                              <1> 
   886 00000B06 60                  <1> 	pusha				; Prepare to enter loop
   887                              <1> 
   888                              <1> 
   889                              <1> .read_root_dir_loop:
   890 00000B07 61                  <1> 	popa
   891 00000B08 60                  <1> 	pusha
   892                              <1> 
   893 00000B09 F9                  <1> 	stc				; A few BIOSes do not set properly on error
   894 00000B0A CD13                <1> 	int 13h				; Read sectors
   895                              <1> 
   896 00000B0C 7308                <1> 	jnc .root_dir_finished
   897 00000B0E E8E707              <1> 	call disk_reset_floppy		; Reset controller and try again
   898 00000B11 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
   899                              <1> 
   900 00000B13 61                  <1> 	popa
   901 00000B14 EB04                <1> 	jmp .read_failure		; Fatal double error
   902                              <1> 
   903                              <1> 
   904                              <1> .root_dir_finished:
   905 00000B16 61                  <1> 	popa				; Restore registers from main loop
   906                              <1> 
   907 00000B17 61                  <1> 	popa				; And restore from start of this system call
   908                              <1> 
   909 00000B18 F8                  <1> 	clc				; Clear carry (for success)
   910 00000B19 C3                  <1> 	ret
   911                              <1> 
   912                              <1> .read_failure:
   913 00000B1A 61                  <1> 	popa
   914                              <1> 
   915 00000B1B F9                  <1> 	stc				; Set carry flag (for failure)
   916 00000B1C C3                  <1> 	ret
   917                              <1> 
   918                              <1> ; ------------------------------------------------------------------
   919                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   920                              <1> ; IN/OUT: AX = location to store zero-terminated filename string,
   921                              <1> ;         If [0087h] = 1, then BX = location of file extension list
   922                              <1> 
   923                              <1> os_get_file_list:
   924 00000B1D 60                  <1> 	pusha
   925                              <1> 
   926 00000B1E C606[020C]00        <1> 	mov byte [.num_entries], 0
   927 00000B23 891E[030C]          <1> 	mov [.extension_list], bx
   928                              <1> 	
   929 00000B27 BE[070C]            <1> 	mov si, .msg_load
   930 00000B2A E81619              <1> 	call os_print_footer
   931                              <1> 	
   932 00000B2D A3[050C]            <1> 	mov word [.file_list_tmp], ax
   933                              <1> 
   934 00000B30 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   935                              <1> 
   936 00000B36 E8BF07              <1> 	call disk_reset_floppy		; Just in case disk was changed
   937                              <1> 
   938 00000B39 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   939 00000B3C E8C807              <1> 	call disk_convert_l2hts
   940                              <1> 
   941 00000B3F BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   942 00000B42 89F3                <1> 	mov bx, si
   943                              <1> 
   944 00000B44 B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
   945                              <1> 
   946 00000B47 60                  <1> 	pusha				; Prepare to enter loop
   947                              <1> 
   948                              <1> 
   949                              <1> .read_root_dir:
   950 00000B48 61                  <1> 	popa
   951 00000B49 60                  <1> 	pusha
   952                              <1> 
   953 00000B4A F9                  <1> 	stc
   954 00000B4B CD13                <1> 	int 13h				; Read sectors
   955 00000B4D E8A807              <1> 	call disk_reset_floppy		; Check we've read them OK
   956 00000B50 730B                <1> 	jnc .show_dir_init		; No errors, continue
   957                              <1> 
   958 00000B52 E8A307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   959 00000B55 73F1                <1> 	jnc .read_root_dir
   960                              <1> 
   961 00000B57 B8[260C]            <1> 	mov ax, .error
   962 00000B5A E8000B              <1> 	call os_fatal_error
   963                              <1> 	
   964                              <1> .show_dir_init:
   965 00000B5D 61                  <1> 	popa
   966                              <1> 
   967 00000B5E B80000              <1> 	mov ax, 0
   968 00000B61 BE00E0              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   969                              <1> 
   970 00000B64 8B3E[050C]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   971                              <1> 
   972                              <1> 
   973                              <1> .start_entry:
   974 00000B68 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   975 00000B6B 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   976 00000B6D 7478                <1> 	je .skip
   977                              <1> 
   978 00000B6F A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
   979 00000B71 7574                <1> 	jnz .skip			; Yes, ignore it
   980                              <1> 
   981 00000B73 8A04                <1> 	mov al, [si]
   982 00000B75 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   983 00000B77 746E                <1> 	je .skip
   984                              <1> 
   985 00000B79 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   986 00000B7B 7470                <1> 	je .done
   987                              <1> 	
   988 00000B7D B90100              <1> 	mov cx, 1			; Set char counter
   989 00000B80 89F2                <1> 	mov dx, si			; Beginning of possible entry
   990                              <1> 
   991                              <1> .testdirentry:
   992 00000B82 46                  <1> 	inc si
   993 00000B83 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   994 00000B85 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   995 00000B87 7C5C                <1> 	jl .nxtdirentry
   996 00000B89 3C7E                <1> 	cmp al, '~'
   997 00000B8B 7758                <1> 	ja .nxtdirentry
   998                              <1> 
   999 00000B8D 41                  <1> 	inc cx
  1000 00000B8E 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
  1001 00000B91 7402                <1> 	je .gotfilename
  1002 00000B93 EBED                <1> 	jmp .testdirentry
  1003                              <1> 
  1004                              <1> 
  1005                              <1> .gotfilename:				; Got a filename that passes testing
  1006 00000B95 89D6                <1> 	mov si, dx			; DX = where getting string
  1007                              <1> 
  1008 00000B97 803E870001          <1> 	cmp byte [0087h], 1
  1009 00000B9C 7522                <1> 	jne .no_extension_check
  1010                              <1> 	
  1011 00000B9E 8B1E[030C]          <1> 	mov bx, [.extension_list]
  1012 00000BA2 0FB60F              <1> 	movzx cx, byte [bx]
  1013                              <1> 
  1014                              <1> .extension_loop:
  1015 00000BA5 60                  <1> 	pusha
  1016 00000BA6 83C608              <1> 	add si, 8
  1017                              <1> 	
  1018 00000BA9 49                  <1> 	dec cx
  1019 00000BAA 89CF                <1> 	mov di, cx
  1020 00000BAC C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1021 00000BAF 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1022 00000BB0 033E[030C]          <1> 	add di, [.extension_list]	
  1023                              <1> 	
  1024 00000BB4 B90300              <1> 	mov cx, 3
  1025 00000BB7 F3A6                <1> 	rep cmpsb
  1026 00000BB9 61                  <1> 	popa
  1027 00000BBA 7404                <1> 	je .no_extension_check
  1028                              <1> 	
  1029 00000BBC E2E7                <1> 	loop .extension_loop
  1030                              <1> 	
  1031 00000BBE EB25                <1> 	jmp .nxtdirentry
  1032                              <1> 	
  1033                              <1> .no_extension_check:
  1034 00000BC0 31C9                <1> 	xor cx, cx
  1035                              <1> 	
  1036                              <1> .loopy:
  1037 00000BC2 AC                  <1> 	lodsb
  1038 00000BC3 3C20                <1> 	cmp al, ' '
  1039 00000BC5 7401                <1> 	je .ignore_space
  1040 00000BC7 AA                  <1> 	stosb
  1041                              <1> 	
  1042                              <1> .ignore_space:
  1043 00000BC8 41                  <1> 	inc cx
  1044 00000BC9 83F908              <1> 	cmp cx, 8
  1045 00000BCC 7407                <1> 	je .add_dot
  1046 00000BCE 83F90B              <1> 	cmp cx, 11
  1047 00000BD1 7409                <1> 	je .done_copy
  1048 00000BD3 EBED                <1> 	jmp .loopy
  1049                              <1> 
  1050                              <1> .add_dot:
  1051 00000BD5 26C6052E            <1> 	mov byte [es:di], '.'
  1052 00000BD9 47                  <1> 	inc di
  1053 00000BDA EBE6                <1> 	jmp .loopy
  1054                              <1> 
  1055                              <1> .done_copy:
  1056 00000BDC 26C6052C            <1> 	mov byte [es:di], ','		; Use comma to separate filenames
  1057 00000BE0 47                  <1> 	inc di
  1058 00000BE1 FE06[020C]          <1> 	inc byte [.num_entries]
  1059                              <1> 	
  1060                              <1> .nxtdirentry:
  1061 00000BE5 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
  1062                              <1> 
  1063                              <1> .skip:
  1064 00000BE7 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
  1065 00000BEA E97BFF              <1> 	jmp .start_entry
  1066                              <1> 
  1067                              <1> 
  1068                              <1> .done:
  1069 00000BED 803E[020C]00        <1> 	cmp byte [.num_entries], 0
  1070 00000BF2 7401                <1> 	je .no_dec
  1071                              <1> 	
  1072 00000BF4 4F                  <1> 	dec di
  1073                              <1> 
  1074                              <1> .no_dec:
  1075 00000BF5 26C60500            <1> 	mov byte [es:di], 0		; Zero-terminate string (gets rid of final comma)
  1076                              <1> 
  1077 00000BF9 60                  <1> 	pusha
  1078 00000BFA 31F6                <1> 	xor si, si
  1079 00000BFC E84418              <1> 	call os_print_footer
  1080 00000BFF 61                  <1> 	popa
  1081                              <1> 
  1082 00000C00 61                  <1> 	popa
  1083                              <1> 
  1084 00000C01 C3                  <1> 	ret
  1085                              <1> 
  1086 00000C02 00                  <1> 	.num_entries		db 0
  1087 00000C03 0000                <1> 	.extension_list		dw 0
  1088 00000C05 0000                <1> 	.file_list_tmp		dw 0
  1089 00000C07 2052656164696E6720- <1> 	.msg_load			db ' Reading directory contents...', 0
  1089 00000C10 6469726563746F7279- <1>
  1089 00000C19 20636F6E74656E7473- <1>
  1089 00000C22 2E2E2E00            <1>
  1090 00000C26 6F735F6765745F6669- <1> 	.error				db 'os_get_file_list: Floppy reset fail', 0
  1090 00000C2F 6C655F6C6973743A20- <1>
  1090 00000C38 466C6F707079207265- <1>
  1090 00000C41 736574206661696C00  <1>
  1091                              <1> 	
  1092                              <1> ; ------------------------------------------------------------------
  1093                              <1> ; os_load_file -- Load a file into RAM
  1094                              <1> ; IN: AX = location of filename, ES:CX = location in RAM to load file
  1095                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
  1096                              <1> 
  1097                              <1> os_load_file:
  1098 00000C4A 06                  <1> 	push es
  1099 00000C4B 8C06[A00D]          <1> 	mov [.old_segment], es
  1100                              <1> 
  1101 00000C4F 0E                  <1> 	push cs
  1102 00000C50 07                  <1> 	pop es
  1103                              <1> 	
  1104 00000C51 E8791E              <1> 	call os_string_uppercase
  1105                              <1> 
  1106 00000C54 60                  <1> 	pusha							; Message display routine
  1107 00000C55 89C3                <1> 	mov bx, ax
  1108 00000C57 B8[A20D]            <1> 	mov ax, .msg_load
  1109 00000C5A B95200              <1> 	mov cx, 82
  1110 00000C5D E8B01E              <1> 	call os_string_join
  1111 00000C60 BE5200              <1> 	mov si, 82
  1112 00000C63 E8DD17              <1> 	call os_print_footer
  1113 00000C66 61                  <1> 	popa
  1114                              <1> 	
  1115 00000C67 E83D05              <1> 	call int_filename_convert
  1116                              <1> 
  1117 00000C6A A3[780D]            <1> 	mov [.filename_loc], ax		; Store filename location
  1118 00000C6D 890E[7A0D]          <1> 	mov [.load_position], cx	; And where to load the file!
  1119                              <1> 
  1120 00000C71 6631C0              <1> 	xor eax, eax			; Needed for some older BIOSes
  1121                              <1> 
  1122 00000C74 E88106              <1> 	call disk_reset_floppy		; In case floppy has been changed
  1123 00000C77 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
  1124                              <1> 
  1125 00000C79 B8[800D]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
  1126 00000C7C E9DE09              <1> 	jmp os_fatal_error
  1127                              <1> 
  1128                              <1> 
  1129                              <1> .floppy_ok:				; Ready to read first block of data
  1130 00000C7F B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1131 00000C82 E88206              <1> 	call disk_convert_l2hts
  1132                              <1> 
  1133 00000C85 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
  1134 00000C88 89F3                <1> 	mov bx, si
  1135                              <1> 
  1136 00000C8A B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
  1137                              <1> 
  1138 00000C8D 60                  <1> 	pusha				; Prepare to enter loop
  1139                              <1> 
  1140                              <1> 
  1141                              <1> .read_root_dir:
  1142 00000C8E 61                  <1> 	popa
  1143 00000C8F 60                  <1> 	pusha
  1144                              <1> 
  1145 00000C90 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
  1146                              <1> 	
  1147 00000C91 CD13                <1> 	int 13h				; Read sectors
  1148 00000C93 7308                <1> 	jnc .search_root_dir		; No errors = continue
  1149                              <1> 
  1150 00000C95 E86006              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
  1151 00000C98 73F4                <1> 	jnc .read_root_dir
  1152                              <1> 
  1153 00000C9A 61                  <1> 	popa
  1154 00000C9B EB38                <1> 	jmp .root_problem		; Double error = exit
  1155                              <1> 
  1156                              <1> .search_root_dir:
  1157 00000C9D 61                  <1> 	popa
  1158                              <1> 
  1159 00000C9E B9E000              <1> 	mov cx, 224		; Search all entries in root dir
  1160 00000CA1 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
  1161                              <1> 
  1162                              <1> .next_root_entry:
  1163 00000CA4 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
  1164 00000CA7 BF00E0              <1> 	mov di, disk_buffer		; Point root dir at next entry
  1165 00000CAA 01DF                <1> 	add di, bx
  1166                              <1> 
  1167 00000CAC 8A05                <1> 	mov al, [di]			; First character of name
  1168                              <1> 
  1169 00000CAE 3C00                <1> 	cmp al, 0			; Last file name already checked?
  1170 00000CB0 7423                <1> 	je .root_problem
  1171                              <1> 
  1172 00000CB2 3CE5                <1> 	cmp al, 229			; Was this file deleted?
  1173 00000CB4 74EE                <1> 	je .next_root_entry		; If yes, skip it
  1174                              <1> 
  1175 00000CB6 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
  1176                              <1> 
  1177 00000CB9 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
  1178 00000CBB 74E7                <1> 	je .next_root_entry
  1179                              <1> 
  1180 00000CBD A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
  1181 00000CBF 75E3                <1> 	jnz .next_root_entry
  1182                              <1> 
  1183 00000CC1 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
  1184                              <1> 
  1185 00000CC5 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
  1186 00000CC7 E8031E              <1> 	call os_string_uppercase
  1187                              <1> 
  1188 00000CCA 8B36[780D]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
  1189                              <1> 
  1190 00000CCE E8951E              <1> 	call os_string_compare		; Current entry same as requested?
  1191 00000CD1 7208                <1> 	jc .found_file_to_load
  1192                              <1> 
  1193 00000CD3 E2CF                <1> 	loop .next_root_entry
  1194                              <1> 
  1195                              <1> .root_problem:
  1196 00000CD5 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
  1197 00000CD8 07                  <1> 	pop es
  1198                              <1> 
  1199 00000CD9 F9                  <1> 	stc				; return with size = 0 and carry set
  1200 00000CDA C3                  <1> 	ret
  1201                              <1> 
  1202                              <1> 
  1203                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
  1204 00000CDB 668B451C            <1> 	mov eax, [di+28]			; Store file size to return to calling routine
  1205 00000CDF 66A3[7C0D]          <1> 	mov [.file_size], eax
  1206                              <1> 
  1207 00000CE3 6683F800            <1> 	cmp eax, 0			; If the file size is zero, don't bother trying
  1208 00000CE7 747B                <1> 	je .end				; to read more clusters
  1209                              <1> 
  1210 00000CE9 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
  1211 00000CEC A3[740D]            <1> 	mov word [.cluster], ax
  1212                              <1> 
  1213 00000CEF B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
  1214 00000CF2 E81206              <1> 	call disk_convert_l2hts
  1215                              <1> 
  1216 00000CF5 BB00E0              <1> 	mov bx, disk_buffer		; ES:BX points to our buffer
  1217                              <1> 
  1218 00000CF8 B402                <1> 	mov ah, 2			; int 13h params: read sectors
  1219 00000CFA B009                <1> 	mov al, 9			; And read 9 of them
  1220                              <1> 
  1221 00000CFC 60                  <1> 	pusha
  1222                              <1> 
  1223                              <1> .read_fat:
  1224 00000CFD 61                  <1> 	popa				; In case registers altered by int 13h
  1225 00000CFE 60                  <1> 	pusha
  1226                              <1> 
  1227 00000CFF F9                  <1> 	stc
  1228 00000D00 CD13                <1> 	int 13h
  1229 00000D02 7308                <1> 	jnc .read_fat_ok
  1230                              <1> 
  1231 00000D04 E8F105              <1> 	call disk_reset_floppy
  1232 00000D07 73F4                <1> 	jnc .read_fat
  1233                              <1> 
  1234 00000D09 61                  <1> 	popa
  1235 00000D0A EBC9                <1> 	jmp .root_problem
  1236                              <1> 
  1237                              <1> 
  1238                              <1> .read_fat_ok:
  1239 00000D0C 61                  <1> 	popa
  1240                              <1> 
  1241                              <1> 
  1242                              <1> .load_file_sector:
  1243 00000D0D A1[740D]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
  1244 00000D10 83C01F              <1> 	add ax, 31
  1245                              <1> 
  1246 00000D13 E8F105              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
  1247                              <1> 
  1248 00000D16 8B1E[7A0D]          <1> 	mov bx, [.load_position]
  1249 00000D1A 8E06[A00D]          <1> 	mov es, [.old_segment]
  1250                              <1> 
  1251 00000D1E B80102              <1> 	mov ax, 0201h			; AH = read sectors, AL = just read 1
  1252                              <1> 
  1253 00000D21 F9                  <1> 	stc
  1254 00000D22 CD13                <1> 	int 13h
  1255                              <1> 
  1256 00000D24 0E                  <1> 	push cs
  1257 00000D25 07                  <1> 	pop es
  1258                              <1> 	
  1259 00000D26 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
  1260                              <1> 
  1261 00000D28 E8CD05              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
  1262 00000D2B 73E0                <1> 	jnc .load_file_sector
  1263                              <1> 
  1264 00000D2D B8[800D]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
  1265 00000D30 E92A09              <1> 	jmp os_fatal_error
  1266                              <1> 
  1267                              <1> 
  1268                              <1> .calculate_next_cluster:
  1269 00000D33 A1[740D]            <1> 	mov ax, [.cluster]
  1270 00000D36 BB0300              <1> 	mov bx, 3
  1271 00000D39 F7E3                <1> 	mul bx
  1272 00000D3B BB0200              <1> 	mov bx, 2
  1273 00000D3E F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
  1274 00000D40 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1275 00000D43 01C6                <1> 	add si, ax
  1276 00000D45 3E8B04              <1> 	mov ax, word [ds:si]
  1277                              <1> 
  1278 00000D48 83FA00              <1> 	cmp dx, 0			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
  1279 00000D4B 7405                <1> 	je .even			; If [CLUSTER] = even, drop last 4 bits of word
  1280                              <1> 					; with next cluster; if odd, drop first 4 bits
  1281                              <1> 
  1282                              <1> .odd:
  1283 00000D4D C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
  1284 00000D50 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1285                              <1> 
  1286                              <1> .even:
  1287 00000D52 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
  1288                              <1> 
  1289                              <1> .calculate_cluster_cont:
  1290 00000D55 A3[740D]            <1> 	mov word [.cluster], ax		; Store cluster
  1291                              <1> 
  1292 00000D58 3DF80F              <1> 	cmp ax, 0FF8h
  1293 00000D5B 7D07                <1> 	jge .end
  1294                              <1> 
  1295 00000D5D 8306[A00D]20        <1> 	add word [.old_segment], 512 / 16
  1296 00000D62 EBA9                <1> 	jmp .load_file_sector		; Onto next sector!
  1297                              <1> 
  1298                              <1> 
  1299                              <1> .end:
  1300 00000D64 668B1E[7C0D]        <1> 	mov ebx, [.file_size]		; Get file size to pass back in BX
  1301 00000D69 60                  <1> 	pusha
  1302 00000D6A 31F6                <1> 	xor si, si
  1303 00000D6C E8D416              <1> 	call os_print_footer
  1304 00000D6F 61                  <1> 	popa
  1305 00000D70 07                  <1> 	pop es
  1306                              <1> 
  1307 00000D71 F8                  <1> 	clc				; Carry clear = good load
  1308 00000D72 C3                  <1> 	ret
  1309                              <1> 
  1310                              <1> 
  1311 00000D73 00                  <1> 	.bootd					db 0 		; Boot device number
  1312 00000D74 0000                <1> 	.cluster				dw 0 		; Cluster of the file we want to load
  1313 00000D76 0000                <1> 	.pointer				dw 0 		; Pointer into disk_buffer, for loading 'file2load'
  1314                              <1> 
  1315 00000D78 0000                <1> 	.filename_loc			dw 0		; Temporary store of filename location
  1316 00000D7A 0000                <1> 	.load_position			dw 0		; Where we'll load the file
  1317 00000D7C 00000000            <1> 	.file_size				dd 0		; Size of the file
  1318                              <1> 
  1319 00000D80 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy reset fail', 0
  1319 00000D89 696C653A20466C6F70- <1>
  1319 00000D92 707920726573657420- <1>
  1319 00000D9B 6661696C00          <1>
  1320                              <1> 
  1321 00000DA0 0000                <1> 	.old_segment			dw 0
  1322                              <1> 	
  1323 00000DA2 204C6F6164696E6720- <1> 	.msg_load				db ' Loading ', 0
  1323 00000DAB 00                  <1>
  1324                              <1> 	
  1325                              <1> ; --------------------------------------------------------------------------
  1326                              <1> ; os_write_file -- Save (max 64K) file to disk
  1327                              <1> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
  1328                              <1> ; OUT: Carry clear if OK, set if failure
  1329                              <1> 
  1330                              <1> os_write_file:
  1331 00000DAC 60                  <1> 	pusha
  1332                              <1> 	
  1333 00000DAD 8C06[830F]          <1> 	mov [.old_segment], es
  1334                              <1> 	
  1335 00000DB1 0E                  <1> 	push cs
  1336 00000DB2 07                  <1> 	pop es
  1337                              <1> 		
  1338 00000DB3 60                  <1> 	pusha							; Message display routine
  1339 00000DB4 89C3                <1> 	mov bx, ax
  1340 00000DB6 B8[850F]            <1> 	mov ax, .msg_save
  1341 00000DB9 B95200              <1> 	mov cx, 82
  1342 00000DBC E8511D              <1> 	call os_string_join
  1343 00000DBF BE5200              <1> 	mov si, 82
  1344 00000DC2 E87E16              <1> 	call os_print_footer
  1345 00000DC5 61                  <1> 	popa
  1346                              <1> 
  1347 00000DC6 89C6                <1> 	mov si, ax
  1348 00000DC8 E8A91C              <1> 	call os_string_length
  1349 00000DCB 83F800              <1> 	cmp ax, 0
  1350 00000DCE 0F849601            <1> 	je near .failure
  1351 00000DD2 89F0                <1> 	mov ax, si
  1352                              <1> 
  1353 00000DD4 E8F61C              <1> 	call os_string_uppercase
  1354                              <1> 
  1355 00000DD7 E8CD03              <1> 	call int_filename_convert	; Make filename FAT12-style
  1356 00000DDA 0F828A01            <1> 	jc near .failure
  1357                              <1> 
  1358 00000DDE 890E[770F]          <1> 	mov word [.filesize], cx
  1359 00000DE2 891E[7D0F]          <1> 	mov word [.location], bx
  1360 00000DE6 A3[810F]            <1> 	mov word [.filename], ax
  1361                              <1> 
  1362 00000DE9 E8A201              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
  1363 00000DEC 0F837801            <1> 	jnc near .failure
  1364                              <1> 
  1365                              <1> 
  1366                              <1> 	; First, zero out the .free_clusters list from any previous execution
  1367 00000DF0 60                  <1> 	pusha
  1368                              <1> 
  1369 00000DF1 BF00FF              <1> 	mov di, .free_clusters
  1370 00000DF4 B98000              <1> 	mov cx, 128
  1371                              <1> .clean_free_loop:
  1372 00000DF7 C7050000            <1> 	mov word [di], 0
  1373 00000DFB 47                  <1> 	inc di
  1374 00000DFC 47                  <1> 	inc di
  1375 00000DFD E2F8                <1> 	loop .clean_free_loop
  1376                              <1> 
  1377 00000DFF 61                  <1> 	popa
  1378                              <1> 
  1379                              <1> 
  1380                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
  1381                              <1> 
  1382 00000E00 89C8                <1> 	mov ax, cx
  1383 00000E02 31D2                <1> 	xor dx, dx
  1384 00000E04 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
  1385 00000E07 F7F3                <1> 	div bx
  1386 00000E09 83FA00              <1> 	cmp dx, 0
  1387 00000E0C 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
  1388 00000E0E EB03                <1> 	jmp .carry_on
  1389                              <1> 
  1390                              <1> .add_a_bit:
  1391 00000E10 83C001              <1> 	add ax, 1
  1392                              <1> .carry_on:
  1393                              <1> 
  1394 00000E13 A3[7F0F]            <1> 	mov word [.clusters_needed], ax
  1395                              <1> 
  1396 00000E16 A1[810F]            <1> 	mov word ax, [.filename]	; Get filename back
  1397                              <1> 
  1398 00000E19 E89301              <1> 	call os_create_file		; Create empty root dir entry for this file
  1399 00000E1C 0F824801            <1> 	jc near .failure		; If we can't write to the media, jump out
  1400                              <1> 
  1401 00000E20 8B1E[770F]          <1> 	mov word bx, [.filesize]
  1402 00000E24 83FB00              <1> 	cmp bx, 0
  1403 00000E27 0F842F01            <1> 	je near .finished
  1404                              <1> 
  1405 00000E2B E83604              <1> 	call disk_read_fat		; Get FAT copy into RAM
  1406 00000E2E BE03E0              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
  1407                              <1> 
  1408 00000E31 BB0200              <1> 	mov bx, 2			; Current cluster counter
  1409 00000E34 8B0E[7F0F]          <1> 	mov word cx, [.clusters_needed]
  1410 00000E38 31D2                <1> 	xor dx, dx			; Offset in .free_clusters list
  1411                              <1> 
  1412                              <1> .find_free_cluster:
  1413 00000E3A AD                  <1> 	lodsw				; Get a word
  1414 00000E3B 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
  1415 00000E3E 740D                <1> 	jz .found_free_even		; Free entry?
  1416                              <1> 
  1417                              <1> .more_odd:
  1418 00000E40 43                  <1> 	inc bx				; If not, bump our counter
  1419 00000E41 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
  1420                              <1> 
  1421 00000E42 AD                  <1> 	lodsw				; Get word
  1422 00000E43 C1E804              <1> 	shr ax, 4			; Shift for odd
  1423 00000E46 09C0                <1> 	or ax, ax			; Free entry?
  1424 00000E48 7413                <1> 	jz .found_free_odd
  1425                              <1> 
  1426                              <1> .more_even:
  1427 00000E4A 43                  <1> 	inc bx				; If not, keep going
  1428 00000E4B EBED                <1> 	jmp .find_free_cluster
  1429                              <1> 
  1430                              <1> 
  1431                              <1> .found_free_even:
  1432 00000E4D 56                  <1> 	push si
  1433 00000E4E BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1434 00000E51 01D6                <1> 	add si, dx
  1435 00000E53 891C                <1> 	mov word [si], bx
  1436 00000E55 5E                  <1> 	pop si
  1437                              <1> 
  1438 00000E56 49                  <1> 	dec cx				; Got all the clusters we need?
  1439 00000E57 E314                <1> 	jcxz .finished_list
  1440                              <1> 
  1441 00000E59 42                  <1> 	inc dx				; Next word in our list
  1442 00000E5A 42                  <1> 	inc dx
  1443 00000E5B EBE3                <1> 	jmp .more_odd
  1444                              <1> 
  1445                              <1> .found_free_odd:
  1446 00000E5D 56                  <1> 	push si
  1447 00000E5E BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1448 00000E61 01D6                <1> 	add si, dx
  1449 00000E63 891C                <1> 	mov word [si], bx
  1450 00000E65 5E                  <1> 	pop si
  1451                              <1> 
  1452 00000E66 49                  <1> 	dec cx
  1453 00000E67 E304                <1> 	jcxz .finished_list
  1454                              <1> 
  1455 00000E69 42                  <1> 	inc dx				; Next word in our list
  1456 00000E6A 42                  <1> 	inc dx
  1457 00000E6B EBDD                <1> 	jmp .more_even
  1458                              <1> 
  1459                              <1> 
  1460                              <1> 
  1461                              <1> .finished_list:
  1462                              <1> 
  1463                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
  1464                              <1> 	; that correspond to free clusters on the disk; the next job is to
  1465                              <1> 	; create a cluster chain in the FAT for our file
  1466                              <1> 
  1467 00000E6D 31C9                <1> 	xor cx, cx			; .free_clusters offset counter
  1468 00000E6F C706[7B0F]0100      <1> 	mov word [.count], 1		; General cluster counter
  1469                              <1> 
  1470                              <1> .chain_loop:
  1471 00000E75 A1[7B0F]            <1> 	mov word ax, [.count]		; Is this the last cluster?
  1472 00000E78 3B06[7F0F]          <1> 	cmp word ax, [.clusters_needed]
  1473 00000E7C 7454                <1> 	je .last_cluster
  1474                              <1> 
  1475 00000E7E BF00FF              <1> 	mov di, .free_clusters
  1476                              <1> 
  1477 00000E81 01CF                <1> 	add di, cx
  1478 00000E83 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1479                              <1> 
  1480 00000E85 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
  1481 00000E87 31D2                <1> 	xor dx, dx
  1482 00000E89 BB0300              <1> 	mov bx, 3
  1483 00000E8C F7E3                <1> 	mul bx
  1484 00000E8E BB0200              <1> 	mov bx, 2
  1485 00000E91 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1486 00000E93 BE00E0              <1> 	mov si, disk_buffer
  1487 00000E96 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1488 00000E98 3E8B04              <1> 	mov ax, word [ds:si]
  1489                              <1> 
  1490 00000E9B 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1491 00000E9D 741B                <1> 	jz .even
  1492                              <1> 
  1493                              <1> .odd:
  1494 00000E9F 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
  1495 00000EA2 BF00FF              <1> 	mov di, .free_clusters
  1496 00000EA5 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1497 00000EA7 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
  1498 00000EAA C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
  1499 00000EAD 01D8                <1> 	add ax, bx
  1500                              <1> 
  1501 00000EAF 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1502                              <1> 
  1503 00000EB2 FF06[7B0F]          <1> 	inc word [.count]
  1504 00000EB6 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1505 00000EB7 41                  <1> 	inc cx
  1506                              <1> 
  1507 00000EB8 EBBB                <1> 	jmp .chain_loop
  1508                              <1> 
  1509                              <1> .even:
  1510 00000EBA 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
  1511 00000EBD BF00FF              <1> 	mov di, .free_clusters
  1512 00000EC0 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1513 00000EC2 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
  1514                              <1> 
  1515 00000EC5 01D8                <1> 	add ax, bx
  1516                              <1> 
  1517 00000EC7 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1518                              <1> 
  1519 00000ECA FF06[7B0F]          <1> 	inc word [.count]
  1520 00000ECE 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1521 00000ECF 41                  <1> 	inc cx
  1522                              <1> 
  1523 00000ED0 EBA3                <1> 	jmp .chain_loop
  1524                              <1> 
  1525                              <1> 
  1526                              <1> 
  1527                              <1> .last_cluster:
  1528 00000ED2 BF00FF              <1> 	mov di, .free_clusters
  1529 00000ED5 01CF                <1> 	add di, cx
  1530 00000ED7 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1531                              <1> 
  1532 00000ED9 89D8                <1> 	mov ax, bx
  1533                              <1> 
  1534 00000EDB 31D2                <1> 	xor dx, dx
  1535 00000EDD BB0300              <1> 	mov bx, 3
  1536 00000EE0 F7E3                <1> 	mul bx
  1537 00000EE2 BB0200              <1> 	mov bx, 2
  1538 00000EE5 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1539 00000EE7 BE00E0              <1> 	mov si, disk_buffer
  1540 00000EEA 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1541 00000EEC 3E8B04              <1> 	mov ax, word [ds:si]
  1542                              <1> 
  1543 00000EEF 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1544 00000EF1 7408                <1> 	jz .even_last
  1545                              <1> 
  1546                              <1> .odd_last:
  1547 00000EF3 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
  1548 00000EF6 83C080              <1> 	add ax, 0FF80h
  1549 00000EF9 EB06                <1> 	jmp .finito
  1550                              <1> 
  1551                              <1> .even_last:
  1552 00000EFB 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
  1553 00000EFE 05F80F              <1> 	add ax, 0FF8h
  1554                              <1> 
  1555                              <1> 
  1556                              <1> .finito:
  1557 00000F01 3E8904              <1> 	mov word [ds:si], ax
  1558                              <1> 
  1559 00000F04 E88803              <1> 	call disk_write_fat		; Save our FAT back to disk
  1560                              <1> 
  1561                              <1> 
  1562                              <1> 	; Now it's time to save the sectors to disk!
  1563                              <1> 
  1564 00000F07 31C9                <1> 	xor cx, cx
  1565                              <1> 
  1566                              <1> .save_loop:
  1567 00000F09 BF00FF              <1> 	mov di, .free_clusters
  1568 00000F0C 01CF                <1> 	add di, cx
  1569 00000F0E 8B05                <1> 	mov word ax, [di]
  1570                              <1> 
  1571 00000F10 83F800              <1> 	cmp ax, 0
  1572 00000F13 0F842200            <1> 	je near .write_root_entry
  1573                              <1> 
  1574 00000F17 60                  <1> 	pusha
  1575                              <1> 
  1576 00000F18 83C01F              <1> 	add ax, 31
  1577                              <1> 
  1578 00000F1B E8E903              <1> 	call disk_convert_l2hts
  1579                              <1> 
  1580 00000F1E 8B1E[7D0F]          <1> 	mov word bx, [.location]
  1581 00000F22 8E06[830F]          <1> 	mov es, [.old_segment]
  1582                              <1> 	
  1583 00000F26 B80103              <1> 	mov ax, 0301h
  1584 00000F29 F9                  <1> 	stc
  1585 00000F2A CD13                <1> 	int 13h
  1586                              <1> 
  1587 00000F2C 0E                  <1> 	push cs
  1588 00000F2D 07                  <1> 	pop es
  1589                              <1> 		
  1590 00000F2E 61                  <1> 	popa
  1591                              <1> 
  1592 00000F2F 8106[7D0F]0002      <1> 	add word [.location], 512
  1593 00000F35 41                  <1> 	inc cx
  1594 00000F36 41                  <1> 	inc cx
  1595 00000F37 EBD0                <1> 	jmp .save_loop
  1596                              <1> 
  1597                              <1> 
  1598                              <1> .write_root_entry:
  1599                              <1> 
  1600                              <1> 	; Now it's time to head back to the root directory, find our
  1601                              <1> 	; entry and update it with the cluster in use and file size
  1602                              <1> 
  1603 00000F39 E87203              <1> 	call disk_read_root_dir
  1604                              <1> 
  1605 00000F3C A1[810F]            <1> 	mov word ax, [.filename]
  1606 00000F3F E8EA02              <1> 	call disk_get_root_entry
  1607                              <1> 
  1608 00000F42 A100FF              <1> 	mov word ax, [.free_clusters]	; Get first free cluster
  1609                              <1> 
  1610 00000F45 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
  1611                              <1> 
  1612 00000F48 8B0E[770F]          <1> 	mov word cx, [.filesize]
  1613 00000F4C 894D1C              <1> 	mov word [di+28], cx
  1614                              <1> 
  1615 00000F4F C6451E00            <1> 	mov byte [di+30], 0		; File size
  1616 00000F53 C6451F00            <1> 	mov byte [di+31], 0
  1617                              <1> 
  1618 00000F57 E87F03              <1> 	call disk_write_root_dir
  1619                              <1> 
  1620                              <1> .finished:
  1621 00000F5A 61                  <1> 	popa
  1622 00000F5B 60                  <1> 	pusha
  1623 00000F5C 31F6                <1> 	xor si, si
  1624 00000F5E E8E214              <1> 	call os_print_footer
  1625 00000F61 61                  <1> 	popa
  1626 00000F62 8E06[830F]          <1> 	mov es, [.old_segment]
  1627                              <1> 
  1628 00000F66 F8                  <1> 	clc
  1629 00000F67 C3                  <1> 	ret
  1630                              <1> 
  1631                              <1> .failure:
  1632 00000F68 61                  <1> 	popa
  1633 00000F69 60                  <1> 	pusha
  1634 00000F6A BE0000              <1> 	mov si, 0
  1635 00000F6D E8D314              <1> 	call os_print_footer
  1636 00000F70 61                  <1> 	popa
  1637 00000F71 8E06[830F]          <1> 	mov es, [.old_segment]
  1638                              <1> 
  1639 00000F75 F9                  <1> 	stc				; Couldn't write!
  1640 00000F76 C3                  <1> 	ret
  1641                              <1> 
  1642                              <1> 
  1643 00000F77 0000                <1> 	.filesize				dw 0
  1644 00000F79 0000                <1> 	.cluster				dw 0
  1645 00000F7B 0000                <1> 	.count					dw 0
  1646 00000F7D 0000                <1> 	.location				dw 0
  1647                              <1> 
  1648 00000F7F 0000                <1> 	.clusters_needed		dw 0
  1649                              <1> 
  1650 00000F81 0000                <1> 	.filename				dw 0
  1651                              <1> 
  1652                              <1> 	.free_clusters			equ 65280
  1653                              <1> 
  1654 00000F83 0000                <1> 	.old_segment			dw 0
  1655                              <1> 
  1656 00000F85 20536176696E672000  <1> 	.msg_save				db ' Saving ', 0
  1657                              <1> 	
  1658                              <1> ; --------------------------------------------------------------------------
  1659                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1660                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1661                              <1> 
  1662                              <1> os_file_exists:
  1663 00000F8E E83C1B              <1> 	call os_string_uppercase
  1664 00000F91 E81302              <1> 	call int_filename_convert	; Make FAT12-style filename
  1665                              <1> 
  1666 00000F94 50                  <1> 	push ax
  1667 00000F95 E8DC1A              <1> 	call os_string_length
  1668 00000F98 83F800              <1> 	cmp ax, 0
  1669 00000F9B 740F                <1> 	je .failure
  1670 00000F9D 58                  <1> 	pop ax
  1671                              <1> 
  1672 00000F9E 50                  <1> 	push ax
  1673 00000F9F E80C03              <1> 	call disk_read_root_dir
  1674                              <1> 
  1675 00000FA2 58                  <1> 	pop ax				; Restore filename
  1676                              <1> 
  1677 00000FA3 BF00E0              <1> 	mov di, disk_buffer
  1678                              <1> 
  1679 00000FA6 E88302              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1680                              <1> 
  1681 00000FA9 9C                  <1> 	pushf
  1682                              <1> 
  1683 00000FAA 9D                  <1> 	popf
  1684 00000FAB C3                  <1> 	ret
  1685                              <1> 
  1686                              <1> .failure:
  1687 00000FAC 58                  <1> 	pop ax
  1688                              <1> 
  1689 00000FAD F9                  <1> 	stc
  1690 00000FAE C3                  <1> 	ret
  1691                              <1> 
  1692                              <1> 
  1693                              <1> ; --------------------------------------------------------------------------
  1694                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1695                              <1> ; IN: AX = location of filename; OUT: Nothing
  1696                              <1> 
  1697                              <1> os_create_file:
  1698 00000FAF F8                  <1> 	clc
  1699                              <1> 
  1700 00000FB0 E81A1B              <1> 	call os_string_uppercase
  1701 00000FB3 E8F101              <1> 	call int_filename_convert	; Make FAT12-style filename
  1702 00000FB6 60                  <1> 	pusha
  1703                              <1> 
  1704 00000FB7 50                  <1> 	push ax				; Save filename for now
  1705                              <1> 
  1706 00000FB8 E8D3FF              <1> 	call os_file_exists		; Does the file already exist?
  1707 00000FBB 731B                <1> 	jnc .exists_error
  1708                              <1> 
  1709                              <1> 
  1710                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1711                              <1> 
  1712 00000FBD BF00E0              <1> 	mov di, disk_buffer		; So point DI at it!
  1713                              <1> 
  1714 00000FC0 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1715                              <1> .next_entry:
  1716 00000FC3 8A05                <1> 	mov byte al, [di]
  1717 00000FC5 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1718 00000FC7 7412                <1> 	je .found_free_entry
  1719 00000FC9 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1720 00000FCB 740E                <1> 	je .found_free_entry
  1721 00000FCD 83C720              <1> 	add di, 32			; If not, go onto next entry
  1722 00000FD0 E2F1                <1> 	loop .next_entry
  1723                              <1> 	
  1724 00000FD2 B8[6F10]            <1> 	mov ax, .err_msg		; Is the root directory full?
  1725 00000FD5 E88506              <1> 	call os_fatal_error
  1726                              <1> 
  1727                              <1> .exists_error:				; We also get here if above loop finds nothing
  1728 00000FD8 58                  <1> 	pop ax				; Get filename back
  1729                              <1> 
  1730 00000FD9 EB7C                <1> 	jmp .failure
  1731                              <1> 
  1732                              <1> .found_free_entry:
  1733 00000FDB 5E                  <1> 	pop si				; Get filename back
  1734 00000FDC B90B00              <1> 	mov cx, 11
  1735 00000FDF F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1736                              <1> 
  1737                              <1> 	; Get the time information
  1738                              <1> 	
  1739 00000FE1 60                  <1> 	pusha
  1740 00000FE2 B402                <1> 	mov ah, 2
  1741 00000FE4 E89307              <1> 	call os_int_1Ah
  1742                              <1> 
  1743 00000FE7 88E8                <1> 	mov al, ch			; Hours
  1744 00000FE9 E8D404              <1> 	call os_bcd_to_int
  1745 00000FEC 89C3                <1> 	mov bx, ax
  1746 00000FEE C1E306              <1> 	shl bx, 6
  1747                              <1> 	
  1748 00000FF1 88C8                <1> 	mov al, cl			; Minutes
  1749 00000FF3 E8CA04              <1> 	call os_bcd_to_int
  1750 00000FF6 09C3                <1> 	or bx, ax
  1751 00000FF8 C1E305              <1> 	shl bx, 5
  1752                              <1> 	
  1753 00000FFB D0EE                <1> 	shr dh, 1			; Seconds (they're stored as "doubleseconds")
  1754 00000FFD 88F0                <1> 	mov al, dh
  1755 00000FFF E8BE04              <1> 	call os_bcd_to_int
  1756 00001002 09C3                <1> 	or bx, ax
  1757                              <1> 	
  1758 00001004 891E[5D10]          <1> 	mov [.creation_time], bx
  1759 00001008 891E[6510]          <1> 	mov [.write_time], bx
  1760                              <1> 
  1761                              <1> 	; Get date information
  1762                              <1> 	
  1763 0000100C B404                <1> 	mov ah, 4
  1764 0000100E E86907              <1> 	call os_int_1Ah
  1765                              <1> 
  1766 00001011 52                  <1> 	push dx
  1767 00001012 88E8                <1> 	mov al, ch			; Century
  1768 00001014 E8A904              <1> 	call os_bcd_to_int
  1769 00001017 BB6400              <1> 	mov bx, 100
  1770 0000101A F7E3                <1> 	mul bx
  1771 0000101C 89C3                <1> 	mov bx, ax
  1772                              <1> 	
  1773 0000101E 88C8                <1> 	mov al, cl			; Years
  1774 00001020 E89D04              <1> 	call os_bcd_to_int
  1775 00001023 01C3                <1> 	add bx, ax
  1776                              <1> 	
  1777 00001025 81EBBC07            <1> 	sub bx, 1980		; Years are stored as "years past 1980"
  1778                              <1> 	
  1779 00001029 C1E304              <1> 	shl bx, 4
  1780 0000102C 5A                  <1> 	pop dx
  1781                              <1> 	
  1782 0000102D 88F0                <1> 	mov al, dh			; Months
  1783 0000102F E88E04              <1> 	call os_bcd_to_int
  1784 00001032 09C3                <1> 	or bx, ax
  1785 00001034 C1E305              <1> 	shl bx, 5
  1786                              <1> 	
  1787 00001037 88D0                <1> 	mov al, dl			; Days
  1788 00001039 E88404              <1> 	call os_bcd_to_int
  1789 0000103C 09C3                <1> 	or bx, ax
  1790                              <1> 	
  1791 0000103E 891E[5F10]          <1> 	mov [.creation_date], bx
  1792 00001042 891E[6710]          <1> 	mov [.write_date], bx
  1793 00001046 61                  <1> 	popa
  1794                              <1> 	
  1795 00001047 BE[5A10]            <1> 	mov si, .table		; Copy over all the attributes
  1796 0000104A B91500              <1> 	mov cx, 21
  1797 0000104D F3A4                <1> 	rep movsb
  1798                              <1> 	
  1799 0000104F E88702              <1> 	call disk_write_root_dir
  1800 00001052 7203                <1> 	jc .failure
  1801                              <1> 
  1802 00001054 61                  <1> 	popa
  1803                              <1> 
  1804 00001055 F8                  <1> 	clc				; Clear carry for success
  1805 00001056 C3                  <1> 	ret
  1806                              <1> 
  1807                              <1> .failure:
  1808 00001057 61                  <1> 	popa
  1809                              <1> 
  1810 00001058 F9                  <1> 	stc
  1811 00001059 C3                  <1> 	ret
  1812                              <1> 
  1813                              <1> ;	.table			db 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0, 0 
  1814                              <1> 	.table:
  1815 0000105A 00                  <1> 		.atttribute		db 0
  1816 0000105B 00<rep 2h>          <1> 		.reserved		times 2 db 0
  1817 0000105D 0000                <1> 		.creation_time	dw 0
  1818 0000105F 0000                <1> 		.creation_date	dw 0
  1819 00001061 00<rep 4h>          <1> 		.reserved2		times 4 db 0
  1820 00001065 0000                <1> 		.write_time		dw 0
  1821 00001067 0000                <1> 		.write_date		dw 0
  1822 00001069 00<rep 6h>          <1> 		.reserved3		times 6 db 0
  1823 0000106F 4E6F7420656E6F7567- <1> 	.err_msg		db 'Not enough space in directory', 0
  1823 00001078 682073706163652069- <1>
  1823 00001081 6E206469726563746F- <1>
  1823 0000108A 727900              <1>
  1824                              <1> 
  1825                              <1> ; --------------------------------------------------------------------------
  1826                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1827                              <1> ; IN: AX = location of filename to remove
  1828                              <1> 
  1829                              <1> os_remove_file:
  1830 0000108D 60                  <1> 	pusha
  1831 0000108E E83C1A              <1> 	call os_string_uppercase
  1832 00001091 E81301              <1> 	call int_filename_convert	; Make filename FAT12-style
  1833 00001094 50                  <1> 	push ax				; Save filename
  1834                              <1> 
  1835 00001095 F8                  <1> 	clc
  1836                              <1> 
  1837 00001096 E81502              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1838                              <1> 
  1839 00001099 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1840                              <1> 
  1841 0000109C 58                  <1> 	pop ax				; Get chosen filename back
  1842                              <1> 
  1843 0000109D E88C01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1844 000010A0 7268                <1> 	jc .failure			; If entry can't be found
  1845                              <1> 
  1846                              <1> 
  1847 000010A2 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1848 000010A6 A3[0D11]            <1> 	mov word [.cluster], ax		; And save it
  1849                              <1> 
  1850 000010A9 C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1851                              <1> 
  1852 000010AC 47                  <1> 	inc di
  1853                              <1> 
  1854 000010AD 31C9                <1> 	xor cx, cx			; Set rest of data in root dir entry to zeros
  1855                              <1> .clean_loop:
  1856 000010AF C60500              <1> 	mov byte [di], 0
  1857 000010B2 47                  <1> 	inc di
  1858 000010B3 41                  <1> 	inc cx
  1859 000010B4 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1860 000010B7 7CF6                <1> 	jl .clean_loop
  1861                              <1> 
  1862 000010B9 E81D02              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1863                              <1> 
  1864                              <1> 
  1865 000010BC E8A501              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1866 000010BF BF00E0              <1> 	mov di, disk_buffer		; And DI points to it
  1867                              <1> 
  1868                              <1> 
  1869                              <1> .more_clusters:
  1870 000010C2 A1[0D11]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1871                              <1> 
  1872 000010C5 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1873 000010C8 743D                <1> 	je .nothing_to_do
  1874                              <1> 
  1875 000010CA BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1876 000010CD F7E3                <1> 	mul bx
  1877 000010CF BB0200              <1> 	mov bx, 2
  1878 000010D2 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1879 000010D4 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1880 000010D7 01C6                <1> 	add si, ax
  1881 000010D9 3E8B04              <1> 	mov ax, word [ds:si]
  1882                              <1> 
  1883 000010DC 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1884                              <1> 
  1885 000010DE 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1886                              <1> 					; with next cluster; if odd, drop first 4 bits
  1887                              <1> .odd:
  1888 000010E0 50                  <1> 	push ax
  1889 000010E1 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1890 000010E4 3E8904              <1> 	mov word [ds:si], ax
  1891 000010E7 58                  <1> 	pop ax
  1892                              <1> 
  1893 000010E8 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1894 000010EB EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1895                              <1> 
  1896                              <1> .even:
  1897 000010ED 50                  <1> 	push ax
  1898 000010EE 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1899 000010F1 3E8904              <1> 	mov word [ds:si], ax
  1900 000010F4 58                  <1> 	pop ax
  1901                              <1> 
  1902 000010F5 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1903                              <1> 
  1904                              <1> .calculate_cluster_cont:
  1905 000010F8 A3[0D11]            <1> 	mov word [.cluster], ax		; Store cluster
  1906                              <1> 
  1907 000010FB 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1908 000010FE 7302                <1> 	jae .end
  1909                              <1> 
  1910 00001100 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1911                              <1> 
  1912                              <1> .end:
  1913 00001102 E88A01              <1> 	call disk_write_fat
  1914 00001105 7203                <1> 	jc .failure
  1915                              <1> 
  1916                              <1> .nothing_to_do:
  1917 00001107 61                  <1> 	popa
  1918                              <1> 
  1919 00001108 F8                  <1> 	clc
  1920 00001109 C3                  <1> 	ret
  1921                              <1> 
  1922                              <1> .failure:
  1923 0000110A 61                  <1> 	popa
  1924                              <1> 
  1925 0000110B F9                  <1> 	stc
  1926 0000110C C3                  <1> 	ret
  1927                              <1> 
  1928                              <1> 
  1929 0000110D 0000                <1> 	.cluster dw 0
  1930                              <1> 
  1931                              <1> 
  1932                              <1> ; --------------------------------------------------------------------------
  1933                              <1> ; os_rename_file -- Change the name of a file on the disk
  1934                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1935                              <1> ; OUT: carry set on error
  1936                              <1> 
  1937                              <1> os_rename_file:
  1938 0000110F 53                  <1> 	push bx
  1939 00001110 50                  <1> 	push ax
  1940                              <1> 
  1941 00001111 F8                  <1> 	clc
  1942                              <1> 
  1943 00001112 E89901              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1944                              <1> 
  1945 00001115 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1946                              <1> 
  1947 00001118 58                  <1> 	pop ax				; Get chosen filename back
  1948                              <1> 
  1949 00001119 E8B119              <1> 	call os_string_uppercase
  1950 0000111C E88800              <1> 	call int_filename_convert
  1951 0000111F 721E                <1> 	jc .fail_read
  1952                              <1> 	
  1953 00001121 E80801              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1954 00001124 7219                <1> 	jc .fail_read			; Quit out if file not found
  1955                              <1> 
  1956 00001126 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1957                              <1> 
  1958 00001127 89D8                <1> 	mov ax, bx
  1959                              <1> 
  1960 00001129 E8A119              <1> 	call os_string_uppercase
  1961 0000112C E87800              <1> 	call int_filename_convert
  1962 0000112F 7211                <1> 	jc .fail_write
  1963                              <1> 	
  1964 00001131 89C6                <1> 	mov si, ax
  1965                              <1> 
  1966 00001133 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1967 00001136 F3A4                <1> 	rep movsb
  1968                              <1> 
  1969 00001138 E89E01              <1> 	call disk_write_root_dir	; Save root dir to disk
  1970 0000113B 7205                <1> 	jc .fail_write
  1971                              <1> 
  1972                              <1> 
  1973 0000113D F8                  <1> 	clc
  1974 0000113E C3                  <1> 	ret
  1975                              <1> 
  1976                              <1> .fail_read:
  1977 0000113F 58                  <1> 	pop ax
  1978                              <1> 
  1979 00001140 F9                  <1> 	stc
  1980 00001141 C3                  <1> 	ret
  1981                              <1> 
  1982                              <1> .fail_write:
  1983                              <1> 
  1984 00001142 F9                  <1> 	stc
  1985 00001143 C3                  <1> 	ret
  1986                              <1> 
  1987                              <1> 
  1988                              <1> ; --------------------------------------------------------------------------
  1989                              <1> ; os_get_file_size -- Get file size information for specified file
  1990                              <1> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
  1991                              <1> ; or carry set if file not found
  1992                              <1> 
  1993                              <1> os_get_file_size:
  1994 00001144 60                  <1> 	pusha
  1995                              <1> 
  1996 00001145 E88519              <1> 	call os_string_uppercase
  1997 00001148 E85C00              <1> 	call int_filename_convert
  1998                              <1> 
  1999 0000114B F8                  <1> 	clc
  2000                              <1> 
  2001 0000114C 50                  <1> 	push ax
  2002                              <1> 
  2003 0000114D E85E01              <1> 	call disk_read_root_dir
  2004 00001150 7219                <1> 	jc .failure
  2005                              <1> 
  2006 00001152 58                  <1> 	pop ax
  2007                              <1> 
  2008 00001153 BF00E0              <1> 	mov di, disk_buffer
  2009                              <1> 
  2010 00001156 E8D300              <1> 	call disk_get_root_entry
  2011 00001159 7210                <1> 	jc .failure
  2012                              <1> 
  2013 0000115B 668B5D1C            <1> 	mov ebx, [di+28]
  2014                              <1> 
  2015 0000115F 66891E[6E11]        <1> 	mov [.tmp], ebx
  2016                              <1> 
  2017 00001164 61                  <1> 	popa
  2018                              <1> 
  2019 00001165 668B1E[6E11]        <1> 	mov ebx, [.tmp]
  2020                              <1> 
  2021                              <1> 
  2022 0000116A C3                  <1> 	ret
  2023                              <1> 
  2024                              <1> .failure:
  2025 0000116B 61                  <1> 	popa
  2026 0000116C F9                  <1> 	stc
  2027                              <1> 
  2028 0000116D C3                  <1> 	ret
  2029                              <1> 
  2030                              <1> 
  2031 0000116E 00000000            <1> 	.tmp	dd 0
  2032                              <1> 
  2033                              <1> ; --------------------------------------------------------------------------
  2034                              <1> ; os_get_file_datetime -- Get file write time/date information for specified file
  2035                              <1> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
  2036                              <1> ; or carry set if file not found
  2037                              <1> 
  2038                              <1> os_get_file_datetime:
  2039 00001172 60                  <1> 	pusha
  2040                              <1> 
  2041 00001173 E85719              <1> 	call os_string_uppercase
  2042 00001176 E82E00              <1> 	call int_filename_convert
  2043                              <1> 
  2044 00001179 F8                  <1> 	clc
  2045                              <1> 
  2046 0000117A 50                  <1> 	push ax
  2047                              <1> 
  2048 0000117B E83001              <1> 	call disk_read_root_dir
  2049 0000117E 7220                <1> 	jc .failure
  2050                              <1> 
  2051 00001180 58                  <1> 	pop ax
  2052                              <1> 
  2053 00001181 BF00E0              <1> 	mov di, disk_buffer
  2054                              <1> 
  2055 00001184 E8A500              <1> 	call disk_get_root_entry
  2056 00001187 7217                <1> 	jc .failure
  2057                              <1> 
  2058 00001189 8B4516              <1> 	mov ax, [di+22]
  2059 0000118C 8B5D18              <1> 	mov bx, [di+24]
  2060                              <1> 
  2061 0000118F A3[A311]            <1> 	mov [.tmp], ax
  2062 00001192 891E[A511]          <1> 	mov [.tmp + 2], bx
  2063                              <1> 
  2064 00001196 61                  <1> 	popa
  2065                              <1> 
  2066 00001197 8B1E[A311]          <1> 	mov bx, [.tmp]
  2067 0000119B 8B0E[A511]          <1> 	mov cx, [.tmp + 2]
  2068                              <1> 
  2069                              <1> 
  2070 0000119F C3                  <1> 	ret
  2071                              <1> 
  2072                              <1> .failure:
  2073 000011A0 61                  <1> 	popa
  2074 000011A1 F9                  <1> 	stc
  2075                              <1> 
  2076 000011A2 C3                  <1> 	ret
  2077                              <1> 
  2078                              <1> 
  2079 000011A3 00000000            <1> 	.tmp	dd 0
  2080                              <1> 
  2081                              <1> 
  2082                              <1> ; ==================================================================
  2083                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  2084                              <1> 
  2085                              <1> ; ------------------------------------------------------------------
  2086                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  2087                              <1> ; IN: AX = filename string
  2088                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  2089                              <1> 
  2090                              <1> 
  2091                              <1> int_filename_convert:
  2092 000011A7 60                  <1> 	pusha
  2093                              <1> 
  2094 000011A8 89C6                <1> 	mov si, ax
  2095                              <1> 
  2096 000011AA E8C718              <1> 	call os_string_length
  2097 000011AD 83F80C              <1> 	cmp ax, 12			; Filename too long?
  2098 000011B0 7F49                <1> 	jg .failure0			; Fail if so
  2099                              <1> 
  2100 000011B2 83F800              <1> 	cmp ax, 0
  2101 000011B5 744B                <1> 	je .failure1			; Similarly, fail if zero-char string
  2102                              <1> 
  2103 000011B7 89C2                <1> 	mov dx, ax			; Store string length for now
  2104                              <1> 
  2105 000011B9 BF[1F12]            <1> 	mov di, .dest_string
  2106                              <1> 
  2107 000011BC B90000              <1> 	mov cx, 0
  2108                              <1> .copy_loop:
  2109 000011BF AC                  <1> 	lodsb
  2110 000011C0 3C2E                <1> 	cmp al, '.'
  2111 000011C2 7408                <1> 	je .extension_found
  2112 000011C4 AA                  <1> 	stosb
  2113 000011C5 41                  <1> 	inc cx
  2114 000011C6 39D1                <1> 	cmp cx, dx
  2115 000011C8 7F3F                <1> 	jg .failure2			; No extension found = wrong
  2116 000011CA EBF3                <1> 	jmp .copy_loop
  2117                              <1> 
  2118                              <1> .extension_found:
  2119 000011CC 83F900              <1> 	cmp cx, 0
  2120 000011CF 743F                <1> 	je .failure3			; Fail if extension dot is first char
  2121                              <1> 
  2122 000011D1 83F908              <1> 	cmp cx, 8
  2123 000011D4 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  2124                              <1> 
  2125                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  2126                              <1> 	; with spaces, if necessary
  2127                              <1> 
  2128                              <1> .add_spaces:
  2129 000011D6 C60520              <1> 	mov byte [di], ' '
  2130 000011D9 47                  <1> 	inc di
  2131 000011DA 41                  <1> 	inc cx
  2132 000011DB 83F908              <1> 	cmp cx, 8
  2133 000011DE 7CF6                <1> 	jl .add_spaces
  2134                              <1> 
  2135                              <1> 	; Finally, copy over the extension
  2136                              <1> .do_extension:
  2137 000011E0 AC                  <1> 	lodsb				; 3 characters
  2138 000011E1 3C00                <1> 	cmp al, 0
  2139 000011E3 7432                <1> 	je .failure4
  2140 000011E5 AA                  <1> 	stosb
  2141 000011E6 AC                  <1> 	lodsb
  2142 000011E7 3C00                <1> 	cmp al, 0
  2143 000011E9 742C                <1> 	je .failure4
  2144 000011EB AA                  <1> 	stosb
  2145 000011EC AC                  <1> 	lodsb
  2146 000011ED 3C00                <1> 	cmp al, 0
  2147 000011EF 7426                <1> 	je .failure4
  2148 000011F1 AA                  <1> 	stosb
  2149                              <1> 
  2150 000011F2 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  2151                              <1> 
  2152 000011F5 61                  <1> 	popa
  2153 000011F6 B8[1F12]            <1> 	mov ax, .dest_string
  2154 000011F9 F8                  <1> 	clc				; Clear carry for success
  2155 000011FA C3                  <1> 	ret
  2156                              <1> 
  2157                              <1> 
  2158                              <1> .failure0:
  2159 000011FB C606860000          <1> 	mov byte [0086h], 0
  2160 00001200 EB1A                <1> 	jmp .failure
  2161                              <1> 	
  2162                              <1> .failure1:
  2163 00001202 C606860001          <1> 	mov byte [0086h], 1
  2164 00001207 EB13                <1> 	jmp .failure
  2165                              <1> 	
  2166                              <1> .failure2:
  2167 00001209 C606860002          <1> 	mov byte [0086h], 2
  2168 0000120E EB0C                <1> 	jmp .failure
  2169                              <1> 	
  2170                              <1> .failure3:
  2171 00001210 C606860003          <1> 	mov byte [0086h], 3
  2172 00001215 EB05                <1> 	jmp .failure
  2173                              <1> 	
  2174                              <1> .failure4:
  2175 00001217 C606860004          <1> 	mov byte [0086h], 4
  2176                              <1> 
  2177                              <1> .failure:	
  2178 0000121C 61                  <1> 	popa
  2179 0000121D F9                  <1> 	stc				; Set carry for failure
  2180 0000121E C3                  <1> 	ret
  2181                              <1> 
  2182 0000121F 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  2183                              <1> 
  2184                              <1> 
  2185                              <1> ; --------------------------------------------------------------------------
  2186                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  2187                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  2188                              <1> ; or carry set if file not found
  2189                              <1> 
  2190                              <1> disk_get_root_entry:
  2191 0000122C 60                  <1> 	pusha
  2192                              <1> 
  2193 0000122D A3[6012]            <1> 	mov word [.filename], ax
  2194                              <1> 
  2195 00001230 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  2196 00001233 B80000              <1> 	mov ax, 0			; Searching at offset 0
  2197                              <1> 
  2198                              <1> .to_next_root_entry:
  2199 00001236 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  2200                              <1> 
  2201 00001238 8B36[6012]          <1> 	mov word si, [.filename]	; Start searching for filename
  2202 0000123C B90B00              <1> 	mov cx, 11
  2203 0000123F F3A6                <1> 	rep cmpsb
  2204 00001241 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  2205                              <1> 
  2206 00001243 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  2207                              <1> 
  2208 00001246 BF00E0              <1> 	mov di, disk_buffer		; Point to next root dir entry
  2209 00001249 01C7                <1> 	add di, ax
  2210                              <1> 
  2211 0000124B 87D1                <1> 	xchg dx, cx			; Get the original CX back
  2212 0000124D E2E7                <1> 	loop .to_next_root_entry
  2213                              <1> 
  2214 0000124F 61                  <1> 	popa
  2215                              <1> 
  2216 00001250 F9                  <1> 	stc				; Set carry if entry not found
  2217 00001251 C3                  <1> 	ret
  2218                              <1> 
  2219                              <1> 
  2220                              <1> .found_file:
  2221 00001252 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  2222                              <1> 
  2223 00001255 893E[6212]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  2224                              <1> 
  2225 00001259 61                  <1> 	popa
  2226                              <1> 
  2227 0000125A 8B3E[6212]          <1> 	mov word di, [.tmp]
  2228                              <1> 
  2229 0000125E F8                  <1> 	clc
  2230 0000125F C3                  <1> 	ret
  2231                              <1> 
  2232                              <1> 
  2233 00001260 0000                <1> 	.filename	dw 0
  2234 00001262 0000                <1> 	.tmp		dw 0
  2235                              <1> 
  2236                              <1> 
  2237                              <1> ; --------------------------------------------------------------------------
  2238                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  2239                              <1> ; IN: Nothing; OUT: carry set if failure
  2240                              <1> 
  2241                              <1> disk_read_fat:
  2242 00001264 60                  <1> 	pusha
  2243                              <1> 
  2244 00001265 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2245 00001268 E89C00              <1> 	call disk_convert_l2hts
  2246                              <1> 
  2247 0000126B BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2248 0000126E 8CCB                <1> 	mov bx, cs
  2249 00001270 8EC3                <1> 	mov es, bx
  2250 00001272 89F3                <1> 	mov bx, si
  2251                              <1> 
  2252 00001274 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2253 00001276 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  2254                              <1> 
  2255 00001278 60                  <1> 	pusha				; Prepare to enter loop
  2256                              <1> 
  2257                              <1> 
  2258                              <1> .read_fat_loop:
  2259 00001279 61                  <1> 	popa
  2260 0000127A 60                  <1> 	pusha
  2261                              <1> 
  2262 0000127B F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2263 0000127C CD13                <1> 	int 13h				; Read sectors
  2264                              <1> 
  2265 0000127E 7308                <1> 	jnc .fat_done
  2266 00001280 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  2267 00001283 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  2268                              <1> 
  2269 00001285 61                  <1> 	popa
  2270 00001286 EB04                <1> 	jmp .read_failure		; Fatal double error
  2271                              <1> 
  2272                              <1> .fat_done:
  2273 00001288 61                  <1> 	popa				; Restore registers from main loop
  2274                              <1> 
  2275 00001289 61                  <1> 	popa				; And restore registers from start of system call
  2276 0000128A F8                  <1> 	clc
  2277 0000128B C3                  <1> 	ret
  2278                              <1> 
  2279                              <1> .read_failure:
  2280 0000128C 61                  <1> 	popa
  2281 0000128D F9                  <1> 	stc				; Set carry flag (for failure)
  2282 0000128E C3                  <1> 	ret
  2283                              <1> 
  2284                              <1> 
  2285                              <1> ; --------------------------------------------------------------------------
  2286                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  2287                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  2288                              <1> 
  2289                              <1> disk_write_fat:
  2290 0000128F 60                  <1> 	pusha
  2291                              <1> 
  2292 00001290 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2293 00001293 E87100              <1> 	call disk_convert_l2hts
  2294                              <1> 
  2295 00001296 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2296 00001299 8CDB                <1> 	mov bx, ds
  2297 0000129B 8EC3                <1> 	mov es, bx
  2298 0000129D 89F3                <1> 	mov bx, si
  2299                              <1> 
  2300 0000129F B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2301 000012A1 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  2302                              <1> 
  2303 000012A3 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2304 000012A4 CD13                <1> 	int 13h				; Write sectors
  2305                              <1> 
  2306 000012A6 7203                <1> 	jc .write_failure		; Fatal double error
  2307                              <1> 
  2308 000012A8 61                  <1> 	popa				; And restore from start of system call
  2309 000012A9 F8                  <1> 	clc
  2310 000012AA C3                  <1> 	ret
  2311                              <1> 
  2312                              <1> .write_failure:
  2313 000012AB 61                  <1> 	popa
  2314 000012AC F9                  <1> 	stc				; Set carry flag (for failure)
  2315 000012AD C3                  <1> 	ret
  2316                              <1> 
  2317                              <1> 
  2318                              <1> ; --------------------------------------------------------------------------
  2319                              <1> ; disk_read_root_dir -- Get the root directory contents
  2320                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  2321                              <1> 
  2322                              <1> disk_read_root_dir:
  2323 000012AE 60                  <1> 	pusha
  2324                              <1> 
  2325 000012AF B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2326 000012B2 E85200              <1> 	call disk_convert_l2hts
  2327                              <1> 
  2328 000012B5 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2329 000012B8 8CDB                <1> 	mov bx, ds
  2330 000012BA 8EC3                <1> 	mov es, bx
  2331 000012BC 89F3                <1> 	mov bx, si
  2332                              <1> 
  2333 000012BE B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2334 000012C0 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  2335                              <1> 
  2336 000012C2 60                  <1> 	pusha				; Prepare to enter loop
  2337                              <1> 
  2338                              <1> 
  2339                              <1> .read_root_dir_loop:
  2340 000012C3 61                  <1> 	popa
  2341 000012C4 60                  <1> 	pusha
  2342                              <1> 
  2343 000012C5 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2344 000012C6 CD13                <1> 	int 13h				; Read sectors
  2345                              <1> 
  2346 000012C8 7308                <1> 	jnc .root_dir_finished
  2347 000012CA E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  2348 000012CD 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  2349                              <1> 
  2350 000012CF 61                  <1> 	popa
  2351 000012D0 EB04                <1> 	jmp .read_failure		; Fatal double error
  2352                              <1> 
  2353                              <1> 
  2354                              <1> .root_dir_finished:
  2355 000012D2 61                  <1> 	popa				; Restore registers from main loop
  2356                              <1> 
  2357 000012D3 61                  <1> 	popa				; And restore from start of this system call
  2358 000012D4 F8                  <1> 	clc				; Clear carry (for success)
  2359 000012D5 C3                  <1> 	ret
  2360                              <1> 
  2361                              <1> .read_failure:
  2362 000012D6 61                  <1> 	popa
  2363 000012D7 F9                  <1> 	stc				; Set carry flag (for failure)
  2364 000012D8 C3                  <1> 	ret
  2365                              <1> 
  2366                              <1> ; --------------------------------------------------------------------------
  2367                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  2368                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  2369                              <1> 
  2370                              <1> disk_write_root_dir:
  2371 000012D9 60                  <1> 	pusha
  2372                              <1> 
  2373 000012DA B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2374 000012DD E82700              <1> 	call disk_convert_l2hts
  2375                              <1> 
  2376 000012E0 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2377 000012E3 8CDB                <1> 	mov bx, ds
  2378 000012E5 8EC3                <1> 	mov es, bx
  2379 000012E7 89F3                <1> 	mov bx, si
  2380                              <1> 
  2381 000012E9 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2382 000012EB B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  2383                              <1> 
  2384 000012ED F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2385 000012EE CD13                <1> 	int 13h				; Write sectors
  2386 000012F0 7203                <1> 	jc .write_failure
  2387                              <1> 
  2388 000012F2 61                  <1> 	popa				; And restore from start of this system call
  2389 000012F3 F8                  <1> 	clc
  2390 000012F4 C3                  <1> 	ret
  2391                              <1> 
  2392                              <1> .write_failure:
  2393 000012F5 61                  <1> 	popa
  2394 000012F6 F9                  <1> 	stc				; Set carry flag (for failure)
  2395 000012F7 C3                  <1> 	ret
  2396                              <1> 
  2397                              <1> 
  2398                              <1> ; --------------------------------------------------------------------------
  2399                              <1> ; Reset floppy disk
  2400                              <1> 
  2401                              <1> disk_reset_floppy:
  2402 000012F8 50                  <1> 	push ax
  2403 000012F9 52                  <1> 	push dx
  2404 000012FA B80000              <1> 	mov ax, 0
  2405                              <1> ; ******************************************************************
  2406 000012FD 8A16[3613]          <1> 	mov dl, [bootdev]
  2407                              <1> ; ******************************************************************
  2408 00001301 F9                  <1> 	stc
  2409 00001302 CD13                <1> 	int 13h
  2410 00001304 5A                  <1> 	pop dx
  2411 00001305 58                  <1> 	pop ax
  2412 00001306 C3                  <1> 	ret
  2413                              <1> 
  2414                              <1> 
  2415                              <1> ; --------------------------------------------------------------------------
  2416                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  2417                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  2418                              <1> 
  2419                              <1> disk_convert_l2hts:
  2420 00001307 53                  <1> 	push bx
  2421 00001308 50                  <1> 	push ax
  2422                              <1> 
  2423 00001309 89C3                <1> 	mov bx, ax			; Save logical sector
  2424                              <1> 
  2425 0000130B BA0000              <1> 	mov dx, 0			; First the sector
  2426 0000130E F736[3413]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2427 00001312 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  2428 00001315 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  2429 00001317 89D8                <1> 	mov ax, bx
  2430                              <1> 
  2431 00001319 BA0000              <1> 	mov dx, 0			; Now calculate the head
  2432 0000131C F736[3413]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2433 00001320 BA0000              <1> 	mov dx, 0
  2434 00001323 F736[3213]          <1> 	div word [Sides]		; Floppy sides
  2435 00001327 88D6                <1> 	mov dh, dl			; Head/side
  2436 00001329 88C5                <1> 	mov ch, al			; Track
  2437                              <1> 	
  2438 0000132B 58                  <1> 	pop ax
  2439 0000132C 5B                  <1> 	pop bx
  2440                              <1> 
  2441 0000132D 8A16[3613]          <1> 	mov dl, [bootdev]		; Set correct device
  2442                              <1> 
  2443 00001331 C3                  <1> 	ret
  2444                              <1> 
  2445                              <1> 
  2446                              <1> 
  2447 00001332 0200                <1> 	Sides dw 2
  2448 00001334 1200                <1> 	SecsPerTrack dw 18
  2449                              <1> 	
  2450 00001336 00                  <1> 	bootdev db 0			; Boot device number
  2451                              <1> 
  2452                              <1> 
  2453                              <1> ; ==================================================================
  2454                              <1> 
  2455                              <1> 
   815                                  	%INCLUDE "features/keyboard.asm"
   816                              <1> ; ==================================================================
   817                              <1> ; KEYBOARD HANDLING ROUTINES
   818                              <1> ; ==================================================================
   819                              <1> 
   820                              <1> ; ------------------------------------------------------------------
   821                              <1> ; os_wait_for_key -- Waits for keypress and returns key
   822                              <1> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   823                              <1> ; IN: Nothing; OUT: AX = key pressed, other regs preserved
   824                              <1> 
   825                              <1> os_wait_for_key:
   826 00001337 60                  <1> 	pusha
   827                              <1> 	
   828                              <1> .try_again:
   829 00001338 B700                <1> 	mov bh, 0
   830 0000133A E88200              <1> 	call .screen_power
   831                              <1> 
   832                              <1> 	; Reset the screensaver tick
   833 0000133D 0FB606F2DE          <1> 	movzx ax, byte [57074]
   834 00001342 BB4404              <1> 	mov bx, 1092		; 18.2 Hz * 60 seconds
   835 00001345 F7E3                <1> 	mul bx
   836 00001347 A3[7649]            <1> 	mov [screensaver_timer], ax		; See "int.asm"
   837                              <1> 	
   838 0000134A C606[D813]00        <1> 	mov byte [.scrn_active], 0	; Reset all the screensaver variables
   839                              <1> 
   840 0000134F A08200              <1> 	mov al, [0082h]				; Save the current screen state, for later
   841 00001352 A2[D513]            <1> 	mov [.gfx_state], al
   842 00001355 B403                <1> 	mov ah, 03h
   843 00001357 B700                <1> 	mov bh, 0
   844 00001359 CD10                <1> 	int 10h
   845 0000135B 890E[D613]          <1> 	mov [.orig_crsr], cx		; Get the shape of the cursor
   846                              <1> 	
   847                              <1> .loop:
   848 0000135F F4                  <1> 	hlt							; Halt the CPU for 1/18.2 seconds, to save the CPU usage
   849 00001360 E82C00              <1> 	call .screensaver
   850 00001363 E87400              <1> 	call os_check_for_key
   851                              <1> 	
   852 00001366 83F800              <1> 	cmp ax, 0
   853 00001369 74F4                <1> 	je .loop
   854                              <1> 
   855 0000136B 60                  <1> 	pusha
   856 0000136C B80005              <1> 	mov ax, 0500h
   857 0000136F CD10                <1> 	int 10h
   858                              <1> 	
   859 00001371 A0[D513]            <1> 	mov al, [.gfx_state]
   860 00001374 A28200              <1> 	mov [0082h], al
   861 00001377 8B0E[D613]          <1> 	mov cx, [.orig_crsr]
   862 0000137B B401                <1> 	mov ah, 01h
   863 0000137D CD10                <1> 	int 10h
   864 0000137F 61                  <1> 	popa
   865                              <1> 	
   866 00001380 803E[D813]01        <1> 	cmp byte [.scrn_active], 1
   867 00001385 74B1                <1> 	je .try_again
   868                              <1> 	
   869 00001387 A3[D313]            <1> 	mov [.tmp_buf], ax
   870                              <1> 
   871 0000138A 61                  <1> 	popa
   872 0000138B A1[D313]            <1> 	mov ax, [.tmp_buf]
   873 0000138E C3                  <1> 	ret
   874                              <1> 	
   875                              <1> .screensaver:
   876 0000138F 833E[7649]00        <1> 	cmp word [screensaver_timer], 0
   877 00001394 7528                <1> 	jne .good
   878                              <1> 	
   879 00001396 803EF2DE00          <1> 	cmp byte [57074], 0
   880 0000139B 7421                <1> 	je .good
   881                              <1> 	
   882 0000139D B40F                <1> 	mov ah, 0Fh
   883 0000139F CD10                <1> 	int 10h
   884                              <1> 	
   885 000013A1 3C03                <1> 	cmp al, 3
   886 000013A3 7519                <1> 	jne .good
   887                              <1> 	
   888 000013A5 60                  <1> 	pusha
   889 000013A6 C606820001          <1> 	mov byte [0082h], 1
   890 000013AB B80105              <1> 	mov ax, 0501h
   891 000013AE CD10                <1> 	int 10h
   892 000013B0 E8B405              <1> 	call os_hide_cursor
   893 000013B3 C606[D813]01        <1> 	mov byte [.scrn_active], 1
   894                              <1> 
   895 000013B8 B704                <1> 	mov bh, 4
   896 000013BA E80200              <1> 	call .screen_power
   897 000013BD 61                  <1> 	popa
   898                              <1> 
   899                              <1> .good:
   900 000013BE C3                  <1> 	ret
   901                              <1> 	
   902                              <1> .screen_power:
   903 000013BF 3A3E[D913]          <1> 	cmp bh, [.scrn_power]
   904 000013C3 74F9                <1> 	je .good
   905                              <1> 
   906 000013C5 60                  <1> 	pusha
   907 000013C6 B8104F              <1> 	mov ax, 4F10h
   908 000013C9 B301                <1> 	mov bl, 1
   909 000013CB 883E[D913]          <1> 	mov [.scrn_power], bh
   910 000013CF CD10                <1> 	int 10h
   911 000013D1 61                  <1> 	popa
   912 000013D2 C3                  <1> 	ret
   913                              <1> 	
   914 000013D3 0000                <1> 	.tmp_buf		dw 0
   915 000013D5 00                  <1> 	.gfx_state		db 0
   916 000013D6 0000                <1> 	.orig_crsr		dw 0
   917 000013D8 00                  <1> 	.scrn_active	db 0
   918 000013D9 00                  <1> 	.scrn_power		db 0
   919                              <1> 	
   920                              <1> ; ------------------------------------------------------------------
   921                              <1> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   922                              <1> ; Also handles special keyboard shortcuts.
   923                              <1> ; IN: Nothing; OUT: AX = 0 if no key pressed, otherwise scan code
   924                              <1> 
   925                              <1> os_check_for_key:
   926 000013DA 60                  <1> 	pusha
   927                              <1> 
   928 000013DB B411                <1> 	mov ah, 11h			; BIOS call to check for key
   929                              <1> 	
   930 000013DD CD16                <1> 	int 16h
   931                              <1> 		
   932 000013DF 740F                <1> 	jz .nokey			; If no key, skip to end
   933                              <1> 
   934 000013E1 B410                <1> 	mov ah, 10h			; Otherwise get it from buffer
   935 000013E3 CD16                <1> 	int 16h
   936                              <1> 
   937 000013E5 E80E00              <1> 	call special_keys
   938                              <1> 
   939 000013E8 A3[F413]            <1> 	mov [.tmp_buf], ax		; Store resulting keypress
   940                              <1> 
   941 000013EB 61                  <1> 	popa				; But restore all other regs
   942 000013EC A1[F413]            <1> 	mov ax, [.tmp_buf]
   943 000013EF C3                  <1> 	ret
   944                              <1> 
   945                              <1> .nokey:
   946 000013F0 61                  <1> 	popa
   947                              <1> 	clr ax			; Zero result if no key pressed
    14 000013F1 31C0                <2>  xor %1, %1
   948 000013F3 C3                  <1> 	ret
   949                              <1> 
   950                              <1> 
   951 000013F4 0000                <1> 	.tmp_buf	dw 0
   952                              <1> 
   953                              <1> 
   954                              <1> ; ==================================================================
   955                              <1> 
   956                              <1> ; Checks for special keys and performs their action.
   957                              <1> ; IN: AX = key
   958                              <1> ; OUT: nothing
   959                              <1> special_keys:
   960 000013F6 60                  <1> 	pusha
   961 000013F7 80FC69              <1> 	cmp ah, 105
   962 000013FA 0F844E00            <1> 	je near .disable_sound
   963 000013FE 80FC6A              <1> 	cmp ah, 106
   964 00001401 0F844000            <1> 	je near .enable_sound
   965 00001405 80FC6B              <1> 	cmp ah, 107
   966 00001408 0F842500            <1> 	je near .exit_app
   967 0000140C 80FC8B              <1> 	cmp ah, 139
   968 0000140F 0F840200            <1> 	je near .intended_system_crash
   969 00001413 61                  <1> 	popa
   970 00001414 C3                  <1> 	ret
   971                              <1> 	
   972                              <1> .intended_system_crash:
   973 00001415 B8[1B14]            <1> 	mov ax, .crash_msg
   974 00001418 E84202              <1> 	call os_fatal_error
   975                              <1> 	
   976 0000141B 496E74656E64656420- <1> 	.crash_msg		db 'Intended system crash', 0
   976 00001424 73797374656D206372- <1>
   976 0000142D 61736800            <1>
   977                              <1> 	
   978                              <1> .exit_app:
   979 00001431 803E[7109]00        <1> 	cmp byte [app_running], 0
   980 00001436 0F840900            <1> 	je near .no_exit
   981                              <1> 	
   982 0000143A 61                  <1> 	popa
   983                              <1> 	
   984 0000143B 8B26[6F09]          <1> 	mov sp, [origstack]
   985 0000143F 83EC02              <1> 	sub sp, 2
   986                              <1> 	
   987 00001442 C3                  <1> 	ret
   988                              <1> 	
   989                              <1> .no_exit:
   990 00001443 61                  <1> 	popa
   991 00001444 C3                  <1> 	ret
   992                              <1> 		
   993                              <1> .enable_sound:
   994 00001445 C606830001          <1> 	mov byte [0083h], 1
   995 0000144A EB08                <1> 	jmp .display_speaker
   996                              <1> 	
   997                              <1> .disable_sound:
   998 0000144C C606830000          <1> 	mov byte [0083h], 0
   999 00001451 E8D712              <1> 	call os_speaker_off
  1000                              <1> 
  1001                              <1> .display_speaker:
  1002 00001454 803E820001          <1> 	cmp byte [0082h], 1
  1003 00001459 741E                <1> 	je .no_display_spkr
  1004                              <1> 
  1005 0000145B E8D204              <1> 	call os_get_cursor_pos
  1006 0000145E 52                  <1> 	push dx
  1007 0000145F BA4F00              <1> 	mov dx, 79			; Print the little speaker icon
  1008 00001462 E8C204              <1> 	call os_move_cursor
  1009                              <1> 	
  1010 00001465 B8170E              <1> 	mov ax, 0E17h
  1011 00001468 B700                <1> 	mov bh, 0
  1012 0000146A 803E830000          <1> 	cmp byte [0083h], 0
  1013 0000146F 7402                <1> 	je .no_crossed_spkr
  1014                              <1> 	
  1015 00001471 FEC8                <1> 	dec al
  1016                              <1> 	
  1017                              <1> .no_crossed_spkr:
  1018 00001473 CD10                <1> 	int 10h
  1019 00001475 5A                  <1> 	pop dx
  1020 00001476 E8AE04              <1> 	call os_move_cursor
  1021                              <1> 	
  1022                              <1> .no_display_spkr:
  1023 00001479 61                  <1> 	popa
  1024 0000147A C3                  <1> 	ret
  1025                              <1> 	
  1026                              <1> ; ==================================================================
  1027                              <1> 
   816                                  	%INCLUDE "features/math.asm"
   817                              <1> ; ==================================================================
   818                              <1> ; MATH ROUTINES
   819                              <1> ; ==================================================================
   820                              <1> 
   821                              <1> ; ------------------------------------------------------------------
   822                              <1> ; os_seed_random -- Seed the random number generator based on the current state of registers and time
   823                              <1> ; IN: every register; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_seed_random:
   826 0000147B 60                  <1> 	pusha
   827                              <1> 
   828 0000147C B402                <1> 	mov ah, 02h
   829 0000147E CD1A                <1> 	int 1Ah
   830                              <1> 	
   831 00001480 31D8                <1> 	xor ax, bx
   832 00001482 01C8                <1> 	add ax, cx
   833 00001484 31D0                <1> 	xor ax, dx
   834 00001486 01F0                <1> 	add ax, si
   835 00001488 31F8                <1> 	xor ax, di
   836 0000148A 01E0                <1> 	add ax, sp
   837 0000148C 31E8                <1> 	xor ax, bp
   838 0000148E 05ADDE              <1> 	add ax, 0xDEAD
   839 00001491 35EFBE              <1> 	xor ax, 0xBEEF
   840                              <1> 	
   841 00001494 A3[9914]            <1> 	mov [os_random_seed], ax	; Store the data
   842 00001497 61                  <1> 	popa
   843 00001498 C3                  <1> 	ret
   844                              <1> 
   845                              <1> 
   846 00001499 0000                <1> 	os_random_seed	dw 0
   847                              <1> 
   848                              <1> 
   849                              <1> ; ------------------------------------------------------------------
   850                              <1> ; os_get_random -- Return a random integer between low and high (inclusive)
   851                              <1> ; IN: AX = low integer, BX = high integer
   852                              <1> ; OUT: CX = random integer
   853                              <1> 
   854                              <1> os_get_random:
   855 0000149B 52                  <1> 	push dx
   856 0000149C 53                  <1> 	push bx
   857 0000149D 50                  <1> 	push ax
   858                              <1> 
   859 0000149E 29C3                <1> 	sub bx, ax			; We want a number between 0 and (high-low)
   860 000014A0 E80D00              <1> 	call .generate_random
   861 000014A3 89DA                <1> 	mov dx, bx
   862 000014A5 42                  <1> 	inc dx
   863 000014A6 F7E2                <1> 	mul dx
   864 000014A8 89D1                <1> 	mov cx, dx
   865                              <1> 
   866 000014AA 58                  <1> 	pop ax
   867 000014AB 5B                  <1> 	pop bx
   868 000014AC 5A                  <1> 	pop dx
   869 000014AD 01C1                <1> 	add cx, ax			; Add the low offset back
   870 000014AF C3                  <1> 	ret
   871                              <1> 
   872                              <1> 
   873                              <1> .generate_random:
   874 000014B0 52                  <1> 	push dx
   875 000014B1 53                  <1> 	push bx
   876                              <1> 
   877 000014B2 A1[9914]            <1> 	mov ax, [os_random_seed]
   878 000014B5 BA8373              <1> 	mov dx, 0x7383			; The magic number (random.org)
   879 000014B8 F7E2                <1> 	mul dx				; DX:AX = AX * DX
   880 000014BA A3[9914]            <1> 	mov [os_random_seed], ax
   881                              <1> 
   882 000014BD 5B                  <1> 	pop bx
   883 000014BE 5A                  <1>  	pop dx
   884 000014BF C3                  <1> 	ret
   885                              <1> 
   886                              <1> 
   887                              <1> ; ------------------------------------------------------------------
   888                              <1> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   889                              <1> ; IN: AL = BCD number; OUT: AX = integer value
   890                              <1> 
   891                              <1> os_bcd_to_int:
   892 000014C0 60                  <1> 	pusha
   893                              <1> 
   894 000014C1 88C3                <1> 	mov bl, al			; Store entire number for now
   895                              <1> 
   896 000014C3 83E00F              <1> 	and ax, 0Fh			; Zero-out high bits
   897 000014C6 89C1                <1> 	mov cx, ax			; CH/CL = lower BCD number, zero extended
   898                              <1> 
   899 000014C8 C0EB04              <1> 	shr bl, 4			; Move higher BCD number into lower bits, zero fill msb
   900 000014CB B00A                <1> 	mov al, 10
   901 000014CD F6E3                <1> 	mul bl				; AX = 10 * BL
   902                              <1> 
   903 000014CF 01C8                <1> 	add ax, cx			; Add lower BCD to 10*higher
   904 000014D1 A3[D914]            <1> 	mov [.tmp], ax
   905                              <1> 
   906 000014D4 61                  <1> 	popa
   907 000014D5 A1[D914]            <1> 	mov ax, [.tmp]			; And return it in AX!
   908 000014D8 C3                  <1> 	ret
   909                              <1> 
   910                              <1> 
   911 000014D9 0000                <1> 	.tmp	dw 0
   912                              <1> 
   913                              <1> 	
   914                              <1> ; ------------------------------------------------------------------
   915                              <1> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   916                              <1> ; IN: AL = integer value; OUT: AL = BCD number
   917                              <1> 
   918                              <1> os_int_to_bcd:
   919 000014DB 60                  <1> 	pusha
   920 000014DC 0FB6C0              <1> 	movzx ax, al
   921 000014DF 31D2                <1> 	xor dx, dx
   922                              <1> 	
   923 000014E1 BB0A00              <1> 	mov bx, 10
   924 000014E4 F7F3                <1> 	div bx
   925                              <1> 	
   926 000014E6 C0E004              <1> 	shl al, 4
   927 000014E9 00C2                <1> 	add dl, al
   928                              <1> 	
   929 000014EB 8816[F414]          <1> 	mov [.tmp], dl
   930 000014EF 61                  <1> 	popa
   931 000014F0 A0[F414]            <1> 	mov al, [.tmp]
   932 000014F3 C3                  <1> 	ret
   933                              <1> 
   934 000014F4 00                  <1> 	.tmp	db 0
   935                              <1> 
   936                              <1> 
   937                              <1> ; Calculates EAX^EBX.
   938                              <1> ; IN: EAX^EBX = input
   939                              <1> ; OUT: EAX = result
   940                              <1> 
   941                              <1> os_math_power:
   942 000014F5 6660                <1> 	pushad
   943 000014F7 6683FB01            <1> 	cmp ebx, 1
   944 000014FB 0F841900            <1> 	je near .power_end
   945 000014FF 6683FB00            <1> 	cmp ebx, 0
   946 00001503 0F841F00            <1> 	je near .zero
   947 00001507 6689D9              <1> 	mov ecx, ebx				; Prepare the data
   948 0000150A 6689C3              <1> 	mov ebx, eax
   949                              <1> .power_loop:
   950 0000150D 66F7E3              <1> 	mul ebx
   951 00001510 6649                <1> 	dec ecx
   952 00001512 6683F901            <1> 	cmp ecx, 1
   953 00001516 7FF5                <1> 	jnle .power_loop
   954                              <1> .power_end:
   955 00001518 66A3[3215]          <1> 	mov [.tmp_dword], eax
   956 0000151C 6661                <1> 	popad
   957 0000151E 66A1[3215]          <1> 	mov eax, [.tmp_dword]
   958 00001522 6631D2              <1> 	xor edx, edx
   959 00001525 C3                  <1> 	ret
   960                              <1> .zero:
   961 00001526 6661                <1> 	popad
   962 00001528 66B801000000        <1> 	mov eax, 1
   963 0000152E 6631D2              <1> 	xor edx, edx
   964 00001531 C3                  <1> 	ret
   965                              <1> 	
   966 00001532 00000000            <1> 	.tmp_dword		dd 0
   967 00001536 00000000            <1> 	.tmp_dword2		dd 0
   968                              <1> 	
   969                              <1> ; Calculates the EBX root of EAX.
   970                              <1> ; IN: EAX = input, EBX = root
   971                              <1> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   972                              <1> 
   973                              <1> os_math_root:
   974 0000153A 6660                <1> 	pushad
   975 0000153C 6689C1              <1> 	mov ecx, eax				; Prepare the data
   976 0000153F 66BE02000000        <1> 	mov esi, 2
   977                              <1> .root_loop:
   978 00001545 6689F0              <1> 	mov eax, esi
   979 00001548 E8AAFF              <1> 	call os_math_power
   980 0000154B 6639C8              <1> 	cmp eax, ecx
   981 0000154E 0F840800            <1> 	je near .root_exact
   982 00001552 0F8F1300            <1> 	jg near .root_range
   983 00001556 6646                <1> 	inc esi
   984 00001558 EBEB                <1> 	jmp .root_loop
   985                              <1> .root_exact:
   986 0000155A 668936[8115]        <1> 	mov [.tmp_dword], esi
   987 0000155F 6661                <1> 	popad
   988 00001561 66A1[8115]          <1> 	mov eax, [.tmp_dword]
   989 00001565 6631D2              <1> 	xor edx, edx
   990 00001568 C3                  <1> 	ret
   991                              <1> .root_range:
   992 00001569 668936[8515]        <1> 	mov [.tmp_dword2], esi
   993 0000156E 664E                <1> 	dec esi
   994 00001570 668936[8115]        <1> 	mov [.tmp_dword], esi
   995 00001575 6661                <1> 	popad
   996 00001577 66A1[8115]          <1> 	mov eax, [.tmp_dword]
   997 0000157B 668B16[8515]        <1> 	mov edx, [.tmp_dword2]
   998 00001580 C3                  <1> 	ret
   999                              <1> 	
  1000 00001581 00000000            <1> 	.tmp_dword		dd 0
  1001 00001585 00000000            <1> 	.tmp_dword2		dd 0
  1002                              <1> 
  1003                              <1> ; ==================================================================
   817                                  	%INCLUDE "features/misc.asm"
   818                              <1> ; ==================================================================
   819                              <1> ; MISCELLANEOUS ROUTINES
   820                              <1> ; ==================================================================
   821                              <1> 
   822                              <1> ; ------------------------------------------------------------------
   823                              <1> ; os_pause -- Delay execution for specified 110ms chunks
   824                              <1> ; IN: AX = amount of ticks to wait
   825                              <1> 
   826                              <1> os_pause:
   827 00001589 60                  <1> 	pusha
   828 0000158A 83F800              <1> 	cmp ax, 0
   829 0000158D 741F                <1> 	je .time_up			; If delay = 0 then bail out
   830                              <1> 
   831 0000158F C706[C515]0000      <1> 	mov word [.counter_var], 0		; Zero the counter variable
   832                              <1> 
   833 00001595 A3[C315]            <1> 	mov [.orig_req_delay], ax	; Save it
   834                              <1> 
   835 00001598 B400                <1> 	mov ah, 0
   836 0000159A E8DD01              <1> 	call os_int_1Ah				; Get tick count	
   837                              <1> 
   838 0000159D 8916[C715]          <1> 	mov [.prev_tick_count], dx	; Save it for later comparison
   839                              <1> 
   840                              <1> .checkloop:
   841 000015A1 B400                <1> 	mov ah,0
   842 000015A3 E8D401              <1> 	call os_int_1Ah				; Get tick count again
   843                              <1> 
   844 000015A6 3916[C715]          <1> 	cmp [.prev_tick_count], dx	; Compare with previous tick count
   845                              <1> 
   846 000015AA 7504                <1> 	jne .up_date			; If it's changed check it
   847 000015AC EBF3                <1> 	jmp .checkloop			; Otherwise wait some more
   848                              <1> 
   849                              <1> .time_up:
   850 000015AE 61                  <1> 	popa
   851 000015AF C3                  <1> 	ret
   852                              <1> 
   853                              <1> .up_date:
   854 000015B0 FF06[C515]          <1> 	inc word [.counter_var]		; Inc counter_var
   855 000015B4 A1[C515]            <1> 	mov ax, [.counter_var]
   856                              <1> 	
   857 000015B7 3B06[C315]          <1> 	cmp ax, [.orig_req_delay]	; Is counter_var = required delay?
   858 000015BB 7DF1                <1> 	jge .time_up			; Yes, so bail out
   859                              <1> 
   860 000015BD 8916[C715]          <1> 	mov [.prev_tick_count], dx	; No, so update .prev_tick_count 
   861                              <1> 
   862 000015C1 EBDE                <1> 	jmp .checkloop			; And go wait some more
   863                              <1> 
   864                              <1> 
   865 000015C3 0000                <1> 	.orig_req_delay		dw	0
   866 000015C5 0000                <1> 	.counter_var		dw	0
   867 000015C7 0000                <1> 	.prev_tick_count	dw	0
   868                              <1> 
   869                              <1> ; ------------------------------------------------------------------
   870                              <1> ; os_clear_registers -- Clear all registers
   871                              <1> ; IN: Nothing; OUT: Clear registers
   872                              <1> 
   873                              <1> os_clear_registers:
   874 000015C9 6631C0              <1> 	xor eax, eax
   875 000015CC 6631DB              <1> 	xor ebx, ebx
   876 000015CF 6631C9              <1> 	xor ecx, ecx
   877 000015D2 6631D2              <1> 	xor edx, edx
   878 000015D5 6631F6              <1> 	xor esi, esi
   879 000015D8 6631FF              <1> 	xor edi, edi
   880 000015DB C3                  <1> 	ret
   881                              <1> 
   882                              <1> os_illegal_call:
   883 000015DC B8[E115]            <1> 	mov ax, .msg
   884 000015DF EB7C                <1> 	jmp os_fatal_error
   885                              <1> 	
   886 000015E1 43616C6C6564206120- <1> 	.msg db 'Called a non-existent system function', 0
   886 000015EA 6E6F6E2D6578697374- <1>
   886 000015F3 656E74207379737465- <1>
   886 000015FC 6D2066756E6374696F- <1>
   886 00001605 6E00                <1>
   887                              <1> 	
   888                              <1> os_update_clock:
   889 00001607 60                  <1> 	pusha
   890 00001608 803E820001          <1> 	cmp byte [0082h], 1
   891 0000160D 0F843B00            <1> 	je near .update_time_end
   892                              <1> 	
   893 00001611 B402                <1> 	mov ah, 02h			; Get the time
   894 00001613 E86401              <1> 	call os_int_1Ah
   895 00001616 3B0E[5A16]          <1> 	cmp cx, [.tmp_time]
   896 0000161A 0F842E00            <1> 	je near .update_time_end
   897 0000161E 890E[5A16]          <1> 	mov [.tmp_time], cx
   898                              <1> 	
   899 00001622 E80B03              <1> 	call os_get_cursor_pos
   900 00001625 52                  <1> 	push dx
   901                              <1> 	
   902 00001626 BB[4E16]            <1> 	mov bx, .tmp_buffer
   903 00001629 E88816              <1> 	call os_get_date_string
   904                              <1> 	
   905 0000162C BA4500              <1> 	mov dx, 69			; Display date
   906 0000162F E8F502              <1> 	call os_move_cursor
   907                              <1> 
   908 00001632 89DE                <1> 	mov si, bx
   909 00001634 E87F02              <1> 	call os_print_string
   910                              <1> 	
   911 00001637 BB[4E16]            <1> 	mov bx, .tmp_buffer
   912 0000163A E83016              <1> 	call os_get_time_string
   913                              <1> 
   914 0000163D BA3F00              <1> 	mov dx, 63			; Display time
   915 00001640 E8E402              <1> 	call os_move_cursor
   916 00001643 89DE                <1> 	mov si, bx
   917 00001645 E86E02              <1> 	call os_print_string
   918                              <1> 	
   919 00001648 5A                  <1> 	pop dx
   920 00001649 E8DB02              <1> 	call os_move_cursor
   921                              <1> 	
   922                              <1> .update_time_end:
   923 0000164C 61                  <1> 	popa
   924 0000164D C3                  <1> 	ret
   925                              <1> 	
   926 0000164E 00<rep Ch>          <1> 	.tmp_buffer		times 12 db 0
   927 0000165A 0000                <1> 	.tmp_time		dw 0
   928 0000165C 00                  <1> 	.tmp_hours		db 0
   929                              <1> 
   930                              <1> ; ------------------------------------------------------------------
   931                              <1> ; os_fatal_error -- Display error message and halt execution
   932                              <1> ; IN: AX = error message string location
   933                              <1> 
   934                              <1> os_fatal_error:
   935 0000165D A3[5917]            <1> 	mov [.ax], ax			; Store string location for now, ...
   936 00001660 E8AE02              <1> 	call os_clear_screen
   937                              <1> 	
   938                              <1> .main_screen:
   939 00001663 8CC8                <1> 	mov ax, cs
   940 00001665 8ED8                <1> 	mov ds, ax
   941 00001667 8EC0                <1> 	mov es, ax
   942                              <1> 
   943 00001669 B80300              <1> 	mov ax, 3
   944 0000166C CD10                <1> 	int 10h
   945                              <1> 	
   946 0000166E B80310              <1> 	mov ax, 1003h				; Set text output with certain attributes
   947 00001671 31DB                <1> 	xor bx, bx					; to be bright, and not blinking
   948 00001673 CD10                <1> 	int 10h	
   949                              <1> 
   950 00001675 B8[1117]            <1> 	mov ax, .title_msg
   951 00001678 BB[2517]            <1> 	mov bx, .footer_msg
   952 0000167B B94F00              <1> 	mov cx, 01001111b
   953 0000167E E8B108              <1> 	call os_draw_background
   954 00001681 E8240E              <1> 	call os_reset_font
   955                              <1> 	
   956 00001684 BA0002              <1> 	mov dx, 2 * 256
   957 00001687 E89D02              <1> 	call os_move_cursor
   958 0000168A BE[7209]            <1> 	mov si, bomblogo
   959 0000168D E8560E              <1> 	call os_draw_icon
   960                              <1> 	
   961 00001690 BA2302              <1> 	mov dx, 2 * 256 + 35
   962 00001693 E89102              <1> 	call os_move_cursor
   963                              <1> 	
   964 00001696 BE[2617]            <1> 	mov si, .msg0
   965 00001699 E81A02              <1> 	call os_print_string
   966                              <1> 	
   967 0000169C BA2303              <1> 	mov dx, 3 * 256 + 35
   968 0000169F E88502              <1> 	call os_move_cursor
   969                              <1> 	
   970 000016A2 B82A0A              <1> 	mov ax, 0A2Ah					; Write a 43-character long asterisk-type line
   971 000016A5 B700                <1> 	mov bh, 0
   972 000016A7 B92B00              <1> 	mov cx, 43
   973 000016AA CD10                <1> 	int 10h
   974                              <1> 	
   975 000016AC BA2305              <1> 	mov dx, 5 * 256 + 35
   976 000016AF E87502              <1> 	call os_move_cursor
   977 000016B2 BE[5117]            <1> 	mov si, .msg3
   978 000016B5 E8FE01              <1> 	call os_print_string
   979                              <1> 
   980 000016B8 8B36[5917]          <1> 	mov si, [.ax]
   981 000016BC E8F701              <1> 	call os_print_string
   982                              <1> 
   983 000016BF E8A502              <1> 	call os_hide_cursor
   984                              <1> 	
   985 000016C2 5B                  <1> 	pop bx
   986 000016C3 58                  <1> 	pop ax
   987                              <1> 	
   988                              <1> 	mov16 dx, 35, 7
    18 000016C4 BA2307              <2>  mov %1, (%2 + %3 * 256)
   989 000016C7 E85D02              <1> 	call os_move_cursor
   990                              <1> 	
   991 000016CA BE[F016]            <1> 	mov si, .msg
   992 000016CD E8E601              <1> 	call os_print_string
   993                              <1> 	
   994 000016D0 E88E0B              <1> 	call os_print_4hex
   995                              <1> 	
   996 000016D3 B03A                <1> 	mov al, ':'
   997 000016D5 E8CA01              <1> 	call os_putchar
   998                              <1> 	
   999 000016D8 89D8                <1> 	mov ax, bx
  1000 000016DA E8840B              <1> 	call os_print_4hex
  1001                              <1> 	
  1002                              <1> 	mov16 dx, 35, 8
    18 000016DD BA2308              <2>  mov %1, (%2 + %3 * 256)
  1003 000016E0 E84402              <1> 	call os_move_cursor
  1004                              <1> 	
  1005 000016E3 BE[0117]            <1> 	mov si, .msg1
  1006 000016E6 E8CD01              <1> 	call os_print_string
  1007                              <1> 	
  1008 000016E9 89E0                <1> 	mov ax, sp
  1009 000016EB E8730B              <1> 	call os_print_4hex
  1010                              <1> 	
  1011 000016EE FA                  <1> 	cli
  1012 000016EF F4                  <1> 	hlt
  1013                              <1> 	
  1014 000016F0 4372617368206C6F63- <1> 	.msg 			db 'Crash location: ', 0
  1014 000016F9 6174696F6E3A2000    <1>
  1015 00001701 537461636B20706F69- <1> 	.msg1			db 'Stack pointer: ', 0
  1015 0000170A 6E7465723A2000      <1>
  1016                              <1> 	
  1017 00001711 4D696368616C4F5320- <1> 	.title_msg		db 'MichalOS Fatal Error'
  1017 0000171A 466174616C20457272- <1>
  1017 00001723 6F72                <1>
  1018 00001725 00                  <1> 	.footer_msg		db 0
  1019                              <1> 	
  1020 00001726 4D696368616C4F5320- <1> 	.msg0			db 'MichalOS has encountered a critical error.', 0
  1020 0000172F 68617320656E636F75- <1>
  1020 00001738 6E7465726564206120- <1>
  1020 00001741 637269746963616C20- <1>
  1020 0000174A 6572726F722E00      <1>
  1021 00001751 4572726F723A2000    <1> 	.msg3			db 'Error: ', 0
  1022                              <1> 
  1023 00001759 0000                <1> 	.ax				dw 0
  1024                              <1> 
  1025                              <1> ; Gets the amount of system RAM.
  1026                              <1> ; IN: nothing
  1027                              <1> ; OUT: AX = conventional memory(kB), EBX = high memory(kB)
  1028                              <1> os_get_memory:
  1029 0000175B 60                  <1> 	pusha
  1030 0000175C 31C9                <1> 	xor cx, cx
  1031 0000175E CD12                <1> 	int 12h					; Get the conventional memory size...
  1032 00001760 A3[7317]            <1> 	mov [.conv_mem], ax		; ...and store it
  1033                              <1> 	
  1034 00001763 B488                <1> 	mov ah, 88h				; Also get the high memory (>1MB)...
  1035 00001765 CD15                <1> 	int 15h
  1036 00001767 A3[7517]            <1> 	mov [.high_mem], ax		; ...and store it too
  1037 0000176A 61                  <1> 	popa
  1038 0000176B A1[7317]            <1> 	mov ax, [.conv_mem]
  1039 0000176E 8B1E[7517]          <1> 	mov bx, [.high_mem]
  1040 00001772 C3                  <1> 	ret
  1041                              <1> 
  1042 00001773 0000                <1> 	.conv_mem	dw 0
  1043 00001775 0000                <1> 	.high_mem	dw 0
  1044                              <1> 
  1045                              <1> ; Calls a system function from a far location.
  1046                              <1> ; IN: BP = System function number (8000h, 8003h...)
  1047                              <1> ; OUT: nothing
  1048                              <1> os_far_call:
  1049 00001777 FFD5                <1> 	call bp
  1050 00001779 CB                  <1> 	retf
  1051                              <1> 	
  1052                              <1> ; Serves as a middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
  1053                              <1> ; IN/OUT: same as int 1Ah
  1054                              <1> os_int_1Ah:
  1055 0000177A 60                  <1> 	pusha
  1056                              <1> 
  1057 0000177B 80FC02              <1> 	cmp ah, 2		; Read system time
  1058 0000177E 7416                <1> 	je .read_time
  1059                              <1> 	
  1060 00001780 80FC04              <1> 	cmp ah, 4		; Read system date
  1061 00001783 7404                <1> 	je .read_date
  1062                              <1> 	
  1063 00001785 61                  <1> 	popa
  1064 00001786 CD1A                <1> 	int 1Ah
  1065 00001788 C3                  <1> 	ret
  1066                              <1> 	
  1067                              <1> .read_date:
  1068 00001789 E81700              <1> 	call .update_time
  1069 0000178C 61                  <1> 	popa
  1070 0000178D 8B16[6718]          <1> 	mov dx, [.days]
  1071 00001791 8B0E[6918]          <1> 	mov cx, [.years]
  1072 00001795 C3                  <1> 	ret
  1073                              <1> 	
  1074                              <1> .read_time:
  1075 00001796 E80A00              <1> 	call .update_time
  1076                              <1> 	
  1077 00001799 61                  <1> 	popa
  1078 0000179A 8A36[6418]          <1> 	mov dh, [.seconds]
  1079 0000179E 8B0E[6518]          <1> 	mov cx, [.minutes]
  1080                              <1> 	
  1081 000017A2 C3                  <1> 	ret
  1082                              <1> 
  1083                              <1> .update_time:
  1084 000017A3 B404                <1> 	mov ah, 4
  1085 000017A5 CD1A                <1> 	int 1Ah
  1086 000017A7 8916[6718]          <1> 	mov [.days], dx
  1087 000017AB 890E[6918]          <1> 	mov [.years], cx
  1088                              <1> 	
  1089 000017AF B402                <1> 	mov ah, 2
  1090 000017B1 CD1A                <1> 	int 1Ah
  1091                              <1> 
  1092 000017B3 8836[6418]          <1> 	mov [.seconds], dh
  1093 000017B7 890E[6518]          <1> 	mov [.minutes], cx
  1094                              <1> 	
  1095                              <1> 	; Convert all of these values from BCD to integers
  1096                              <1> 	
  1097 000017BB B90700              <1> 	mov cx, 7
  1098 000017BE BE[6418]            <1> 	mov si, .seconds
  1099 000017C1 89F7                <1> 	mov di, si
  1100                              <1> 	
  1101                              <1> .loop:
  1102 000017C3 AC                  <1> 	lodsb
  1103 000017C4 E8F9FC              <1> 	call os_bcd_to_int
  1104 000017C7 AA                  <1> 	stosb
  1105                              <1> 	
  1106 000017C8 E2F9                <1> 	loop .loop
  1107                              <1> 	
  1108                              <1> 	; Calculate the time with the time offset
  1109                              <1> 	
  1110 000017CA A1F9DE              <1> 	mov ax, [57081]
  1111 000017CD A90080              <1> 	test ax, 8000h
  1112 000017D0 7541                <1> 	jnz .subtract
  1113                              <1> 	
  1114 000017D2 31D2                <1> 	xor dx, dx
  1115 000017D4 BB3C00              <1> 	mov bx, 60
  1116 000017D7 F7F3                <1> 	div bx
  1117                              <1> 	
  1118                              <1> 	; DX = value to add to minutes
  1119                              <1> 	; AX = value to add to hours
  1120                              <1> 	
  1121 000017D9 0016[6518]          <1> 	add [.minutes], dl
  1122 000017DD 803E[6518]3C        <1> 	cmp byte [.minutes], 60
  1123 000017E2 7C19                <1> 	jl .add_minutes_ok
  1124                              <1> 	
  1125 000017E4 802E[6518]3C        <1> 	sub byte [.minutes], 60
  1126 000017E9 FE06[6618]          <1> 	inc byte [.hours]
  1127 000017ED 803E[6618]18        <1> 	cmp byte [.hours], 24
  1128 000017F2 7C09                <1> 	jl .add_minutes_ok
  1129                              <1> 	
  1130 000017F4 802E[6618]18        <1> 	sub byte [.hours], 24
  1131 000017F9 FE06[6718]          <1> 	inc byte [.days]
  1132                              <1> 	
  1133                              <1> 	; At this point I don't care
  1134                              <1> 	
  1135                              <1> .add_minutes_ok:
  1136 000017FD 0006[6618]          <1> 	add [.hours], al
  1137 00001801 803E[6618]18        <1> 	cmp byte [.hours], 24
  1138 00001806 7C4C                <1> 	jl .encodeandexit
  1139                              <1> 	
  1140 00001808 802E[6618]18        <1> 	sub byte [.hours], 24
  1141 0000180D FE06[6718]          <1> 	inc byte [.days]
  1142                              <1> 	
  1143 00001811 EB41                <1> 	jmp .encodeandexit
  1144                              <1> 	
  1145                              <1> .subtract:
  1146 00001813 F7D8                <1> 	neg ax
  1147                              <1> 	
  1148 00001815 31D2                <1> 	xor dx, dx
  1149 00001817 BB3C00              <1> 	mov bx, 60
  1150 0000181A F7F3                <1> 	div bx
  1151                              <1> 	
  1152                              <1> 	; DX = value to subtract from minutes
  1153                              <1> 	; AX = value to subtract from hours
  1154                              <1> 
  1155 0000181C 2816[6518]          <1> 	sub [.minutes], dl
  1156 00001820 803E[6518]00        <1> 	cmp byte [.minutes], 0
  1157 00001825 7D19                <1> 	jge .sub_minutes_ok
  1158                              <1> 	
  1159                              <1> 	
  1160 00001827 8006[6518]3C        <1> 	add byte [.minutes], 60
  1161 0000182C FE0E[6618]          <1> 	dec byte [.hours]
  1162 00001830 803E[6618]00        <1> 	cmp byte [.hours], 0
  1163 00001835 7D09                <1> 	jge .sub_minutes_ok
  1164                              <1> 	
  1165 00001837 8006[6618]18        <1> 	add byte [.hours], 24
  1166 0000183C FE0E[6718]          <1> 	dec byte [.days]
  1167                              <1> 	
  1168                              <1> 	; At this point I don't care
  1169                              <1> 	
  1170                              <1> .sub_minutes_ok:
  1171 00001840 2806[6618]          <1> 	sub [.hours], al
  1172 00001844 803E[6618]00        <1> 	cmp byte [.hours], 0
  1173 00001849 7D09                <1> 	jge .encodeandexit
  1174                              <1> 	
  1175 0000184B 8006[6618]18        <1> 	add byte [.hours], 24
  1176 00001850 FE0E[6718]          <1> 	dec byte [.days]
  1177                              <1> 	
  1178                              <1> .encodeandexit:
  1179 00001854 B90700              <1> 	mov cx, 7
  1180 00001857 BE[6418]            <1> 	mov si, .seconds
  1181 0000185A 89F7                <1> 	mov di, si
  1182                              <1> 	
  1183                              <1> .encode_loop:
  1184 0000185C AC                  <1> 	lodsb
  1185 0000185D E87BFC              <1> 	call os_int_to_bcd
  1186 00001860 AA                  <1> 	stosb
  1187 00001861 E2F9                <1> 	loop .encode_loop
  1188                              <1> 
  1189 00001863 C3                  <1> 	ret
  1190                              <1> 	
  1191                              <1> 	
  1192 00001864 00                  <1> 	.seconds	db 0
  1193 00001865 00                  <1> 	.minutes	db 0
  1194 00001866 00                  <1> 	.hours		db 0
  1195 00001867 00                  <1> 	.days		db 0
  1196 00001868 00                  <1> 	.months		db 0
  1197 00001869 00                  <1> 	.years		db 0
  1198 0000186A 00                  <1> 	.centuries	db 0
  1199                              <1> 	
  1200                              <1> ; ==================================================================
  1201                              <1> 
   818                                  	%INCLUDE "features/ports.asm"
   819                              <1> ; ==================================================================
   820                              <1> ; PORT INPUT AND OUTPUT ROUTINES
   821                              <1> ; ==================================================================
   822                              <1> 
   823                              <1> ; ------------------------------------------------------------------
   824                              <1> ; os_serial_port_enable -- Set up the serial port for transmitting data
   825                              <1> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   826                              <1> 
   827                              <1> os_serial_port_enable:
   828 0000186B 60                  <1> 	pusha
   829                              <1> 
   830                              <1> 	clr dx			; Configure serial port 1
    14 0000186C 31D2                <2>  xor %1, %1
   831 0000186E 83F801              <1> 	cmp ax, 1
   832 00001871 7405                <1> 	je .slow_mode
   833                              <1> 
   834 00001873 B8E300              <1> 	mov ax, 11100011b		; 9600 baud, no parity, 8 data bits, 1 stop bit
   835 00001876 EB03                <1> 	jmp .finish
   836                              <1> 
   837                              <1> .slow_mode:
   838 00001878 B88300              <1> 	mov ax, 10000011b		; 1200 baud, no parity, 8 data bits, 1 stop bit	
   839                              <1> 
   840                              <1> .finish:
   841 0000187B CD14                <1> 	int 14h
   842                              <1> 
   843 0000187D 61                  <1> 	popa
   844 0000187E C3                  <1> 	ret
   845                              <1> 
   846                              <1> 
   847                              <1> ; ------------------------------------------------------------------
   848                              <1> ; os_send_via_serial -- Send a byte via the serial port
   849                              <1> ; IN: AL = byte to send via serial; OUT: AH = Bit 7 clear on success
   850                              <1> 
   851                              <1> os_send_via_serial:
   852 0000187F 60                  <1> 	pusha
   853                              <1> 
   854 00001880 B401                <1> 	mov ah, 01h
   855                              <1> 	clr dx			; COM1
    14 00001882 31D2                <2>  xor %1, %1
   856                              <1> 
   857 00001884 CD14                <1> 	int 14h
   858                              <1> 
   859 00001886 8826[9018]          <1> 	mov [.tmp], ah
   860                              <1> 
   861 0000188A 61                  <1> 	popa
   862                              <1> 
   863 0000188B 8A26[9018]          <1> 	mov ah, [.tmp]
   864                              <1> 
   865 0000188F C3                  <1> 	ret
   866                              <1> 
   867 00001890 00                  <1> 	.tmp db 0
   868                              <1> 
   869                              <1> 
   870                              <1> ; ------------------------------------------------------------------
   871                              <1> ; os_get_via_serial -- Get a byte from the serial port
   872                              <1> ; IN: nothing; OUT: AL = byte that was received, AH = Bit 7 clear on success
   873                              <1> 
   874                              <1> os_get_via_serial:
   875 00001891 60                  <1> 	pusha
   876                              <1> 
   877 00001892 B402                <1> 	mov ah, 02h
   878                              <1> 	clr dx			; COM1
    14 00001894 31D2                <2>  xor %1, %1
   879                              <1> 
   880 00001896 CD14                <1> 	int 14h
   881                              <1> 
   882 00001898 A3[A018]            <1> 	mov [.tmp], ax
   883                              <1> 
   884 0000189B 61                  <1> 	popa
   885                              <1> 
   886 0000189C A1[A018]            <1> 	mov ax, [.tmp]
   887                              <1> 
   888 0000189F C3                  <1> 	ret
   889                              <1> 
   890                              <1> 
   891 000018A0 0000                <1> 	.tmp dw 0
   892                              <1> 
   893                              <1> ; ==================================================================
   894                              <1> 
   819                                  	%INCLUDE "features/screen.asm"
   820                              <1> ; ==================================================================
   821                              <1> ; SCREEN HANDLING SYSTEM CALLS
   822                              <1> ; ==================================================================
   823                              <1> 
   824                              <1> ; ------------------------------------------------------------------
   825                              <1> ; os_putchar -- Puts a character on the screen
   826                              <1> ; IN: AL = character
   827                              <1> ; OUT: Nothing (registers preserved)
   828                              <1> 
   829                              <1> os_putchar:
   830 000018A2 60                  <1> 	pusha
   831 000018A3 B40E                <1> 	mov ah, 0Eh
   832 000018A5 CD10                <1> 	int 10h
   833 000018A7 61                  <1> 	popa
   834 000018A8 C3                  <1> 	ret
   835                              <1> 
   836                              <1> ; ------------------------------------------------------------------
   837                              <1> ; os_put_chars -- Puts up to a set amount of characters on the screen
   838                              <1> ; IN: BL = terminator, SI = location, CX = character count
   839                              <1> ; OUT: Nothing (registers preserved)
   840                              <1> 
   841                              <1> os_put_chars:
   842 000018A9 60                  <1> 	pusha
   843                              <1> 	
   844                              <1> .loop:
   845 000018AA AC                  <1> 	lodsb
   846 000018AB 38D8                <1> 	cmp al, bl
   847 000018AD 7405                <1> 	je .done
   848                              <1> 	
   849 000018AF E8F0FF              <1> 	call os_putchar
   850                              <1> 	
   851 000018B2 E2F6                <1> 	loop .loop
   852                              <1> 	
   853                              <1> .done:
   854 000018B4 61                  <1> 	popa
   855 000018B5 C3                  <1> 	ret
   856                              <1> 
   857                              <1> ; ------------------------------------------------------------------
   858                              <1> ; os_print_string -- Displays text
   859                              <1> ; IN: SI = message location (zero-terminated string)
   860                              <1> ; OUT: Nothing (registers preserved)
   861                              <1> 
   862                              <1> os_print_string:
   863 000018B6 60                  <1> 	pusha
   864                              <1> 
   865                              <1> .repeat:
   866 000018B7 AC                  <1> 	lodsb				; Get char from string
   867 000018B8 3C00                <1> 	cmp al, 0
   868 000018BA 7405                <1> 	je .done			; If char is zero, end of string
   869                              <1> 
   870 000018BC E8E3FF              <1> 	call os_putchar
   871 000018BF EBF6                <1> 	jmp .repeat			; And move on to next char
   872                              <1> 
   873                              <1> .done:
   874 000018C1 61                  <1> 	popa
   875 000018C2 C3                  <1> 	ret
   876                              <1> 
   877                              <1> ; ------------------------------------------------------------------
   878                              <1> ; os_print_string_box -- Displays text inside a text-box.
   879                              <1> ; IN: SI = message location (zero-terminated string), DL = left alignment
   880                              <1> ; OUT: Nothing (registers preserved)
   881                              <1> 
   882                              <1> os_print_string_box:
   883 000018C3 60                  <1> 	pusha
   884 000018C4 88D1                <1> 	mov cl, dl
   885                              <1> 
   886                              <1> .repeat:
   887 000018C6 AC                  <1> 	lodsb				; Get char from string
   888 000018C7 3C00                <1> 	cmp al, 0
   889 000018C9 7409                <1> 	je .done			; If char is zero, end of string
   890                              <1> 
   891 000018CB 3C0D                <1> 	cmp al, 13
   892 000018CD 7407                <1> 	je .cr
   893                              <1> 	
   894 000018CF E8D0FF              <1> 	call os_putchar
   895 000018D2 EBF2                <1> 	jmp .repeat			; And move on to next char
   896                              <1> 
   897                              <1> .done:
   898 000018D4 61                  <1> 	popa
   899 000018D5 C3                  <1> 	ret
   900                              <1> 	
   901                              <1> .cr:
   902 000018D6 E85700              <1> 	call os_get_cursor_pos
   903 000018D9 88CA                <1> 	mov dl, cl
   904 000018DB E84900              <1> 	call os_move_cursor
   905 000018DE EBE6                <1> 	jmp .repeat
   906                              <1> 
   907                              <1> ; ------------------------------------------------------------------
   908                              <1> ; os_format_string -- Displays colored text
   909                              <1> ; IN: BL/SI = text color/message location (zero-terminated string)
   910                              <1> ; OUT: Nothing (registers preserved)
   911                              <1> 
   912                              <1> os_format_string:
   913 000018E0 60                  <1> 	pusha
   914                              <1> 
   915 000018E1 B409                <1> 	mov ah, 09h			; int 09h
   916 000018E3 B700                <1> 	mov bh, 0
   917 000018E5 B90100              <1> 	mov cx, 1
   918 000018E8 E84500              <1> 	call os_get_cursor_pos
   919                              <1> 	
   920                              <1> .repeat:
   921 000018EB AC                  <1> 	lodsb				; Get char from string
   922 000018EC 3C0D                <1> 	cmp al, 13
   923 000018EE 7411                <1> 	je .cr
   924 000018F0 3C0A                <1> 	cmp al, 10
   925 000018F2 7414                <1> 	je .lf
   926 000018F4 3C00                <1> 	cmp al, 0
   927 000018F6 7417                <1> 	je .done			; If char is zero, end of string
   928                              <1> 
   929 000018F8 CD10                <1> 	int 10h				; Otherwise, print it
   930                              <1> 
   931 000018FA FEC2                <1> 	inc dl
   932 000018FC E82800              <1> 	call os_move_cursor
   933                              <1> 	
   934 000018FF EBEA                <1> 	jmp .repeat			; And move on to next char
   935                              <1> 	
   936                              <1> .cr:
   937 00001901 B200                <1> 	mov dl, 0
   938 00001903 E82100              <1> 	call os_move_cursor
   939 00001906 EBE3                <1> 	jmp .repeat
   940                              <1> 
   941                              <1> .lf:
   942 00001908 FEC6                <1> 	inc dh
   943 0000190A E81A00              <1> 	call os_move_cursor
   944 0000190D EBDC                <1> 	jmp .repeat
   945                              <1> 	
   946                              <1> .done:
   947 0000190F 61                  <1> 	popa
   948 00001910 C3                  <1> 	ret
   949                              <1> 
   950                              <1> 
   951                              <1> ; ------------------------------------------------------------------
   952                              <1> ; os_clear_screen -- Clears the screen to background
   953                              <1> ; IN/OUT: Nothing (registers preserved)
   954                              <1> 
   955                              <1> os_clear_screen:
   956 00001911 60                  <1> 	pusha
   957                              <1> 
   958 00001912 BA0000              <1> 	mov dx, 0			; Position cursor at top-left
   959 00001915 E80F00              <1> 	call os_move_cursor
   960                              <1> 
   961                              <1> 	mov16 ax, 0, 6		; Scroll full-screen
    18 00001918 B80006              <2>  mov %1, (%2 + %3 * 256)
   962 0000191B B707                <1> 	mov bh, 7
   963                              <1> 	mov16 cx, 0, 0		; Top-left
    18 0000191D B90000              <2>  mov %1, (%2 + %3 * 256)
   964                              <1> 	mov16 dx, 79, 24	; Bottom-right
    18 00001920 BA4F18              <2>  mov %1, (%2 + %3 * 256)
   965 00001923 CD10                <1> 	int 10h
   966                              <1> 
   967 00001925 61                  <1> 	popa
   968 00001926 C3                  <1> 	ret
   969                              <1> 
   970                              <1> 
   971                              <1> ; ------------------------------------------------------------------
   972                              <1> ; os_move_cursor -- Moves cursor in text mode
   973                              <1> ; IN: DH, DL = row, column; OUT: Nothing (registers preserved)
   974                              <1> 
   975                              <1> os_move_cursor:
   976 00001927 60                  <1> 	pusha
   977                              <1> 
   978 00001928 B700                <1> 	mov bh, 0
   979 0000192A B402                <1> 	mov ah, 2
   980 0000192C CD10                <1> 	int 10h				; BIOS interrupt to move cursor
   981                              <1> 
   982 0000192E 61                  <1> 	popa
   983 0000192F C3                  <1> 	ret
   984                              <1> 
   985                              <1> 
   986                              <1> ; ------------------------------------------------------------------
   987                              <1> ; os_get_cursor_pos -- Return position of text cursor
   988                              <1> ; OUT: DH, DL = row, column
   989                              <1> 
   990                              <1> os_get_cursor_pos:
   991 00001930 60                  <1> 	pusha
   992                              <1> 
   993 00001931 B700                <1> 	mov bh, 0
   994 00001933 B403                <1> 	mov ah, 3
   995 00001935 CD10                <1> 	int 10h				; BIOS interrupt to get cursor position
   996                              <1> 
   997 00001937 8916[4119]          <1> 	mov [.tmp], dx
   998 0000193B 61                  <1> 	popa
   999 0000193C 8B16[4119]          <1> 	mov dx, [.tmp]
  1000 00001940 C3                  <1> 	ret
  1001                              <1> 
  1002                              <1> 
  1003 00001941 0000                <1> 	.tmp dw 0
  1004                              <1> 
  1005                              <1> 
  1006                              <1> ; ------------------------------------------------------------------
  1007                              <1> ; os_print_horiz_line -- Draw a horizontal line on the screen
  1008                              <1> ; IN: AX = line type (1 for double (-), otherwise single (=))
  1009                              <1> ; OUT: Nothing (registers preserved)
  1010                              <1> 
  1011                              <1> os_print_horiz_line:
  1012 00001943 60                  <1> 	pusha
  1013                              <1> 
  1014 00001944 89C1                <1> 	mov cx, ax			; Store line type param
  1015 00001946 B0C4                <1> 	mov al, 196			; Default is single-line code
  1016                              <1> 
  1017 00001948 83F901              <1> 	cmp cx, 1			; Was double-line specified in AX?
  1018 0000194B 7502                <1> 	jne .ready
  1019 0000194D B0CD                <1> 	mov al, 205			; If so, here's the code
  1020                              <1> 
  1021                              <1> .ready:
  1022 0000194F B95000              <1> 	mov cx, 80			; Counter
  1023 00001952 B40E                <1> 	mov ah, 0Eh			; BIOS output char routine
  1024 00001954 B700                <1> 	mov bh, 0
  1025                              <1> 	
  1026                              <1> .loop:
  1027 00001956 CD10                <1> 	int 10h
  1028 00001958 E2FC                <1> 	loop .loop
  1029                              <1> 	
  1030 0000195A 61                  <1> 	popa
  1031 0000195B C3                  <1> 	ret
  1032                              <1> 
  1033                              <1> 
  1034                              <1> ; ------------------------------------------------------------------
  1035                              <1> ; os_show_cursor -- Turns on cursor in text mode
  1036                              <1> ; IN/OUT: Nothing
  1037                              <1> 
  1038                              <1> os_show_cursor:
  1039 0000195C 60                  <1> 	pusha
  1040                              <1> 
  1041                              <1> 	mov16 cx, 7, 6
    18 0000195D B90706              <2>  mov %1, (%2 + %3 * 256)
  1042                              <1> 	mov16 ax, 3, 1
    18 00001960 B80301              <2>  mov %1, (%2 + %3 * 256)
  1043 00001963 CD10                <1> 	int 10h
  1044                              <1> 
  1045 00001965 61                  <1> 	popa
  1046 00001966 C3                  <1> 	ret
  1047                              <1> 
  1048                              <1> 
  1049                              <1> ; ------------------------------------------------------------------
  1050                              <1> ; os_hide_cursor -- Turns off cursor in text mode
  1051                              <1> ; IN/OUT: Nothing
  1052                              <1> 
  1053                              <1> os_hide_cursor:
  1054 00001967 60                  <1> 	pusha
  1055                              <1> 
  1056 00001968 B520                <1> 	mov ch, 32
  1057                              <1> 	mov16 ax, 3, 1	; AL must be video mode for buggy BIOSes!
    18 0000196A B80301              <2>  mov %1, (%2 + %3 * 256)
  1058 0000196D CD10                <1> 	int 10h
  1059                              <1> 
  1060 0000196F 61                  <1> 	popa
  1061 00001970 C3                  <1> 	ret
  1062                              <1> 
  1063                              <1> 
  1064                              <1> ; ------------------------------------------------------------------
  1065                              <1> ; os_draw_block -- Render block of specified colour
  1066                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
  1067                              <1> 
  1068                              <1> os_draw_block:
  1069 00001971 60                  <1> 	pusha
  1070                              <1> 
  1071                              <1> .more:
  1072 00001972 E8B2FF              <1> 	call os_move_cursor		; Move to block starting position
  1073                              <1> 
  1074                              <1> 	mov16 ax, ' ', 09h			; Draw colour section
    18 00001975 B82009              <2>  mov %1, (%2 + %3 * 256)
  1075 00001978 B700                <1> 	mov bh, 0
  1076 0000197A 89F1                <1> 	mov cx, si
  1077 0000197C CD10                <1> 	int 10h
  1078                              <1> 
  1079 0000197E FEC6                <1> 	inc dh				; Get ready for next line
  1080                              <1> 
  1081 00001980 0FB6C6              <1> 	movzx ax, dh		; Get current Y position into DL
  1082 00001983 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
  1083 00001985 75EB                <1> 	jne .more			; If not, keep drawing
  1084                              <1> 
  1085 00001987 61                  <1> 	popa
  1086 00001988 C3                  <1> 	ret
  1087                              <1> 
  1088                              <1> 
  1089                              <1> ; ------------------------------------------------------------------
  1090                              <1> ; os_file_selector -- Show a file selection dialog
  1091                              <1> ; IN: If [0087h] = 1, then BX = location of file extension list
  1092                              <1> ; OUT: AX = location of filename string (or carry set if Esc pressed)
  1093                              <1> 
  1094                              <1> os_file_selector:
  1095                              <1> 	; Get volume name
  1096                              <1> 	
  1097 00001989 60                  <1> 	pusha
  1098 0000198A B90100              <1> 	mov cx, 1					; Load first disk sector into RAM
  1099 0000198D 0FB6168400          <1> 	movzx dx, byte [0084h]
  1100 00001992 BB00E0              <1> 	mov bx, disk_buffer
  1101                              <1> 
  1102                              <1> 	mov16 ax, 1, 2
    18 00001995 B80102              <2>  mov %1, (%2 + %3 * 256)
  1103 00001998 F9                  <1> 	stc
  1104 00001999 CD13                <1> 	int 13h						; BIOS load sector call
  1105                              <1> 
  1106 0000199B BE2BE0              <1> 	mov si, disk_buffer + 2Bh	; Disk label starts here
  1107                              <1> 
  1108 0000199E BF[241C]            <1> 	mov di, .volname
  1109 000019A1 B90B00              <1> 	mov cx, 11					; Copy 11 chars of it
  1110 000019A4 F3A4                <1> 	rep movsb
  1111 000019A6 61                  <1> 	popa
  1112                              <1> 	
  1113 000019A7 60                  <1> 	pusha
  1114 000019A8 C706[091C]0000      <1> 	mov word [.filename], 0		; Terminate string in case user leaves without choosing
  1115                              <1> 
  1116 000019AE E8F5F0              <1> 	call os_report_free_space
  1117 000019B1 D1E8                <1> 	shr ax, 1					; Sectors -> kB
  1118 000019B3 A3[301C]            <1> 	mov [.freespace], ax
  1119                              <1> 	
  1120                              <1> 	; Add the filters, if desired
  1121                              <1> 
  1122 000019B6 BF5100              <1> 	mov di, 0051h
  1123 000019B9 C60500              <1> 	mov byte [di], 0
  1124                              <1> 	
  1125 000019BC 803E870001          <1> 	cmp byte [0087h], 1
  1126 000019C1 752F                <1> 	jne .no_filter
  1127                              <1> 	
  1128 000019C3 891E[321C]          <1> 	mov [.extension_list], bx
  1129                              <1> 
  1130 000019C7 BE[D31B]            <1> 	mov si, .filter_msg
  1131 000019CA BF5100              <1> 	mov di, 0051h
  1132 000019CD E83711              <1> 	call os_string_copy
  1133                              <1> 
  1134 000019D0 60                  <1> 	pusha
  1135 000019D1 BF5A00              <1> 	mov di, 0051h + 9
  1136 000019D4 89DE                <1> 	mov si, bx
  1137 000019D6 8A1C                <1> 	mov bl, [si]
  1138 000019D8 46                  <1> 	inc si
  1139 000019D9 B100                <1> 	mov cl, 0
  1140                              <1> 	
  1141                              <1> .filter_loop:
  1142 000019DB E82911              <1> 	call os_string_copy
  1143 000019DE C6450320            <1> 	mov byte [di + 3], ' '
  1144 000019E2 83C704              <1> 	add di, 4
  1145 000019E5 83C604              <1> 	add si, 4
  1146 000019E8 FEC1                <1> 	inc cl
  1147 000019EA 38D9                <1> 	cmp cl, bl
  1148 000019EC 75ED                <1> 	jne .filter_loop
  1149                              <1> 	
  1150 000019EE C60500              <1> 	mov byte [di], 0
  1151 000019F1 61                  <1> 	popa
  1152                              <1> 	
  1153                              <1> .no_filter:
  1154                              <1> 	; Create the filename index list
  1155                              <1> 
  1156 000019F2 E8B9F8              <1> 	call disk_read_root_dir		; Get the files into the buffer
  1157                              <1> 
  1158 000019F5 BE00E0              <1> 	mov si, disk_buffer			; Raw directory buffer
  1159 000019F8 BF00FC              <1> 	mov di, 64512				; Buffer for indexes
  1160 000019FB B90000              <1> 	mov cx, 0					; Number of found files
  1161                              <1> 
  1162                              <1> .index_loop:
  1163 000019FE 81FE00FC            <1> 	cmp si, 64512			; Are we done looping through the directory?
  1164 00001A02 744E                <1> 	je .done
  1165                              <1> 
  1166 00001A04 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
  1167 00001A07 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
  1168 00001A09 7442                <1> 	je .skip
  1169                              <1> 
  1170 00001A0B A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
  1171 00001A0D 753E                <1> 	jnz .skip			; Yes, ignore it
  1172                              <1> 
  1173 00001A0F 8A04                <1> 	mov al, [si]
  1174 00001A11 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
  1175 00001A13 7438                <1> 	je .skip
  1176                              <1> 
  1177 00001A15 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
  1178 00001A17 7439                <1> 	je .done
  1179                              <1> 
  1180 00001A19 60                  <1> 	pusha
  1181                              <1> 
  1182 00001A1A 803E870001          <1> 	cmp byte [0087h], 1	; Check if we are supposed to filter the filenames
  1183 00001A1F 7523                <1> 	jne .no_extension_check
  1184                              <1> 	
  1185 00001A21 8B1E[321C]          <1> 	mov bx, [.extension_list]
  1186 00001A25 0FB60F              <1> 	movzx cx, byte [bx]
  1187                              <1> 
  1188                              <1> .extension_loop:
  1189 00001A28 60                  <1> 	pusha
  1190 00001A29 83C608              <1> 	add si, 8
  1191                              <1> 	
  1192 00001A2C 49                  <1> 	dec cx
  1193 00001A2D 89CF                <1> 	mov di, cx
  1194 00001A2F C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1195 00001A32 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1196 00001A33 033E[321C]          <1> 	add di, [.extension_list]
  1197                              <1> 	
  1198 00001A37 B90300              <1> 	mov cx, 3
  1199 00001A3A F3A6                <1> 	rep cmpsb
  1200 00001A3C 61                  <1> 	popa
  1201 00001A3D 7405                <1> 	je .no_extension_check
  1202                              <1> 	
  1203 00001A3F E2E7                <1> 	loop .extension_loop
  1204                              <1> 	
  1205 00001A41 61                  <1> 	popa
  1206 00001A42 EB09                <1> 	jmp .skip
  1207                              <1> 
  1208                              <1> .no_extension_check:
  1209 00001A44 61                  <1> 	popa
  1210                              <1> 
  1211 00001A45 41                  <1> 	inc cx				; Increment the number of discovered files
  1212 00001A46 89F0                <1> 	mov ax, si			; Store the filename pointer into the buffer
  1213 00001A48 AB                  <1> 	stosw
  1214                              <1> 
  1215 00001A49 C6440B00            <1> 	mov byte [si+11], 0	; Zero-terminate the string
  1216                              <1> 
  1217                              <1> .skip:
  1218 00001A4D 83C620              <1> 	add si, byte 32		; Skip to the next file
  1219 00001A50 EBAC                <1> 	jmp .index_loop
  1220                              <1> 
  1221                              <1> .done:
  1222                              <1> 	; Let the user select a file
  1223                              <1> 
  1224 00001A52 89C8                <1> 	mov ax, cx			; Pass the number of files
  1225 00001A54 BB[F51B]            <1> 	mov bx, .root
  1226 00001A57 B95100              <1> 	mov cx, 0051h
  1227 00001A5A BE[A61A]            <1> 	mov si, .callback
  1228                              <1> 
  1229 00001A5D C606[341C]01        <1> 	mov byte [.file_selector_calling], 1
  1230 00001A62 E8D301              <1> 	call os_list_dialog_tooltip
  1231 00001A65 C606[341C]00        <1> 	mov byte [.file_selector_calling], 0
  1232                              <1> 
  1233 00001A6A 7209                <1> 	jc .esc_pressed
  1234                              <1> 
  1235 00001A6C E80900              <1> 	call .get_filename
  1236                              <1> 	
  1237 00001A6F 61                  <1> 	popa
  1238 00001A70 B8[091C]            <1> 	mov ax, .filename
  1239 00001A73 F8                  <1> 	clc
  1240 00001A74 C3                  <1> 	ret
  1241                              <1> 
  1242                              <1> .esc_pressed:				; Set carry flag if Escape was pressed
  1243 00001A75 61                  <1> 	popa
  1244 00001A76 F9                  <1> 	stc
  1245 00001A77 C3                  <1> 	ret
  1246                              <1> 
  1247                              <1> .get_filename:
  1248 00001A78 48                  <1> 	dec ax				; Result from os_list_dialog starts from 1, but
  1249                              <1> 						; for our file list offset we want to start from 0
  1250                              <1> 	
  1251 00001A79 89C6                <1> 	mov si, ax			; Get the pointer to the string in the index
  1252 00001A7B D1E6                <1> 	shl si, 1
  1253 00001A7D 81C600FC            <1> 	add si, 64512
  1254                              <1> 
  1255 00001A81 AD                  <1> 	lodsw
  1256 00001A82 89C6                <1> 	mov si, ax			; Our resulting pointer
  1257                              <1> 	clr cx
    14 00001A84 31C9                <2>  xor %1, %1
  1258 00001A86 BF[091C]            <1> 	mov di, .filename
  1259                              <1> 	
  1260                              <1> .loopy:
  1261 00001A89 AC                  <1> 	lodsb
  1262 00001A8A 3C20                <1> 	cmp al, ' '
  1263 00001A8C 7401                <1> 	je .ignore_space
  1264 00001A8E AA                  <1> 	stosb
  1265                              <1> 	
  1266                              <1> .ignore_space:
  1267 00001A8F 41                  <1> 	inc cx
  1268 00001A90 83F908              <1> 	cmp cx, 8
  1269 00001A93 7407                <1> 	je .add_dot
  1270 00001A95 83F90B              <1> 	cmp cx, 11
  1271 00001A98 7408                <1> 	je .done_copy
  1272 00001A9A EBED                <1> 	jmp .loopy
  1273                              <1> 
  1274                              <1> .add_dot:
  1275 00001A9C C6052E              <1> 	mov byte [di], '.'
  1276 00001A9F 47                  <1> 	inc di
  1277 00001AA0 EBE7                <1> 	jmp .loopy
  1278                              <1> 
  1279                              <1> .done_copy:
  1280 00001AA2 C60500              <1> 	mov byte [di], 0
  1281                              <1> 
  1282 00001AA5 C3                  <1> 	ret
  1283                              <1> 	
  1284                              <1> .callback:
  1285                              <1> 	; Draw the box on the right
  1286 00001AA6 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1287                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    18 00001AAA BA2902              <2>  mov %1, (%2 + %3 * 256)
  1288 00001AAD BE2500              <1> 	mov si, 37			; Width
  1289 00001AB0 BF1700              <1> 	mov di, 23			; Finish Y position
  1290 00001AB3 E8BBFE              <1> 	call os_draw_block	; Draw option selector window
  1291                              <1> 
  1292                              <1> 	; Draw the icon's background
  1293 00001AB6 B3F0                <1> 	mov bl, 0F0h
  1294                              <1> 	mov16 dx, 50, 3
    18 00001AB8 BA3203              <2>  mov %1, (%2 + %3 * 256)
  1295 00001ABB BE1300              <1> 	mov si, 19			; Width
  1296 00001ABE BF0D00              <1> 	mov di, 13			; Finish Y position
  1297 00001AC1 E8ADFE              <1> 	call os_draw_block	; Draw option selector window	
  1298                              <1> 
  1299                              <1> 	; Draw the icon
  1300                              <1> 	
  1301                              <1> 	mov16 dx, 52, 4
    18 00001AC4 BA3404              <2>  mov %1, (%2 + %3 * 256)
  1302 00001AC7 E85DFE              <1> 	call os_move_cursor
  1303                              <1> 	
  1304 00001ACA BE[040A]            <1> 	mov si, filelogo
  1305 00001ACD E8160A              <1> 	call os_draw_icon
  1306                              <1> 
  1307                              <1> 	; Display the filename
  1308                              <1> 
  1309                              <1> 	mov16 dx, 42, 14
    18 00001AD0 BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  1310 00001AD3 E851FE              <1> 	call os_move_cursor
  1311                              <1> 
  1312 00001AD6 50                  <1> 	push ax
  1313 00001AD7 E89EFF              <1> 	call .get_filename
  1314                              <1> 	
  1315 00001ADA BE[091C]            <1> 	mov si, .filename
  1316 00001ADD E8D6FD              <1> 	call os_print_string
  1317                              <1> 	
  1318                              <1> 	; Find the correct directory entry for this file
  1319                              <1> 
  1320 00001AE0 58                  <1> 	pop ax
  1321                              <1> 
  1322 00001AE1 48                  <1> 	dec ax
  1323 00001AE2 89C6                <1> 	mov si, ax
  1324 00001AE4 D1E6                <1> 	shl si, 1
  1325 00001AE6 81C600FC            <1> 	add si, 64512
  1326 00001AEA 8B34                <1> 	mov si, [si]			; Get the pointer to the entry in the index list
  1327                              <1> 
  1328 00001AEC 56                  <1> 	push si
  1329                              <1> 	
  1330                              <1> 	; Display the file size
  1331                              <1> 	
  1332 00001AED 668B441C            <1> 	mov eax, [si + 28]
  1333 00001AF1 E81D12              <1> 	call os_32int_to_string
  1334                              <1> 	
  1335 00001AF4 89C6                <1> 	mov si, ax
  1336 00001AF6 BF[091C]            <1> 	mov di, .filename
  1337 00001AF9 E80B10              <1> 	call os_string_copy
  1338                              <1> 	
  1339 00001AFC B8[091C]            <1> 	mov ax, .filename
  1340 00001AFF BB[DD1B]            <1> 	mov bx, .byte_msg
  1341 00001B02 E8600F              <1> 	call os_string_add
  1342                              <1> 	
  1343 00001B05 E86C0F              <1> 	call os_string_length
  1344                              <1> 
  1345 00001B08 B24D                <1> 	mov dl, 77
  1346 00001B0A 28C2                <1> 	sub dl, al
  1347 00001B0C E818FE              <1> 	call os_move_cursor
  1348                              <1> 	
  1349 00001B0F BE[091C]            <1> 	mov si, .filename
  1350 00001B12 E8A1FD              <1> 	call os_print_string
  1351                              <1> 	
  1352                              <1> 	; Display the file write date/time
  1353                              <1> 	
  1354 00001B15 C606[091C]00        <1> 	mov byte [.filename], 0
  1355                              <1> 	
  1356 00001B1A 5E                  <1> 	pop si
  1357 00001B1B 8B5C0E              <1> 	mov bx, [si + 14]
  1358 00001B1E 8B4C10              <1> 	mov cx, [si + 16]
  1359                              <1> 	
  1360 00001B21 53                  <1> 	push bx
  1361 00001B22 89C8                <1> 	mov ax, cx		; Days
  1362 00001B24 83E01F              <1> 	and ax, 11111b
  1363                              <1> 	
  1364 00001B27 BA[EF1B]            <1> 	mov dx, .dateseparator
  1365 00001B2A E88400              <1> 	call .cb_add_num
  1366                              <1> 	
  1367 00001B2D 89C8                <1> 	mov ax, cx		; Months
  1368 00001B2F C1E805              <1> 	shr ax, 5
  1369 00001B32 83E00F              <1> 	and ax, 1111b
  1370                              <1> 	
  1371 00001B35 E87900              <1> 	call .cb_add_num
  1372                              <1> 	
  1373 00001B38 89C8                <1> 	mov ax, cx		; Years
  1374 00001B3A C1E809              <1> 	shr ax, 9
  1375 00001B3D 05BC07              <1> 	add ax, 1980
  1376                              <1> 	
  1377 00001B40 BA[F11B]            <1> 	mov dx, .whiteseparator
  1378 00001B43 E86B00              <1> 	call .cb_add_num
  1379                              <1> 	
  1380 00001B46 59                  <1> 	pop cx
  1381                              <1> 	
  1382 00001B47 89C8                <1> 	mov ax, cx		; Hours
  1383 00001B49 C1E80B              <1> 	shr ax, 11
  1384                              <1> 
  1385 00001B4C BA[ED1B]            <1> 	mov dx, .timeseparator
  1386 00001B4F E85F00              <1> 	call .cb_add_num
  1387                              <1> 	
  1388 00001B52 89C8                <1> 	mov ax, cx		; Minutes
  1389 00001B54 C1E805              <1> 	shr ax, 5
  1390 00001B57 83E03F              <1> 	and ax, 111111b
  1391                              <1> 	
  1392 00001B5A E85400              <1> 	call .cb_add_num
  1393                              <1> 
  1394 00001B5D 89C8                <1> 	mov ax, cx		; Seconds
  1395 00001B5F 83E01F              <1> 	and ax, 11111b
  1396 00001B62 D1E0                <1> 	shl ax, 1
  1397                              <1> 
  1398 00001B64 BA[D21B]            <1> 	mov dx, .help_msg2
  1399 00001B67 E84700              <1> 	call .cb_add_num
  1400                              <1> 	
  1401                              <1> 	mov16 dx, 42, 16
    18 00001B6A BA2A10              <2>  mov %1, (%2 + %3 * 256)
  1402 00001B6D E8B7FD              <1> 	call os_move_cursor
  1403                              <1> 
  1404 00001B70 BE[F91B]            <1> 	mov si, .time_msg
  1405 00001B73 E840FD              <1> 	call os_print_string
  1406                              <1> 	
  1407                              <1> 	; Display volume information
  1408                              <1> 	
  1409                              <1> 	mov16 dx, 42, 20
    18 00001B76 BA2A14              <2>  mov %1, (%2 + %3 * 256)
  1410 00001B79 E8ABFD              <1> 	call os_move_cursor
  1411                              <1> 
  1412 00001B7C B8C409              <1> 	mov ax, 09C4h
  1413 00001B7F 0FB61EA9DE          <1> 	movzx bx, byte [57001]
  1414 00001B84 B92300              <1> 	mov cx, 35
  1415 00001B87 CD10                <1> 	int 10h
  1416                              <1> 	
  1417 00001B89 FEC6                <1> 	inc dh
  1418 00001B8B E899FD              <1> 	call os_move_cursor
  1419                              <1> 
  1420 00001B8E BE[1D1C]            <1> 	mov si, .vol_msg
  1421 00001B91 E822FD              <1> 	call os_print_string
  1422                              <1> 	
  1423 00001B94 A1[301C]            <1> 	mov ax, [.freespace]
  1424 00001B97 E86B10              <1> 	call os_int_to_string
  1425 00001B9A 89C6                <1> 	mov si, ax
  1426 00001B9C E8D50E              <1> 	call os_string_length
  1427                              <1> 	
  1428 00001B9F 80C21B              <1> 	add dl, 27
  1429 00001BA2 28C2                <1> 	sub dl, al
  1430 00001BA4 E880FD              <1> 	call os_move_cursor
  1431                              <1> 		
  1432 00001BA7 E80CFD              <1> 	call os_print_string
  1433                              <1> 		
  1434 00001BAA BE[E41B]            <1> 	mov si, .free_msg
  1435 00001BAD E806FD              <1> 	call os_print_string
  1436 00001BB0 C3                  <1> 	ret
  1437                              <1> 	
  1438                              <1> .cb_add_num:
  1439 00001BB1 83F80A              <1> 	cmp ax, 10
  1440 00001BB4 7D0B                <1> 	jge .no_zero
  1441                              <1> 	
  1442 00001BB6 50                  <1> 	push ax
  1443 00001BB7 BB[F31B]            <1> 	mov bx, .zerofill
  1444 00001BBA B8[091C]            <1> 	mov ax, .filename
  1445 00001BBD E8A50E              <1> 	call os_string_add
  1446 00001BC0 58                  <1> 	pop ax
  1447                              <1> 	
  1448                              <1> .no_zero:
  1449 00001BC1 E84110              <1> 	call os_int_to_string
  1450 00001BC4 89C3                <1> 	mov bx, ax
  1451 00001BC6 B8[091C]            <1> 	mov ax, .filename
  1452 00001BC9 E8990E              <1> 	call os_string_add
  1453                              <1> 	
  1454 00001BCC 89D3                <1> 	mov bx, dx
  1455 00001BCE E8940E              <1> 	call os_string_add
  1456                              <1> 
  1457 00001BD1 C3                  <1> 	ret
  1458                              <1> 	
  1459 00001BD2 00                  <1> 	.help_msg2		db 0
  1460 00001BD3 46696C746572733A20- <1> 	.filter_msg		db 'Filters: ', 0
  1460 00001BDC 00                  <1>
  1461 00001BDD 20627974657300      <1> 	.byte_msg		db ' bytes', 0
  1462 00001BE4 206B42206672656500  <1> 	.free_msg		db ' kB free', 0
  1463 00001BED 3A00                <1> 	.timeseparator	db ':', 0
  1464 00001BEF 2F00                <1> 	.dateseparator	db '/', 0
  1465 00001BF1 2000                <1> 	.whiteseparator	db ' ', 0
  1466 00001BF3 3000                <1> 	.zerofill		db '0', 0
  1467 00001BF5 413A2F00            <1> 	.root			db 'A:/', 0
  1468                              <1> 
  1469 00001BF9 5772697474656E2074- <1> 	.time_msg		db 'Written to on:  '
  1469 00001C02 6F206F6E3A2020      <1>
  1470 00001C09 00<rep 14h>         <1> 	.filename		times 20 db 0
  1471                              <1> 	
  1472 00001C1D 566F6C756D6520      <1> 	.vol_msg		db 'Volume '
  1473 00001C24 00<rep Ch>          <1> 	.volname		times 12 db 0
  1474 00001C30 0000                <1> 	.freespace		dw 0
  1475 00001C32 0000                <1> 	.extension_list	dw 0
  1476                              <1> 
  1477 00001C34 00                  <1> 	.file_selector_calling			db 0
  1478 00001C35 00                  <1> 	.file_selector_cursorpos		db 0
  1479 00001C36 00                  <1> 	.file_selector_skipnum			db 0
  1480 00001C37 00                  <1> 	.file_selector_numofentries		db 0
  1481                              <1> 
  1482                              <1> 
  1483                              <1> ; ------------------------------------------------------------------
  1484                              <1> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
  1485                              <1> ; That means, when the user changes the selection, the application will be called back
  1486                              <1> ; to change the tooltip's contents.
  1487                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1488                              <1> ;     BX = first help string, CX = second help string
  1489                              <1> ;     SI = callback pointer
  1490                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1491                              <1> 
  1492                              <1> os_list_dialog_tooltip:
  1493 00001C38 C70689002500        <1> 	mov word [0089h], 37
  1494                              <1> 	
  1495 00001C3E 8936[731C]          <1> 	mov [.callbackaddr], si
  1496                              <1> 	
  1497 00001C42 C706[301F][581C]    <1> 	mov word [os_list_dialog.callback], .callback
  1498 00001C48 E82A00              <1> 	call os_list_dialog
  1499 00001C4B C706[301F]0000      <1> 	mov word [os_list_dialog.callback], 0
  1500 00001C51 C70689004C00        <1> 	mov word [0089h], 76
  1501 00001C57 C3                  <1> 	ret
  1502                              <1> 	
  1503                              <1> .callback:
  1504                              <1> 	; Draw the box on the right
  1505 00001C58 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1506                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    18 00001C5C BA2902              <2>  mov %1, (%2 + %3 * 256)
  1507 00001C5F BE2500              <1> 	mov si, 37			; Width
  1508 00001C62 BF1700              <1> 	mov di, 23			; Finish Y position
  1509 00001C65 E809FD              <1> 	call os_draw_block	; Draw option selector window	
  1510                              <1> 
  1511                              <1> 	mov16 dx, 42, 3
    18 00001C68 BA2A03              <2>  mov %1, (%2 + %3 * 256)
  1512 00001C6B E8B9FC              <1> 	call os_move_cursor
  1513                              <1> 
  1514 00001C6E FF16[731C]          <1> 	call [.callbackaddr]
  1515 00001C72 C3                  <1> 	ret
  1516                              <1> 	
  1517 00001C73 0000                <1> 	.callbackaddr	dw 0
  1518                              <1> 	
  1519                              <1> ; ------------------------------------------------------------------
  1520                              <1> ; os_list_dialog -- Show a dialog with a list of options
  1521                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1522                              <1> ;     BX = first help string, CX = second help string
  1523                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1524                              <1> 
  1525                              <1> os_list_dialog:
  1526 00001C75 60                  <1> 	pusha
  1527                              <1> 
  1528 00001C76 50                  <1> 	push ax				; Store string list for now
  1529                              <1> 
  1530 00001C77 51                  <1> 	push cx				; And help strings
  1531 00001C78 53                  <1> 	push bx
  1532                              <1> 
  1533 00001C79 E8EBFC              <1> 	call os_hide_cursor
  1534                              <1> 
  1535                              <1> 	; Are we calling from the file selector?
  1536                              <1> 
  1537 00001C7C 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1538 00001C81 7509                <1> 	jne .normal_count
  1539                              <1> 
  1540 00001C83 83F800              <1> 	cmp ax, 0
  1541 00001C86 740B                <1> 	je .empty_list
  1542                              <1> 
  1543 00001C88 89C1                <1> 	mov cx, ax
  1544                              <1> 
  1545 00001C8A EB4B                <1> 	jmp .done_count_f
  1546                              <1> 
  1547                              <1> .normal_count:
  1548 00001C8C 89C6                <1> 	mov si, ax
  1549 00001C8E 803C00              <1> 	cmp byte [si], 0
  1550 00001C91 7530                <1> 	jne .count_entries
  1551                              <1> 
  1552                              <1> .empty_list:
  1553 00001C93 83C406              <1> 	add sp, 6
  1554 00001C96 61                  <1> 	popa
  1555                              <1> 
  1556 00001C97 B8[A51C]            <1> 	mov ax, .nofilesmsg
  1557                              <1> 	clr bx
    14 00001C9A 31DB                <2>  xor %1, %1
  1558                              <1> 	clr cx
    14 00001C9C 31C9                <2>  xor %1, %1
  1559                              <1> 	clr dx
    14 00001C9E 31D2                <2>  xor %1, %1
  1560 00001CA0 E85604              <1> 	call os_dialog_box
  1561                              <1> 
  1562 00001CA3 F9                  <1> 	stc
  1563 00001CA4 C3                  <1> 	ret
  1564                              <1> 
  1565 00001CA5 546865726520617265- <1> 	.nofilesmsg	db "There are no items to select.", 0
  1565 00001CAE 206E6F206974656D73- <1>
  1565 00001CB7 20746F2073656C6563- <1>
  1565 00001CC0 742E00              <1>
  1566                              <1> 	
  1567                              <1> .count_entries:	
  1568 00001CC3 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1569                              <1> 	
  1570                              <1> .count_loop:
  1571 00001CC5 268A04              <1> 	mov al, [es:si]
  1572 00001CC8 46                  <1> 	inc si
  1573 00001CC9 3C00                <1> 	cmp al, 0
  1574 00001CCB 7408                <1> 	je .done_count
  1575 00001CCD 3C2C                <1> 	cmp al, ','
  1576 00001CCF 75F4                <1> 	jne .count_loop
  1577 00001CD1 FEC1                <1> 	inc cl
  1578 00001CD3 EBF0                <1> 	jmp .count_loop
  1579                              <1> 
  1580                              <1> .done_count:
  1581 00001CD5 FEC1                <1> 	inc cl
  1582                              <1> 
  1583                              <1> .done_count_f:
  1584 00001CD7 880E[241F]          <1> 	mov byte [.num_of_entries], cl
  1585                              <1> 
  1586                              <1> 
  1587 00001CDB 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1588                              <1> 	mov16 dx, 2, 2		; Start X/Y position
    18 00001CDF BA0202              <2>  mov %1, (%2 + %3 * 256)
  1589 00001CE2 8B368900            <1> 	mov si, [0089h]		; Width
  1590 00001CE6 BF1700              <1> 	mov di, 23			; Finish Y position
  1591 00001CE9 E885FC              <1> 	call os_draw_block	; Draw option selector window
  1592                              <1> 
  1593                              <1> 	mov16 dx, 3, 3		; Show first line of help text...
    18 00001CEC BA0303              <2>  mov %1, (%2 + %3 * 256)
  1594 00001CEF E835FC              <1> 	call os_move_cursor
  1595                              <1> 
  1596 00001CF2 5E                  <1> 	pop si				; Get back first string
  1597 00001CF3 E8C0FB              <1> 	call os_print_string
  1598                              <1> 
  1599 00001CF6 FEC6                <1> 	inc dh
  1600 00001CF8 E82CFC              <1> 	call os_move_cursor
  1601                              <1> 
  1602 00001CFB 5E                  <1> 	pop si				; ...and the second
  1603 00001CFC E8B7FB              <1> 	call os_print_string
  1604                              <1> 
  1605                              <1> 
  1606 00001CFF 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1607 00001D00 8936[261F]          <1> 	mov word [.list_string], si
  1608                              <1> 
  1609                              <1> 
  1610                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1611                              <1> 	; entry and let the user move up and down using the cursor keys
  1612                              <1> 
  1613 00001D04 C606[251F]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1614                              <1> 
  1615                              <1> 	mov16 dx, 25, 6			; Set up starting position for selector
    18 00001D09 BA1906              <2>  mov %1, (%2 + %3 * 256)
  1616                              <1> 
  1617 00001D0C 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1618 00001D11 7510                <1> 	jne .no_load_position
  1619                              <1> 	
  1620 00001D13 3A0E[371C]          <1> 	cmp cl, [os_file_selector.file_selector_numofentries]
  1621 00001D17 750A                <1> 	jne .no_load_position
  1622                              <1> 	
  1623 00001D19 8A36[351C]          <1> 	mov dh, [os_file_selector.file_selector_cursorpos]
  1624 00001D1D A0[361C]            <1> 	mov al, [os_file_selector.file_selector_skipnum]
  1625 00001D20 A2[251F]            <1> 	mov [.skip_num], al
  1626                              <1> 	
  1627                              <1> .no_load_position:
  1628 00001D23 E801FC              <1> 	call os_move_cursor
  1629                              <1> 
  1630                              <1> .more_select:
  1631 00001D26 60                  <1> 	pusha
  1632 00001D27 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1633                              <1> 	mov16 dx, 3, 5
    18 00001D29 BA0305              <2>  mov %1, (%2 + %3 * 256)
  1634 00001D2C 8B368900            <1> 	mov si, [0089h]
  1635 00001D30 83EE02              <1> 	sub si, byte 2
  1636 00001D33 BF1600              <1> 	mov di, 22
  1637 00001D36 E838FC              <1> 	call os_draw_block
  1638 00001D39 61                  <1> 	popa
  1639                              <1> 
  1640 00001D3A E8B701              <1> 	call .draw_black_bar
  1641                              <1> 
  1642 00001D3D 8B36[261F]          <1> 	mov word si, [.list_string]
  1643 00001D41 E8FA00              <1>  	call .draw_list
  1644                              <1> 
  1645                              <1> .another_key:
  1646 00001D44 E8F0F5              <1> 	call os_wait_for_key		; Move / select option
  1647 00001D47 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1648 00001D4A 7420                <1> 	je .go_up
  1649 00001D4C 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1650 00001D4F 742C                <1> 	je .go_down
  1651 00001D51 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1652 00001D53 0F849B00            <1> 	je .option_selected
  1653 00001D57 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1654 00001D59 0F84C400            <1> 	je .esc_pressed
  1655 00001D5D 3C09                <1> 	cmp al, 9			; Tab pressed?
  1656 00001D5F 7402                <1> 	je .tab_pressed
  1657 00001D61 EBC3                <1> 	jmp .more_select	; If not, wait for another key
  1658                              <1> 
  1659                              <1> .tab_pressed:
  1660 00001D63 B606                <1> 	mov dh, 6
  1661 00001D65 C606[251F]00        <1> 	mov byte [.skip_num], 0
  1662 00001D6A EBBA                <1> 	jmp .more_select
  1663                              <1> 	
  1664                              <1> .go_up:
  1665 00001D6C 80FE06              <1> 	cmp dh, 6			; Already at top?
  1666 00001D6F 7E2F                <1> 	jle .hit_top
  1667                              <1> 
  1668 00001D71 E89701              <1> 	call .draw_white_bar
  1669                              <1> 
  1670 00001D74 B219                <1> 	mov dl, 25
  1671 00001D76 E8AEFB              <1> 	call os_move_cursor
  1672                              <1> 
  1673 00001D79 FECE                <1> 	dec dh				; Row to select (increasing down)
  1674 00001D7B EBA9                <1> 	jmp .more_select
  1675                              <1> 
  1676                              <1> 
  1677                              <1> .go_down:				; Already at bottom of list?
  1678 00001D7D 80FE14              <1> 	cmp dh, 20
  1679 00001D80 742E                <1> 	je .hit_bottom
  1680                              <1> 
  1681                              <1> 	clr cx
    14 00001D82 31C9                <2>  xor %1, %1
  1682 00001D84 88F1                <1> 	mov byte cl, dh
  1683                              <1> 
  1684 00001D86 80E905              <1> 	sub cl, 5
  1685 00001D89 020E[251F]          <1> 	add byte cl, [.skip_num]
  1686                              <1> 
  1687 00001D8D A0[241F]            <1> 	mov byte al, [.num_of_entries]
  1688 00001D90 38C1                <1> 	cmp cl, al
  1689 00001D92 741C                <1> 	je .hit_bottom
  1690                              <1> 
  1691 00001D94 E87401              <1> 	call .draw_white_bar
  1692                              <1> 
  1693 00001D97 B219                <1> 	mov dl, 25
  1694 00001D99 E88BFB              <1> 	call os_move_cursor
  1695                              <1> 
  1696 00001D9C FEC6                <1> 	inc dh
  1697 00001D9E EB86                <1> 	jmp .more_select
  1698                              <1> 
  1699                              <1> 
  1700                              <1> .hit_top:
  1701 00001DA0 8A0E[251F]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1702 00001DA4 80F900              <1> 	cmp cl, 0
  1703 00001DA7 742C                <1> 	je .skip_to_bottom			; If not, wait for another key
  1704                              <1> 
  1705 00001DA9 FE0E[251F]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1706 00001DAD E976FF              <1> 	jmp .more_select
  1707                              <1> 
  1708                              <1> 
  1709                              <1> .hit_bottom:				; See if there's more to scroll
  1710                              <1> 	clr cx
    14 00001DB0 31C9                <2>  xor %1, %1
  1711 00001DB2 88F1                <1> 	mov byte cl, dh
  1712                              <1> 
  1713 00001DB4 80E906              <1> 	sub cl, 6
  1714 00001DB7 FEC1                <1> 	inc cl
  1715 00001DB9 020E[251F]          <1> 	add byte cl, [.skip_num]
  1716                              <1> 
  1717 00001DBD A0[241F]            <1> 	mov byte al, [.num_of_entries]
  1718 00001DC0 38C1                <1> 	cmp cl, al
  1719 00001DC2 7407                <1> 	je .skip_to_top
  1720                              <1> 
  1721 00001DC4 FE06[251F]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1722 00001DC8 E95BFF              <1> 	jmp .more_select
  1723                              <1> 
  1724                              <1> .skip_to_top:
  1725 00001DCB C606[251F]00        <1> 	mov byte [.skip_num], 0
  1726 00001DD0 B606                <1> 	mov dh, 6
  1727 00001DD2 E951FF              <1> 	jmp .more_select
  1728                              <1> 
  1729                              <1> .skip_to_bottom:
  1730 00001DD5 A0[241F]            <1> 	mov al, [.num_of_entries]
  1731 00001DD8 3C0F                <1> 	cmp al, 15
  1732 00001DDA 7E0A                <1> 	jle .basic_skip
  1733                              <1> 	
  1734                              <1> .no_basic_skip:
  1735 00001DDC B614                <1> 	mov dh, 20
  1736 00001DDE 2C0F                <1> 	sub al, 15
  1737 00001DE0 A2[251F]            <1> 	mov [.skip_num], al
  1738                              <1> 
  1739 00001DE3 E940FF              <1> 	jmp .more_select
  1740                              <1> 	
  1741                              <1> .basic_skip:
  1742 00001DE6 3C00                <1> 	cmp al, 0
  1743 00001DE8 7CF2                <1> 	jl .no_basic_skip
  1744 00001DEA 88C6                <1> 	mov dh, al
  1745 00001DEC 80C605              <1> 	add dh, 5
  1746 00001DEF E934FF              <1> 	jmp .more_select
  1747                              <1> 	
  1748                              <1> .option_selected:
  1749 00001DF2 E867FB              <1> 	call os_show_cursor
  1750                              <1> 
  1751 00001DF5 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1752 00001DFA 7510                <1> 	jne .no_store_position
  1753                              <1> 	
  1754 00001DFC 8836[351C]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1755 00001E00 A0[251F]            <1> 	mov al, [.skip_num]
  1756 00001E03 A2[361C]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1757 00001E06 A0[241F]            <1> 	mov al, [.num_of_entries]
  1758 00001E09 A2[371C]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1759                              <1> 	
  1760                              <1> .no_store_position:
  1761 00001E0C 80EE06              <1> 	sub dh, 6
  1762                              <1> 
  1763 00001E0F 0FB6C6              <1> 	movzx ax, dh
  1764                              <1> 
  1765 00001E12 FEC0                <1> 	inc al				; Options start from 1
  1766 00001E14 0206[251F]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1767                              <1> 
  1768 00001E18 A3[221F]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1769                              <1> 
  1770 00001E1B 61                  <1> 	popa
  1771                              <1> 
  1772 00001E1C A1[221F]            <1> 	mov word ax, [.tmp]
  1773 00001E1F F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1774 00001E20 C3                  <1> 	ret
  1775                              <1> 
  1776                              <1> 
  1777                              <1> 
  1778                              <1> .esc_pressed:
  1779 00001E21 E838FB              <1> 	call os_show_cursor
  1780                              <1> 
  1781 00001E24 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1782 00001E29 7510                <1> 	jne .no_store_position_on_exit
  1783                              <1> 	
  1784 00001E2B 8836[351C]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1785 00001E2F A0[251F]            <1> 	mov al, [.skip_num]
  1786 00001E32 A2[361C]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1787 00001E35 A0[241F]            <1> 	mov al, [.num_of_entries]
  1788 00001E38 A2[371C]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1789                              <1> 	
  1790                              <1> .no_store_position_on_exit:
  1791 00001E3B 61                  <1> 	popa
  1792 00001E3C F9                  <1> 	stc				; Set carry for Esc
  1793 00001E3D C3                  <1> 	ret
  1794                              <1> 
  1795                              <1> 
  1796                              <1> 
  1797                              <1> .draw_list:
  1798 00001E3E 60                  <1> 	pusha
  1799                              <1> 
  1800                              <1> 	mov16 dx, 5, 6		; Get into position for option list text
    18 00001E3F BA0506              <2>  mov %1, (%2 + %3 * 256)
  1801 00001E42 E8E2FA              <1> 	call os_move_cursor
  1802                              <1> 
  1803                              <1> 	clr cx				; Skip lines scrolled off the top of the dialog
    14 00001E45 31C9                <2>  xor %1, %1
  1804 00001E47 8A0E[251F]          <1> 	mov byte cl, [.skip_num]
  1805                              <1> 
  1806 00001E4B 803E[341C]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1807 00001E50 747C                <1> 	je .file_draw_list
  1808                              <1> 
  1809                              <1> .skip_loop:
  1810 00001E52 83F900              <1> 	cmp cx, 0
  1811 00001E55 740B                <1> 	je .skip_loop_finished
  1812                              <1> .more_lodsb:
  1813 00001E57 268A04              <1> 	mov al, [es:si]
  1814 00001E5A 46                  <1> 	inc si
  1815 00001E5B 3C2C                <1> 	cmp al, ','
  1816 00001E5D 75F8                <1> 	jne .more_lodsb
  1817 00001E5F 49                  <1> 	dec cx
  1818 00001E60 EBF0                <1> 	jmp .skip_loop
  1819                              <1> 
  1820                              <1> 
  1821                              <1> .skip_loop_finished:
  1822                              <1> 	clr bx				; Counter for total number of options
    14 00001E62 31DB                <2>  xor %1, %1
  1823                              <1> 
  1824                              <1> 
  1825                              <1> .more:
  1826 00001E64 268A04              <1> 	mov al, [es:si]		; Get next character in file name, increment pointer
  1827 00001E67 46                  <1> 	inc si
  1828                              <1> 	
  1829 00001E68 3C00                <1> 	cmp al, 0			; End of string?
  1830 00001E6A 7417                <1> 	je .done_list
  1831                              <1> 
  1832 00001E6C 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1833 00001E6E 7406                <1> 	je .newline
  1834                              <1> 
  1835 00001E70 B40E                <1> 	mov ah, 0Eh
  1836 00001E72 CD10                <1> 	int 10h
  1837 00001E74 EBEE                <1> 	jmp .more
  1838                              <1> 
  1839                              <1> .newline:
  1840 00001E76 B205                <1> 	mov dl, 5			; Go back to starting X position
  1841 00001E78 FEC6                <1> 	inc dh				; But jump down a line
  1842 00001E7A E8AAFA              <1> 	call os_move_cursor
  1843                              <1> 
  1844 00001E7D 43                  <1> 	inc bx				; Update the number-of-options counter
  1845 00001E7E 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1846 00001E81 7CE1                <1> 	jl .more
  1847                              <1> 
  1848                              <1> .done_list:
  1849 00001E83 61                  <1> 	popa
  1850                              <1> 
  1851 00001E84 60                  <1> 	pusha
  1852 00001E85 52                  <1> 	push dx
  1853                              <1> 	mov16 dx, 5, 22
    18 00001E86 BA0516              <2>  mov %1, (%2 + %3 * 256)
  1854 00001E89 E89BFA              <1> 	call os_move_cursor
  1855                              <1> 	
  1856 00001E8C BE[281F]            <1> 	mov si, .string1
  1857 00001E8F E824FA              <1> 	call os_print_string
  1858                              <1> 	
  1859 00001E92 5A                  <1> 	pop dx
  1860 00001E93 A0[251F]            <1> 	mov al, [.skip_num]
  1861 00001E96 00F0                <1> 	add al, dh
  1862 00001E98 2C05                <1> 	sub al, 5
  1863 00001E9A 0FB6C0              <1> 	movzx ax, al
  1864 00001E9D E8650D              <1> 	call os_int_to_string
  1865 00001EA0 89C6                <1> 	mov si, ax
  1866 00001EA2 E811FA              <1> 	call os_print_string
  1867                              <1> 	
  1868 00001EA5 BE[2A1F]            <1> 	mov si, .string2
  1869 00001EA8 E80BFA              <1> 	call os_print_string
  1870                              <1> 	
  1871 00001EAB 0FB606[241F]        <1> 	movzx ax, byte [.num_of_entries]
  1872 00001EB0 E8520D              <1> 	call os_int_to_string
  1873 00001EB3 89C6                <1> 	mov si, ax
  1874 00001EB5 E8FEF9              <1> 	call os_print_string
  1875                              <1> 	
  1876 00001EB8 BE[2C1F]            <1> 	mov si, .string3
  1877 00001EBB E8F8F9              <1> 	call os_print_string
  1878                              <1> 	
  1879                              <1> 	
  1880 00001EBE A0[251F]            <1> 	mov al, [.skip_num]
  1881 00001EC1 00F0                <1> 	add al, dh
  1882 00001EC3 2C05                <1> 	sub al, 5
  1883 00001EC5 0FB6C0              <1> 	movzx ax, al
  1884 00001EC8 FF16[301F]          <1> 	call [.callback]
  1885                              <1> 	
  1886 00001ECC 61                  <1> 	popa
  1887 00001ECD C3                  <1> 	ret
  1888                              <1> 
  1889                              <1> .file_draw_list:
  1890                              <1> 	clr bx
    14 00001ECE 31DB                <2>  xor %1, %1
  1891                              <1> 
  1892                              <1> .f_more:
  1893 00001ED0 51                  <1> 	push cx
  1894 00001ED1 89C8                <1> 	mov ax, cx
  1895 00001ED3 40                  <1> 	inc ax
  1896 00001ED4 E8A1FB              <1> 	call os_file_selector.get_filename
  1897 00001ED7 BE[091C]            <1> 	mov si, os_file_selector.filename
  1898 00001EDA E8D9F9              <1> 	call os_print_string
  1899 00001EDD 59                  <1> 	pop cx
  1900                              <1> 
  1901 00001EDE B205                <1> 	mov dl, 5			; Go back to starting X position
  1902 00001EE0 FEC6                <1> 	inc dh				; But jump down a line
  1903 00001EE2 E842FA              <1> 	call os_move_cursor
  1904                              <1> 
  1905 00001EE5 41                  <1> 	inc cx
  1906 00001EE6 3A0E[241F]          <1> 	cmp cl, [.num_of_entries]
  1907 00001EEA 7497                <1> 	je .done_list
  1908                              <1> 
  1909 00001EEC 43                  <1> 	inc bx				; Update the number-of-options counter
  1910 00001EED 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1911 00001EF0 7CDE                <1> 	jl .f_more
  1912 00001EF2 EB8F                <1> 	jmp .done_list
  1913                              <1> 
  1914                              <1> .draw_black_bar:
  1915 00001EF4 60                  <1> 	pusha
  1916                              <1> 
  1917 00001EF5 B204                <1> 	mov dl, 4
  1918 00001EF7 E82DFA              <1> 	call os_move_cursor
  1919                              <1> 
  1920                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    18 00001EFA B82009              <2>  mov %1, (%2 + %3 * 256)
  1921                              <1> 	mov16 bx, 00001111b, 0	; White text on black background
    18 00001EFD BB0F00              <2>  mov %1, (%2 + %3 * 256)
  1922 00001F00 8B0E8900            <1> 	mov cx, [0089h]
  1923 00001F04 83E904              <1> 	sub cx, byte 4
  1924 00001F07 CD10                <1> 	int 10h
  1925                              <1> 
  1926 00001F09 61                  <1> 	popa
  1927 00001F0A C3                  <1> 	ret
  1928                              <1> 
  1929                              <1> 
  1930                              <1> 
  1931                              <1> .draw_white_bar:
  1932 00001F0B 60                  <1> 	pusha
  1933                              <1> 
  1934 00001F0C B204                <1> 	mov dl, 4
  1935 00001F0E E816FA              <1> 	call os_move_cursor
  1936                              <1> 
  1937                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    18 00001F11 B82009              <2>  mov %1, (%2 + %3 * 256)
  1938                              <1> 	mov16 bx, 11110000b, 0	; White text on black background
    18 00001F14 BBF000              <2>  mov %1, (%2 + %3 * 256)
  1939 00001F17 8B0E8900            <1> 	mov cx, [0089h]
  1940 00001F1B 83E904              <1> 	sub cx, byte 4
  1941 00001F1E CD10                <1> 	int 10h
  1942                              <1> 
  1943 00001F20 61                  <1> 	popa
  1944 00001F21 C3                  <1> 	ret
  1945                              <1> 
  1946                              <1> 
  1947 00001F22 0000                <1> 	.tmp			dw 0
  1948 00001F24 00                  <1> 	.num_of_entries	db 0
  1949 00001F25 00                  <1> 	.skip_num		db 0
  1950 00001F26 0000                <1> 	.list_string	dw 0
  1951 00001F28 2800                <1> 	.string1		db '(', 0
  1952 00001F2A 2F00                <1> 	.string2		db '/', 0
  1953 00001F2C 29202000            <1> 	.string3		db ')  ', 0
  1954 00001F30 0000                <1> 	.callback		dw 0
  1955                              <1> 	
  1956                              <1> ; ------------------------------------------------------------------
  1957                              <1> ; os_draw_background -- Clear screen with white top and bottom bars
  1958                              <1> ; containing text, and a coloured middle section.
  1959                              <1> ; IN: AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
  1960                              <1> 
  1961                              <1> os_draw_background:
  1962 00001F32 60                  <1> 	pusha
  1963                              <1> 	
  1964 00001F33 50                  <1> 	push ax				; Store params to pop out later
  1965 00001F34 53                  <1> 	push bx
  1966 00001F35 51                  <1> 	push cx
  1967                              <1> 
  1968 00001F36 BA0000              <1> 	mov dx, 0
  1969 00001F39 E8EBF9              <1> 	call os_move_cursor
  1970                              <1> 
  1971 00001F3C B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1972 00001F3F B95000              <1> 	mov cx, 80
  1973 00001F42 BB7000              <1> 	mov bx, 01110000b
  1974 00001F45 CD10                <1> 	int 10h
  1975                              <1> 
  1976 00001F47 BA0001              <1> 	mov dx, 256
  1977 00001F4A E8DAF9              <1> 	call os_move_cursor
  1978                              <1> 	
  1979 00001F4D 5B                  <1> 	pop bx				; Get colour param (originally in CX)
  1980 00001F4E 81FB0001            <1> 	cmp bx, 256
  1981 00001F52 7469                <1> 	je .draw_default_background
  1982                              <1> 	
  1983 00001F54 B82009              <1> 	mov ax, 0920h			; Draw colour section
  1984 00001F57 B93007              <1> 	mov cx, 1840
  1985 00001F5A B700                <1> 	mov bh, 0
  1986 00001F5C CD10                <1> 	int 10h
  1987                              <1> 
  1988                              <1> .bg_drawn:
  1989                              <1> 	mov16 dx, 0, 24
    18 00001F5E BA0018              <2>  mov %1, (%2 + %3 * 256)
  1990 00001F61 E8C3F9              <1> 	call os_move_cursor
  1991                              <1> 
  1992 00001F64 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1993 00001F67 B95000              <1> 	mov cx, 80
  1994 00001F6A BB7000              <1> 	mov bx, 01110000b
  1995 00001F6D CD10                <1> 	int 10h
  1996                              <1> 
  1997                              <1> 	mov16 dx, 1, 24
    18 00001F6F BA0118              <2>  mov %1, (%2 + %3 * 256)
  1998 00001F72 E8B2F9              <1> 	call os_move_cursor
  1999 00001F75 5E                  <1> 	pop si				; Get bottom string param
  2000 00001F76 E83DF9              <1> 	call os_print_string
  2001                              <1> 
  2002 00001F79 BA0100              <1> 	mov dx, 1
  2003 00001F7C E8A8F9              <1> 	call os_move_cursor
  2004 00001F7F 5E                  <1> 	pop si				; Get top string param
  2005 00001F80 E833F9              <1> 	call os_print_string
  2006                              <1> 
  2007 00001F83 BB[F01F]            <1> 	mov bx, tmp_string
  2008 00001F86 E82B0D              <1> 	call os_get_date_string
  2009                              <1> 	
  2010 00001F89 BA4500              <1> 	mov dx, 69			; Display date
  2011 00001F8C E898F9              <1> 	call os_move_cursor
  2012 00001F8F 89DE                <1> 	mov si, bx
  2013 00001F91 E822F9              <1> 	call os_print_string
  2014                              <1> 	
  2015 00001F94 BB[F01F]            <1> 	mov bx, tmp_string
  2016 00001F97 E8D30C              <1> 	call os_get_time_string
  2017                              <1> 
  2018 00001F9A BA3F00              <1> 	mov dx, 63			; Display time
  2019 00001F9D E887F9              <1> 	call os_move_cursor
  2020 00001FA0 89DE                <1> 	mov si, bx
  2021 00001FA2 E811F9              <1> 	call os_print_string
  2022                              <1> 	
  2023 00001FA5 B24F                <1> 	mov dl, 79			; Print the little speaker icon
  2024 00001FA7 E87DF9              <1> 	call os_move_cursor
  2025                              <1> 	
  2026 00001FAA B8170E              <1> 	mov ax, 0E17h
  2027 00001FAD 2A068300            <1> 	sub al, [0083h]
  2028 00001FB1 B700                <1> 	mov bh, 0
  2029 00001FB3 CD10                <1> 	int 10h
  2030                              <1> 	
  2031                              <1> 	mov16 dx, 0, 1		; Ready for app text
    18 00001FB5 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2032 00001FB8 E86CF9              <1> 	call os_move_cursor
  2033                              <1> 
  2034 00001FBB 61                  <1> 	popa
  2035 00001FBC C3                  <1> 	ret
  2036                              <1> 
  2037                              <1> .draw_default_background:
  2038 00001FBD 64803E000600        <1> 	cmp byte [fs:DESKTOP_BACKGROUND], 0
  2039 00001FC3 741B                <1> 	je .fill_color
  2040                              <1> 	
  2041 00001FC5 1E                  <1> 	push ds
  2042 00001FC6 06                  <1> 	push es
  2043                              <1> 	
  2044 00001FC7 8E1E[9405]          <1> 	mov ds, [driversgmt]
  2045 00001FCB BE0006              <1> 	mov si, DESKTOP_BACKGROUND
  2046                              <1> 
  2047 00001FCE B800B8              <1> 	mov ax, 0B800h
  2048 00001FD1 8EC0                <1> 	mov es, ax
  2049 00001FD3 BFA000              <1> 	mov di, 160
  2050                              <1> 	
  2051 00001FD6 B9600E              <1> 	mov cx, 80 * 23 * 2
  2052                              <1> 	
  2053 00001FD9 F3A4                <1> 	rep movsb
  2054                              <1> 	
  2055 00001FDB 07                  <1> 	pop es
  2056 00001FDC 1F                  <1> 	pop ds
  2057 00001FDD E97EFF              <1> 	jmp .bg_drawn
  2058                              <1> 	
  2059                              <1> .fill_color:
  2060 00001FE0 0FB61EA8DE          <1> 	movzx bx, byte [57000]
  2061 00001FE5 B82009              <1> 	mov ax, 0920h
  2062 00001FE8 B93007              <1> 	mov cx, 1840
  2063                              <1> 
  2064 00001FEB CD10                <1> 	int 10h
  2065 00001FED E96EFF              <1> 	jmp .bg_drawn
  2066                              <1> 
  2067 00001FF0 00<rep Fh>          <1> 	tmp_string			times 15 db 0
  2068                              <1> 
  2069                              <1> 
  2070                              <1> ; ------------------------------------------------------------------
  2071                              <1> ; os_print_newline -- Reset cursor to start of next line
  2072                              <1> ; IN/OUT: Nothing (registers preserved)
  2073                              <1> 
  2074                              <1> os_print_newline:
  2075 00001FFF 60                  <1> 	pusha
  2076                              <1> 
  2077 00002000 B40E                <1> 	mov ah, 0Eh			; BIOS output char code
  2078                              <1> 
  2079 00002002 B00D                <1> 	mov al, 13
  2080 00002004 CD10                <1> 	int 10h
  2081 00002006 B00A                <1> 	mov al, 10
  2082 00002008 CD10                <1> 	int 10h
  2083                              <1> 
  2084 0000200A 61                  <1> 	popa
  2085 0000200B C3                  <1> 	ret
  2086                              <1> 
  2087                              <1> 
  2088                              <1> ; ------------------------------------------------------------------
  2089                              <1> ; os_dump_registers -- Displays register contents in hex on the screen
  2090                              <1> ; IN/OUT: EAX/EBX/ECX/EDX/ESI/EDI = registers to show
  2091                              <1> 
  2092                              <1> os_dump_registers:
  2093 0000200C 6660                <1> 	pushad
  2094                              <1> 
  2095 0000200E 6657                <1> 	push edi
  2096 00002010 68[5D20]            <1> 	push .di_string
  2097 00002013 6656                <1> 	push esi
  2098 00002015 68[5720]            <1> 	push .si_string
  2099 00002018 6652                <1> 	push edx
  2100 0000201A 68[5120]            <1> 	push .dx_string
  2101 0000201D 6651                <1> 	push ecx
  2102 0000201F 68[4B20]            <1> 	push .cx_string
  2103 00002022 6653                <1> 	push ebx
  2104 00002024 68[4520]            <1> 	push .bx_string
  2105 00002027 6650                <1> 	push eax
  2106 00002029 68[4020]            <1> 	push .ax_string
  2107                              <1> 	
  2108 0000202C B90600              <1> 	mov cx, 6
  2109                              <1> 	
  2110                              <1> .loop:
  2111 0000202F 5E                  <1> 	pop si
  2112 00002030 E883F8              <1> 	call os_print_string
  2113 00002033 6658                <1> 	pop eax
  2114 00002035 E8B903              <1> 	call os_print_8hex
  2115 00002038 E2F5                <1> 	loop .loop
  2116                              <1> 	
  2117 0000203A E8C2FF              <1> 	call os_print_newline
  2118                              <1> 
  2119 0000203D 6661                <1> 	popad
  2120 0000203F C3                  <1> 	ret
  2121                              <1> 
  2122                              <1> 
  2123 00002040 4541583A00          <1> 	.ax_string		db 'EAX:', 0
  2124 00002045 204542583A00        <1> 	.bx_string		db ' EBX:', 0
  2125 0000204B 204543583A00        <1> 	.cx_string		db ' ECX:', 0
  2126 00002051 204544583A00        <1> 	.dx_string		db ' EDX:', 0
  2127 00002057 204553493A00        <1> 	.si_string		db ' ESI:', 0
  2128 0000205D 204544493A00        <1> 	.di_string		db ' EDI:', 0
  2129                              <1> 
  2130                              <1> 
  2131                              <1> ; ------------------------------------------------------------------
  2132                              <1> ; os_input_dialog -- Get text string from user via a dialog box
  2133                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2134                              <1> 
  2135                              <1> os_input_dialog:
  2136 00002063 60                  <1> 	pusha
  2137                              <1> 
  2138 00002064 50                  <1> 	push ax				; Save string location
  2139 00002065 53                  <1> 	push bx				; Save message to show
  2140                              <1> 
  2141                              <1> 
  2142                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    18 00002066 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2143                              <1> 
  2144                              <1> .redbox:				; Loop to draw all lines of box
  2145 00002069 E8BBF8              <1> 	call os_move_cursor
  2146                              <1> 
  2147 0000206C 60                  <1> 	pusha
  2148                              <1> 	mov16 ax, ' ', 09h
    18 0000206D B82009              <2>  mov %1, (%2 + %3 * 256)
  2149 00002070 B93700              <1> 	mov cx, 55
  2150 00002073 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2151 00002078 CD10                <1> 	int 10h
  2152 0000207A 61                  <1> 	popa
  2153                              <1> 
  2154 0000207B FEC6                <1> 	inc dh
  2155 0000207D 80FE10              <1> 	cmp dh, 16
  2156 00002080 7402                <1> 	je .boxdone
  2157 00002082 EBE5                <1> 	jmp .redbox
  2158                              <1> 
  2159                              <1> 
  2160                              <1> .boxdone:
  2161                              <1> 	mov16 dx, 14, 14
    18 00002084 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2162 00002087 E89DF8              <1> 	call os_move_cursor
  2163                              <1> 
  2164                              <1> 	mov16 ax, ' ', 09h
    18 0000208A B82009              <2>  mov %1, (%2 + %3 * 256)
  2165 0000208D BBF000              <1> 	mov bx, 240
  2166 00002090 B93300              <1> 	mov cx, 51
  2167 00002093 CD10                <1> 	int 10h
  2168                              <1> 	
  2169                              <1> 	mov16 dx, 14, 11
    18 00002095 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2170 00002098 E88CF8              <1> 	call os_move_cursor
  2171                              <1> 	
  2172                              <1> 
  2173 0000209B 5B                  <1> 	pop bx				; Get message back and display it
  2174 0000209C 89DE                <1> 	mov si, bx
  2175 0000209E E815F8              <1> 	call os_print_string
  2176                              <1> 
  2177                              <1> 	mov16 dx, 14, 14
    18 000020A1 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2178 000020A4 E880F8              <1> 	call os_move_cursor
  2179                              <1> 
  2180                              <1> 
  2181 000020A7 58                  <1> 	pop ax				; Get input string back
  2182 000020A8 E8C301              <1> 	call os_input_string
  2183                              <1> 
  2184 000020AB 61                  <1> 	popa
  2185 000020AC C3                  <1> 	ret
  2186                              <1> 
  2187                              <1> ; ------------------------------------------------------------------
  2188                              <1> ; os_password_dialog -- Get a password from user via a dialog box
  2189                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2190                              <1> 
  2191                              <1> os_password_dialog:
  2192 000020AD 60                  <1> 	pusha
  2193                              <1> 
  2194 000020AE 50                  <1> 	push ax				; Save string location
  2195 000020AF 53                  <1> 	push bx				; Save message to show
  2196                              <1> 
  2197                              <1> 
  2198                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    18 000020B0 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2199                              <1> 
  2200                              <1> .redbox:				; Loop to draw all lines of box
  2201 000020B3 E871F8              <1> 	call os_move_cursor
  2202                              <1> 
  2203 000020B6 60                  <1> 	pusha
  2204                              <1> 	mov16 ax, ' ', 09h
    18 000020B7 B82009              <2>  mov %1, (%2 + %3 * 256)
  2205 000020BA B93700              <1> 	mov cx, 55
  2206 000020BD 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2207 000020C2 CD10                <1> 	int 10h
  2208 000020C4 61                  <1> 	popa
  2209                              <1> 
  2210 000020C5 FEC6                <1> 	inc dh
  2211 000020C7 80FE10              <1> 	cmp dh, 16
  2212 000020CA 7402                <1> 	je .boxdone
  2213 000020CC EBE5                <1> 	jmp .redbox
  2214                              <1> 
  2215                              <1> 
  2216                              <1> .boxdone:
  2217                              <1> 	mov16 dx, 14, 14
    18 000020CE BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2218 000020D1 E853F8              <1> 	call os_move_cursor
  2219                              <1> 
  2220                              <1> 	mov16 ax, ' ', 09h
    18 000020D4 B82009              <2>  mov %1, (%2 + %3 * 256)
  2221 000020D7 BBF000              <1> 	mov bx, 240
  2222 000020DA B93300              <1> 	mov cx, 51
  2223 000020DD CD10                <1> 	int 10h
  2224                              <1> 	
  2225                              <1> 	mov16 dx, 14, 11
    18 000020DF BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2226 000020E2 E842F8              <1> 	call os_move_cursor
  2227                              <1> 	
  2228                              <1> 
  2229 000020E5 5B                  <1> 	pop bx				; Get message back and display it
  2230 000020E6 89DE                <1> 	mov si, bx
  2231 000020E8 E8CBF7              <1> 	call os_print_string
  2232                              <1> 
  2233                              <1> 	mov16 dx, 14, 14
    18 000020EB BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2234 000020EE E836F8              <1> 	call os_move_cursor
  2235                              <1> 
  2236                              <1> 
  2237 000020F1 58                  <1> 	pop ax				; Get input string back
  2238 000020F2 B3F0                <1> 	mov bl, 240
  2239 000020F4 E8E101              <1> 	call os_input_password
  2240                              <1> 
  2241 000020F7 61                  <1> 	popa
  2242 000020F8 C3                  <1> 	ret
  2243                              <1> 
  2244                              <1> 
  2245                              <1> ; ------------------------------------------------------------------
  2246                              <1> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
  2247                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display),
  2248                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
  2249                              <1> ; IN: [0085h] = Default button for 2-button dialog (0 or 1)
  2250                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
  2251                              <1> ; NOTE: Each string is limited to 40 characters
  2252                              <1> 
  2253                              <1> os_dialog_box:
  2254 000020F9 60                  <1> 	pusha
  2255                              <1> 
  2256 000020FA 52                  <1> 	push dx
  2257                              <1> 
  2258 000020FB 51                  <1> 	push cx
  2259 000020FC 53                  <1> 	push bx
  2260 000020FD 50                  <1> 	push ax
  2261                              <1> 	
  2262 000020FE E866F8              <1> 	call os_hide_cursor
  2263                              <1> 
  2264 00002101 60                  <1> 	pusha
  2265 00002102 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  2266                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    18 00002106 BA1309              <2>  mov %1, (%2 + %3 * 256)
  2267 00002109 BE2A00              <1> 	mov si, 42
  2268 0000210C BF1000              <1> 	mov di, 16
  2269 0000210F E85FF8              <1> 	call os_draw_block
  2270 00002112 61                  <1> 	popa
  2271                              <1> 	
  2272                              <1> 	mov16 dx, 20, 9
    18 00002113 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2273 00002116 B90300              <1> 	mov cx, 3
  2274                              <1> 	
  2275                              <1> .loop:
  2276 00002119 FEC6                <1> 	inc dh
  2277 0000211B E809F8              <1> 	call os_move_cursor
  2278                              <1> 	
  2279 0000211E 5E                  <1> 	pop si
  2280 0000211F 83FE00              <1> 	cmp si, 0
  2281 00002122 7403                <1> 	je .no_string
  2282                              <1> 	
  2283 00002124 E88FF7              <1> 	call os_print_string
  2284                              <1> 	
  2285                              <1> .no_string:
  2286 00002127 E2F0                <1> 	loop .loop
  2287                              <1> 	
  2288 00002129 5A                  <1> 	pop dx
  2289 0000212A 83FA01              <1> 	cmp dx, 1
  2290 0000212D 7426                <1> 	je .two_button
  2291                              <1> 
  2292                              <1> 	
  2293                              <1> .one_button:
  2294 0000212F B3F0                <1> 	mov bl, 11110000b		; Black on white
  2295                              <1> 	mov16 dx, 35, 14
    18 00002131 BA230E              <2>  mov %1, (%2 + %3 * 256)
  2296 00002134 BE0800              <1> 	mov si, 8
  2297 00002137 BF0F00              <1> 	mov di, 15
  2298 0000213A E834F8              <1> 	call os_draw_block
  2299                              <1> 
  2300                              <1> 	mov16 dx, 38, 14		; OK button, centred at bottom of box
    18 0000213D BA260E              <2>  mov %1, (%2 + %3 * 256)
  2301 00002140 E8E4F7              <1> 	call os_move_cursor
  2302 00002143 BE[2422]            <1> 	mov si, .ok_button_string
  2303 00002146 E86DF7              <1> 	call os_print_string
  2304                              <1> 
  2305                              <1> .one_button_wait:
  2306 00002149 E8EBF1              <1> 	call os_wait_for_key
  2307 0000214C 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2308 0000214E 75F9                <1> 	jne .one_button_wait
  2309                              <1> 
  2310 00002150 E809F8              <1> 	call os_show_cursor
  2311                              <1> 
  2312 00002153 61                  <1> 	popa
  2313 00002154 C3                  <1> 	ret
  2314                              <1> 
  2315                              <1> .two_button:
  2316 00002155 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2317                              <1> 	mov16 dx, 27, 14
    18 00002157 BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2318 0000215A BE0800              <1> 	mov si, 8
  2319 0000215D BF0F00              <1> 	mov di, 15
  2320 00002160 E80EF8              <1> 	call os_draw_block
  2321                              <1> 
  2322                              <1> 	mov16 dx, 30, 14			; OK button
    18 00002163 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2323 00002166 E8BEF7              <1> 	call os_move_cursor
  2324 00002169 BE[2422]            <1> 	mov si, .ok_button_string
  2325 0000216C E847F7              <1> 	call os_print_string
  2326                              <1> 
  2327                              <1> 	mov16 dx, 44, 14			; Cancel button
    18 0000216F BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2328 00002172 E8B2F7              <1> 	call os_move_cursor
  2329 00002175 BE[2722]            <1> 	mov si, .cancel_button_string
  2330 00002178 E83BF7              <1> 	call os_print_string
  2331                              <1> 
  2332 0000217B 803E850001          <1> 	cmp byte [0085h], 1
  2333 00002180 7466                <1> 	je .draw_right
  2334 00002182 7529                <1> 	jne .draw_left
  2335                              <1> 	
  2336                              <1> .two_button_wait:
  2337 00002184 E8B0F1              <1> 	call os_wait_for_key
  2338                              <1> 
  2339 00002187 80FC4B              <1> 	cmp ah, 75			; Left cursor key pressed?
  2340 0000218A 7421                <1> 	je .draw_left
  2341 0000218C 80FC4D              <1> 	cmp ah, 77			; Right cursor key pressed?
  2342 0000218F 7457                <1> 	je .draw_right
  2343                              <1> 	
  2344 00002191 3C1B                <1> 	cmp al, 27			; Escape, automatically select "Cancel"
  2345 00002193 7410                <1> 	je .cancel
  2346 00002195 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2347 00002197 75EB                <1> 	jne .two_button_wait
  2348                              <1> 	
  2349 00002199 E8C0F7              <1> 	call os_show_cursor
  2350                              <1> 
  2351 0000219C 890E[2E22]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
  2352 000021A0 61                  <1> 	popa
  2353 000021A1 A1[2E22]            <1> 	mov ax, [.tmp]
  2354                              <1> 
  2355 000021A4 C3                  <1> 	ret
  2356                              <1> 
  2357                              <1> .cancel:
  2358 000021A5 E8B4F7              <1> 	call os_show_cursor
  2359 000021A8 61                  <1> 	popa
  2360 000021A9 B80100              <1> 	mov ax, 1
  2361 000021AC C3                  <1> 	ret
  2362                              <1> 
  2363                              <1> .draw_left:
  2364 000021AD B3F0                <1> 	mov bl, 11110000b		; Black on white
  2365                              <1> 	mov16 dx, 27, 14
    18 000021AF BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2366 000021B2 BE0800              <1> 	mov si, 8
  2367 000021B5 BF0F00              <1> 	mov di, 15
  2368 000021B8 E8B6F7              <1> 	call os_draw_block
  2369                              <1> 
  2370                              <1> 	mov16 dx, 30, 14		; OK button
    18 000021BB BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2371 000021BE E866F7              <1> 	call os_move_cursor
  2372 000021C1 BE[2422]            <1> 	mov si, .ok_button_string
  2373 000021C4 E8EFF6              <1> 	call os_print_string
  2374                              <1> 
  2375 000021C7 8A1EA9DE            <1> 	mov bl, [57001]
  2376                              <1> 	mov16 dx, 42, 14
    18 000021CB BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  2377 000021CE BE0900              <1> 	mov si, 9
  2378 000021D1 BF0F00              <1> 	mov di, 15
  2379 000021D4 E89AF7              <1> 	call os_draw_block
  2380                              <1> 
  2381                              <1> 	mov16 dx, 44, 14		; Cancel button
    18 000021D7 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2382 000021DA E84AF7              <1> 	call os_move_cursor
  2383 000021DD BE[2722]            <1> 	mov si, .cancel_button_string
  2384 000021E0 E8D3F6              <1> 	call os_print_string
  2385                              <1> 
  2386 000021E3 B90000              <1> 	mov cx, 0			; And update result we'll return
  2387 000021E6 EB9C                <1> 	jmp .two_button_wait
  2388                              <1> 
  2389                              <1> .draw_right:
  2390 000021E8 8A1EA9DE            <1> 	mov bl, [57001]
  2391                              <1> 	mov16 dx, 27, 14
    18 000021EC BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2392 000021EF BE0800              <1> 	mov si, 8
  2393 000021F2 BF0F00              <1> 	mov di, 15
  2394 000021F5 E879F7              <1> 	call os_draw_block
  2395                              <1> 
  2396                              <1> 	mov16 dx, 30, 14			; OK button
    18 000021F8 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2397 000021FB E829F7              <1> 	call os_move_cursor
  2398 000021FE BE[2422]            <1> 	mov si, .ok_button_string
  2399 00002201 E8B2F6              <1> 	call os_print_string
  2400                              <1> 
  2401 00002204 B3F0                <1> 	mov bl, 11110000b
  2402                              <1> 	mov16 dx, 43, 14
    18 00002206 BA2B0E              <2>  mov %1, (%2 + %3 * 256)
  2403 00002209 BE0800              <1> 	mov si, 8
  2404 0000220C BF0F00              <1> 	mov di, 15
  2405 0000220F E85FF7              <1> 	call os_draw_block
  2406                              <1> 
  2407                              <1> 	mov16 dx, 44, 14			; Cancel button
    18 00002212 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2408 00002215 E80FF7              <1> 	call os_move_cursor
  2409 00002218 BE[2722]            <1> 	mov si, .cancel_button_string
  2410 0000221B E898F6              <1> 	call os_print_string
  2411                              <1> 
  2412 0000221E B90100              <1> 	mov cx, 1			; And update result we'll return
  2413 00002221 E960FF              <1> 	jmp .two_button_wait
  2414                              <1> 
  2415                              <1> 
  2416                              <1> 
  2417 00002224 4F4B00              <1> 	.ok_button_string	db 'OK', 0
  2418 00002227 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
  2419                              <1> 
  2420 0000222E 0000                <1> 	.tmp dw 0
  2421                              <1> 
  2422                              <1> ; ------------------------------------------------------------------
  2423                              <1> ; os_print_space -- Print a space to the screen
  2424                              <1> ; IN/OUT: Nothing
  2425                              <1> 
  2426                              <1> os_print_space:
  2427 00002230 60                  <1> 	pusha
  2428                              <1> 
  2429 00002231 B8200E              <1> 	mov ax, 0E20h			; BIOS teletype function
  2430 00002234 CD10                <1> 	int 10h
  2431                              <1> 
  2432 00002236 61                  <1> 	popa
  2433 00002237 C3                  <1> 	ret
  2434                              <1> 
  2435                              <1> 
  2436                              <1> ; ------------------------------------------------------------------
  2437                              <1> ; os_print_digit -- Displays contents of AX as a single digit
  2438                              <1> ; Works up to base 37, ie digits 0-Z
  2439                              <1> ; IN: AX = "digit" to format and print
  2440                              <1> 
  2441                              <1> os_print_digit:
  2442 00002238 60                  <1> 	pusha
  2443                              <1> 
  2444 00002239 83F809              <1> 	cmp ax, 9			; There is a break in ASCII table between 9 and A
  2445 0000223C 7E03                <1> 	jle .digit_format
  2446                              <1> 
  2447 0000223E 83C007              <1> 	add ax, 'A'-'9'-1		; Correct for the skipped punctuation
  2448                              <1> 
  2449                              <1> .digit_format:
  2450 00002241 83C030              <1> 	add ax, '0'			; 0 will display as '0', etc.	
  2451                              <1> 
  2452 00002244 B40E                <1> 	mov ah, 0Eh			; May modify other registers
  2453 00002246 CD10                <1> 	int 10h
  2454                              <1> 
  2455 00002248 61                  <1> 	popa
  2456 00002249 C3                  <1> 	ret
  2457                              <1> 
  2458                              <1> 
  2459                              <1> ; ------------------------------------------------------------------
  2460                              <1> ; os_print_1hex -- Displays low nibble of AL in hex format
  2461                              <1> ; IN: AL = number to format and print
  2462                              <1> 
  2463                              <1> os_print_1hex:
  2464 0000224A 60                  <1> 	pusha
  2465                              <1> 
  2466 0000224B 83E00F              <1> 	and ax, 0Fh			; Mask off data to display
  2467 0000224E E8E7FF              <1> 	call os_print_digit
  2468                              <1> 
  2469 00002251 61                  <1> 	popa
  2470 00002252 C3                  <1> 	ret
  2471                              <1> 
  2472                              <1> 
  2473                              <1> ; ------------------------------------------------------------------
  2474                              <1> ; os_print_2hex -- Displays AL in hex format
  2475                              <1> ; IN: AL = number to format and print
  2476                              <1> 
  2477                              <1> os_print_2hex:
  2478 00002253 60                  <1> 	pusha
  2479                              <1> 
  2480 00002254 50                  <1> 	push ax				; Output high nibble
  2481 00002255 C1E804              <1> 	shr ax, 4
  2482 00002258 E8EFFF              <1> 	call os_print_1hex
  2483                              <1> 
  2484 0000225B 58                  <1> 	pop ax				; Output low nibble
  2485 0000225C E8EBFF              <1> 	call os_print_1hex
  2486                              <1> 
  2487 0000225F 61                  <1> 	popa
  2488 00002260 C3                  <1> 	ret
  2489                              <1> 
  2490                              <1> 
  2491                              <1> ; ------------------------------------------------------------------
  2492                              <1> ; os_print_4hex -- Displays AX in hex format
  2493                              <1> ; IN: AX = number to format and print
  2494                              <1> 
  2495                              <1> os_print_4hex:
  2496 00002261 60                  <1> 	pusha
  2497                              <1> 
  2498 00002262 50                  <1> 	push ax				; Output high byte
  2499 00002263 88E0                <1> 	mov al, ah
  2500 00002265 E8EBFF              <1> 	call os_print_2hex
  2501                              <1> 
  2502 00002268 58                  <1> 	pop ax				; Output low byte
  2503 00002269 E8E7FF              <1> 	call os_print_2hex
  2504                              <1> 
  2505 0000226C 61                  <1> 	popa
  2506 0000226D C3                  <1> 	ret
  2507                              <1> 
  2508                              <1> 
  2509                              <1> ; ------------------------------------------------------------------
  2510                              <1> ; os_input_string -- Take string from keyboard entry
  2511                              <1> ; IN/OUT: AX = location of string, other regs preserved
  2512                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2513                              <1> 
  2514                              <1> os_input_string:
  2515 0000226E 60                  <1> 	pusha
  2516                              <1> 
  2517 0000226F E8EAF6              <1> 	call os_show_cursor
  2518                              <1> 	
  2519 00002272 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2520 00002274 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2521                              <1> 
  2522                              <1> 
  2523                              <1> .more:					; Now onto string getting
  2524 00002277 E8BDF0              <1> 	call os_wait_for_key
  2525                              <1> 
  2526 0000227A 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2527 0000227C 7455                <1> 	je .done
  2528                              <1> 
  2529 0000227E 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2530 00002280 7406                <1> 	je .backspace			; If not, skip following checks
  2531                              <1> 
  2532 00002282 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 127)?
  2533 00002284 7CF1                <1> 	jl .more			; Ignore most non-printing characters
  2534                              <1> 
  2535 00002286 EB35                <1> 	jmp .nobackspace
  2536                              <1> 
  2537                              <1> 
  2538                              <1> .backspace:
  2539 00002288 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2540 0000228B 74EA                <1> 	je .more			; Ignore it if so
  2541                              <1> 
  2542 0000228D E8A0F6              <1> 	call os_get_cursor_pos		; Backspace at start of screen line?
  2543 00002290 80FA00              <1> 	cmp dl, 0
  2544 00002293 7413                <1> 	je .backspace_linestart
  2545                              <1> 
  2546 00002295 60                  <1> 	pusha
  2547 00002296 B8080E              <1> 	mov ax, 0E08h		; If not, write space and move cursor back
  2548 00002299 CD10                <1> 	int 10h				; Backspace twice, to clear space
  2549 0000229B B020                <1> 	mov al, 32
  2550 0000229D CD10                <1> 	int 10h
  2551 0000229F B008                <1> 	mov al, 8
  2552 000022A1 CD10                <1> 	int 10h
  2553 000022A3 61                  <1> 	popa
  2554                              <1> 
  2555 000022A4 4F                  <1> 	dec di				; Character position will be overwritten by new
  2556                              <1> 						; character or terminator at end
  2557                              <1> 
  2558 000022A5 49                  <1> 	dec cx				; Step back counter
  2559                              <1> 
  2560 000022A6 EBCF                <1> 	jmp .more
  2561                              <1> 
  2562                              <1> 
  2563                              <1> .backspace_linestart:
  2564 000022A8 FECE                <1> 	dec dh				; Jump back to end of previous line
  2565 000022AA B24F                <1> 	mov dl, 79
  2566 000022AC E878F6              <1> 	call os_move_cursor
  2567                              <1> 
  2568 000022AF B8200E              <1> 	mov ax, 0E20h		; Print space there
  2569 000022B2 CD10                <1> 	int 10h
  2570                              <1> 
  2571 000022B4 B24F                <1> 	mov dl, 79			; And jump back before the space
  2572 000022B6 E86EF6              <1> 	call os_move_cursor
  2573                              <1> 
  2574 000022B9 4F                  <1> 	dec di				; Step back position in string
  2575 000022BA 49                  <1> 	dec cx				; Step back counter
  2576                              <1> 
  2577 000022BB EBBA                <1> 	jmp .more
  2578                              <1> 
  2579                              <1> 
  2580                              <1> .nobackspace:
  2581 000022BD 0FB61E8800          <1> 	movzx bx, byte [0088h]
  2582 000022C2 39D9                <1> 	cmp cx, bx			; Make sure we don't exhaust buffer
  2583 000022C4 0F8DAFFF            <1> 	jge near .more
  2584                              <1> 
  2585 000022C8 60                  <1> 	pusha
  2586 000022C9 B40E                <1> 	mov ah, 0Eh			; Output entered, printable character
  2587 000022CB CD10                <1> 	int 10h
  2588 000022CD 61                  <1> 	popa
  2589                              <1> 
  2590 000022CE AA                  <1> 	stosb				; Store character in designated buffer
  2591 000022CF 41                  <1> 	inc cx				; Characters processed += 1
  2592                              <1> 	
  2593 000022D0 E9A4FF              <1> 	jmp near .more			; Still room for more
  2594                              <1> 
  2595                              <1> .done:
  2596 000022D3 B000                <1> 	mov al, 0
  2597 000022D5 AA                  <1> 	stosb
  2598                              <1> 
  2599 000022D6 61                  <1> 	popa
  2600 000022D7 C3                  <1> 	ret
  2601                              <1> 
  2602                              <1> ; Input password(displays it as *s)
  2603                              <1> ; IN: AX = location of string, other regs preserved, BL = color
  2604                              <1> ; OUT: nothing
  2605                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2606                              <1> 
  2607                              <1> os_input_password:
  2608 000022D8 60                  <1> 	pusha
  2609                              <1> 
  2610 000022D9 E854F6              <1> 	call os_get_cursor_pos	; Store the cursor position
  2611 000022DC 8916[4923]          <1> 	mov [.cursor], dx
  2612                              <1> 	
  2613 000022E0 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2614 000022E2 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2615                              <1> 
  2616                              <1> .more:					; Now onto string getting
  2617 000022E5 E84FF0              <1> 	call os_wait_for_key
  2618                              <1> 
  2619 000022E8 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2620 000022EA 742E                <1> 	je .done
  2621                              <1> 
  2622 000022EC 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2623 000022EE 740A                <1> 	je .backspace			; If not, skip following checks
  2624                              <1> 
  2625 000022F0 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 126)?
  2626 000022F2 7D13                <1> 	jge .nobackspace	; Ignore most non-printing characters
  2627                              <1> 	
  2628 000022F4 3C00                <1> 	cmp al, 0
  2629 000022F6 7C0F                <1> 	jl .nobackspace
  2630                              <1> 	
  2631 000022F8 EBEB                <1> 	jmp .more
  2632                              <1> 
  2633                              <1> 
  2634                              <1> .backspace:
  2635 000022FA 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2636 000022FD 74E6                <1> 	je .more			; Ignore it if so
  2637                              <1> 
  2638 000022FF 4F                  <1> 	dec di				; Character position will be overwritten by new
  2639                              <1> 						; character or terminator at end
  2640                              <1> 
  2641 00002300 49                  <1> 	dec cx				; Step back counter
  2642                              <1> 
  2643 00002301 E81C00              <1> 	call .update
  2644                              <1> 	
  2645 00002304 E9DEFF              <1> 	jmp near .more
  2646                              <1> 
  2647                              <1> 
  2648                              <1> .nobackspace:
  2649 00002307 0FB6168800          <1> 	movzx dx, byte [0088h]
  2650 0000230C 39D1                <1> 	cmp cx, dx			; Make sure we don't exhaust buffer
  2651 0000230E 0F8DD3FF            <1> 	jge near .more
  2652                              <1> 
  2653 00002312 AA                  <1> 	stosb				; Store character in designated buffer
  2654 00002313 41                  <1> 	inc cx				; Characters processed += 1
  2655                              <1> 
  2656 00002314 E80900              <1> 	call .update
  2657                              <1> 	
  2658 00002317 E9CBFF              <1> 	jmp near .more		; Still room for more
  2659                              <1> 
  2660                              <1> .done:
  2661 0000231A B000                <1> 	mov al, 0
  2662 0000231C AA                  <1> 	stosb
  2663                              <1> 
  2664 0000231D 61                  <1> 	popa
  2665 0000231E F8                  <1> 	clc
  2666 0000231F C3                  <1> 	ret
  2667                              <1> 
  2668                              <1> .update:
  2669 00002320 60                  <1> 	pusha
  2670 00002321 8B16[4923]          <1> 	mov dx, [.cursor]
  2671 00002325 E8FFF5              <1> 	call os_move_cursor
  2672 00002328 B82009              <1> 	mov ax, 0920h		; Clear the line
  2673 0000232B B700                <1> 	mov bh, 0
  2674 0000232D B92000              <1> 	mov cx, 32
  2675 00002330 CD10                <1> 	int 10h
  2676 00002332 61                  <1> 	popa
  2677                              <1> 
  2678 00002333 60                  <1> 	pusha
  2679 00002334 8B16[4923]          <1> 	mov dx, [.cursor]
  2680 00002338 E8ECF5              <1> 	call os_move_cursor
  2681 0000233B B82A09              <1> 	mov ax, 092Ah		; Print *s(amount in CX)
  2682 0000233E B700                <1> 	mov bh, 0
  2683 00002340 CD10                <1> 	int 10h
  2684 00002342 00CA                <1> 	add dl, cl
  2685 00002344 E8E0F5              <1> 	call os_move_cursor
  2686 00002347 61                  <1> 	popa
  2687 00002348 C3                  <1> 	ret
  2688                              <1> 	
  2689 00002349 0000                <1> 	.cursor			dw 0
  2690                              <1> 	
  2691                              <1> ; Opens up os_list_dialog with color.
  2692                              <1> ; IN: nothing
  2693                              <1> ; OUT: color number(0-15)
  2694                              <1> 
  2695                              <1> os_color_selector:
  2696 0000234B 60                  <1> 	pusha
  2697 0000234C B8[6123]            <1> 	mov ax, .colorlist			; Call os_list_dialog with colors
  2698 0000234F BB[DC23]            <1> 	mov bx, .colormsg0
  2699 00002352 B9[EE23]            <1> 	mov cx, .colormsg1
  2700 00002355 E81DF9              <1> 	call os_list_dialog
  2701                              <1> 	
  2702 00002358 48                  <1> 	dec ax						; Output from os_list_dialog starts with 1, so decrement it
  2703 00002359 A3[EF23]            <1> 	mov [.tmp_word], ax
  2704 0000235C 61                  <1> 	popa
  2705 0000235D A0[EF23]            <1> 	mov al, [.tmp_word]
  2706 00002360 C3                  <1> 	ret
  2707                              <1> 	
  2708 00002361 426C61636B2C426C75- <1> 	.colorlist	db 'Black,Blue,Green,Cyan,Red,Magenta,Brown,Light Gray,Dark Gray,Light Blue,Light Green,Light Cyan,Light Red,Pink,Yellow,White', 0
  2708 0000236A 652C477265656E2C43- <1>
  2708 00002373 79616E2C5265642C4D- <1>
  2708 0000237C 6167656E74612C4272- <1>
  2708 00002385 6F776E2C4C69676874- <1>
  2708 0000238E 20477261792C446172- <1>
  2708 00002397 6B20477261792C4C69- <1>
  2708 000023A0 67687420426C75652C- <1>
  2708 000023A9 4C6967687420477265- <1>
  2708 000023B2 656E2C4C6967687420- <1>
  2708 000023BB 4379616E2C4C696768- <1>
  2708 000023C4 74205265642C50696E- <1>
  2708 000023CD 6B2C59656C6C6F772C- <1>
  2708 000023D6 576869746500        <1>
  2709 000023DC 43686F6F7365206120- <1> 	.colormsg0	db 'Choose a color...', 0
  2709 000023E5 636F6C6F722E2E2E00  <1>
  2710 000023EE 00                  <1> 	.colormsg1	db 0
  2711 000023EF 0000                <1> 	.tmp_word	dw 0
  2712                              <1> 	
  2713                              <1> ; Displays EAX in hex format
  2714                              <1> ; IN: EAX = unsigned integer
  2715                              <1> ; OUT: nothing
  2716                              <1> os_print_8hex:
  2717 000023F1 6660                <1> 	pushad
  2718 000023F3 6660                <1> 	pushad
  2719 000023F5 66C1E810            <1> 	shr eax, 16
  2720 000023F9 E865FE              <1> 	call os_print_4hex
  2721 000023FC 6661                <1> 	popad
  2722 000023FE E860FE              <1> 	call os_print_4hex
  2723 00002401 6661                <1> 	popad
  2724 00002403 C3                  <1> 	ret
  2725                              <1> 	
  2726                              <1> ; Displays a dialog similar to os_dialog_box, but without the buttons.
  2727                              <1> ; IN: SI/AX/BX/CX/DX = string locations (or 0 for no display)
  2728                              <1> ; OUT: nothing
  2729                              <1> os_temp_box:
  2730 00002404 60                  <1> 	pusha
  2731                              <1> 
  2732 00002405 52                  <1> 	push dx
  2733 00002406 51                  <1> 	push cx
  2734 00002407 53                  <1> 	push bx
  2735 00002408 50                  <1> 	push ax
  2736 00002409 56                  <1> 	push si
  2737                              <1> 	
  2738 0000240A E85AF5              <1> 	call os_hide_cursor
  2739                              <1> 
  2740                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    18 0000240D BA1309              <2>  mov %1, (%2 + %3 * 256)
  2741                              <1> 
  2742                              <1> .redbox:				; Loop to draw all lines of box
  2743 00002410 E814F5              <1> 	call os_move_cursor
  2744                              <1> 
  2745 00002413 60                  <1> 	pusha
  2746 00002414 B82009              <1> 	mov ax, 0920h
  2747 00002417 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2748 0000241C B92A00              <1> 	mov cx, 42
  2749 0000241F CD10                <1> 	int 10h
  2750 00002421 61                  <1> 	popa
  2751                              <1> 
  2752 00002422 FEC6                <1> 	inc dh
  2753 00002424 80FE10              <1> 	cmp dh, 16
  2754 00002427 7402                <1> 	je .boxdone
  2755 00002429 EBE5                <1> 	jmp .redbox
  2756                              <1> 
  2757                              <1> 
  2758                              <1> .boxdone:
  2759                              <1> 	mov16 dx, 20, 9
    18 0000242B BA1409              <2>  mov %1, (%2 + %3 * 256)
  2760 0000242E B90500              <1> 	mov cx, 5
  2761                              <1> 
  2762                              <1> .loop:
  2763 00002431 FEC6                <1> 	inc dh
  2764 00002433 E8F1F4              <1> 	call os_move_cursor
  2765                              <1> 
  2766 00002436 5E                  <1> 	pop si
  2767 00002437 83FE00              <1> 	cmp si, 0			; Skip string params if zero
  2768 0000243A 7403                <1> 	je .no_string
  2769                              <1> 
  2770 0000243C E877F4              <1> 	call os_print_string
  2771                              <1> 
  2772                              <1> .no_string:
  2773 0000243F E2F0                <1> 	loop .loop
  2774 00002441 61                  <1> 	popa
  2775 00002442 C3                  <1> 	ret
  2776                              <1> 
  2777                              <1> ; Prints a message on the footer.
  2778                              <1> ; IN: SI = Message location(if 0, then it restores the previous message)
  2779                              <1> ; OUT: nothing
  2780                              <1> os_print_footer:
  2781 00002443 60                  <1> 	pusha
  2782 00002444 A08200              <1> 	mov al, [0082h]
  2783 00002447 3C01                <1> 	cmp al, 1
  2784 00002449 0F844700            <1> 	je near .exit
  2785                              <1> 	
  2786 0000244D E8E0F4              <1> 	call os_get_cursor_pos
  2787 00002450 52                  <1> 	push dx
  2788                              <1> 	
  2789 00002451 BF0100              <1> 	mov di, 1
  2790 00002454 83FE00              <1> 	cmp si, 0
  2791 00002457 0F843B00            <1> 	je near .restore
  2792                              <1> 	
  2793                              <1> 	mov16 dx, 0, 24
    18 0000245B BA0018              <2>  mov %1, (%2 + %3 * 256)
  2794                              <1> 	
  2795                              <1> .loop:
  2796 0000245E E8C6F4              <1> 	call os_move_cursor
  2797                              <1> 	
  2798 00002461 B408                <1> 	mov ah, 08h
  2799 00002463 B700                <1> 	mov bh, 0
  2800 00002465 CD10                <1> 	int 10h
  2801                              <1> 	
  2802 00002467 AA                  <1> 	stosb
  2803                              <1> 	
  2804 00002468 FEC2                <1> 	inc dl
  2805 0000246A 83FF51              <1> 	cmp di, 81
  2806 0000246D 0F8CEDFF            <1> 	jnge near .loop
  2807                              <1> 	
  2808 00002471 C606500000          <1> 	mov byte [80], 0
  2809                              <1> 	
  2810                              <1> 	mov16 dx, 0, 24
    18 00002476 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2811 00002479 E8ABF4              <1> 	call os_move_cursor
  2812                              <1> 	
  2813 0000247C B82009              <1> 	mov ax, 0920h
  2814 0000247F BB7000              <1> 	mov bx, 70h
  2815 00002482 B95000              <1> 	mov cx, 80
  2816 00002485 CD10                <1> 	int 10h
  2817                              <1> 	
  2818                              <1> 	mov16 dx, 0, 24
    18 00002487 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2819 0000248A E89AF4              <1> 	call os_move_cursor
  2820                              <1> 	
  2821 0000248D E826F4              <1> 	call os_print_string
  2822                              <1> 	
  2823 00002490 5A                  <1> 	pop dx
  2824 00002491 E893F4              <1> 	call os_move_cursor
  2825                              <1> 
  2826                              <1> .exit:	
  2827 00002494 61                  <1> 	popa
  2828 00002495 C3                  <1> 	ret
  2829                              <1> 	
  2830                              <1> .restore:
  2831                              <1> 	mov16 dx, 0, 24
    18 00002496 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2832 00002499 E88BF4              <1> 	call os_move_cursor
  2833 0000249C BE0100              <1> 	mov si, 1
  2834 0000249F E814F4              <1> 	call os_print_string
  2835                              <1> 	
  2836 000024A2 5A                  <1> 	pop dx
  2837 000024A3 E881F4              <1> 	call os_move_cursor
  2838                              <1> 	
  2839 000024A6 61                  <1> 	popa
  2840 000024A7 C3                  <1> 	ret
  2841                              <1> 	
  2842                              <1> ; Resets the font to the selected default.
  2843                              <1> ; IN = nothing
  2844                              <1> ; OUT = nothing
  2845                              <1> os_reset_font:
  2846 000024A8 60                  <1> 	pusha
  2847                              <1> 	
  2848 000024A9 803EF1DE01          <1> 	cmp byte [57073], 1
  2849 000024AE 0F841800            <1> 	je near .bios
  2850                              <1> 	
  2851 000024B2 06                  <1> 	push es
  2852 000024B3 B80011              <1> 	mov ax, 1100h
  2853 000024B6 BB0010              <1> 	mov bx, 1000h
  2854 000024B9 B90001              <1> 	mov cx, 0100h
  2855                              <1> 	clr dx
    14 000024BC 31D2                <2>  xor %1, %1
  2856 000024BE 8E06[9405]          <1> 	mov es, [driversgmt]
  2857 000024C2 BD0016              <1> 	mov bp, SYSTEM_FONT
  2858 000024C5 CD10                <1> 	int 10h
  2859 000024C7 07                  <1> 	pop es
  2860 000024C8 61                  <1> 	popa
  2861 000024C9 C3                  <1> 	ret
  2862                              <1> 	
  2863                              <1> .bios:
  2864 000024CA 61                  <1> 	popa
  2865 000024CB C3                  <1> 	ret
  2866                              <1> 
  2867                              <1> ; Draws the MichalOS logo.
  2868                              <1> ; IN: nothing
  2869                              <1> ; OUT: a very beautiful logo :-)
  2870                              <1> os_draw_logo:
  2871 000024CC 60                  <1> 	pusha
  2872                              <1> 	
  2873                              <1> 	mov16 dx, 0, 2
    18 000024CD BA0002              <2>  mov %1, (%2 + %3 * 256)
  2874 000024D0 E854F4              <1> 	call os_move_cursor
  2875                              <1> 
  2876 000024D3 B82009              <1> 	mov ax, 0920h
  2877 000024D6 BB0400              <1> 	mov bx, 00000100b
  2878 000024D9 B93002              <1> 	mov cx, 560
  2879 000024DC CD10                <1> 	int 10h
  2880                              <1> 
  2881 000024DE BE[260A]            <1> 	mov si, logo
  2882 000024E1 E80200              <1> 	call os_draw_icon
  2883 000024E4 61                  <1> 	popa
  2884 000024E5 C3                  <1> 	ret
  2885                              <1> 
  2886                              <1> ; Draws an icon (in the MichalOS format).
  2887                              <1> ; IN: SI = address of the icon
  2888                              <1> ; OUT: nothing
  2889                              <1> os_draw_icon:
  2890 000024E6 60                  <1> 	pusha
  2891                              <1> 	
  2892 000024E7 E846F4              <1> 	call os_get_cursor_pos
  2893 000024EA 8916[5325]          <1> 	mov [.cursor], dx
  2894                              <1> 	
  2895 000024EE AD                  <1> 	lodsw
  2896 000024EF A3[5925]            <1> 	mov [.size], ax
  2897                              <1> 	
  2898                              <1> 	clr cx
    14 000024F2 31C9                <2>  xor %1, %1
  2899                              <1> 	
  2900                              <1> .loop:
  2901 000024F4 AC                  <1> 	lodsb
  2902                              <1> 	
  2903 000024F5 B40E                <1> 	mov ah, 0Eh
  2904                              <1> 	
  2905 000024F7 51                  <1> 	push cx
  2906 000024F8 88C1                <1> 	mov cl, al
  2907 000024FA 0FB6D9              <1> 	movzx bx, cl
  2908 000024FD 80E3C0              <1> 	and bl, 11000000b
  2909 00002500 C0EB06              <1> 	shr bl, 6
  2910 00002503 8A87[5525]          <1> 	mov al, [.chars + bx]
  2911 00002507 CD10                <1> 	int 10h
  2912                              <1> 	
  2913 00002509 0FB6D9              <1> 	movzx bx, cl
  2914 0000250C 80E330              <1> 	and bl, 110000b
  2915 0000250F C0EB04              <1> 	shr bl, 4
  2916 00002512 8A87[5525]          <1> 	mov al, [.chars + bx]
  2917 00002516 CD10                <1> 	int 10h
  2918                              <1> 	
  2919 00002518 0FB6D9              <1> 	movzx bx, cl
  2920 0000251B 80E30C              <1> 	and bl, 1100b
  2921 0000251E C0EB02              <1> 	shr bl, 2
  2922 00002521 8A87[5525]          <1> 	mov al, [.chars + bx]
  2923 00002525 CD10                <1> 	int 10h
  2924                              <1> 	
  2925 00002527 0FB6D9              <1> 	movzx bx, cl
  2926 0000252A 80E303              <1> 	and bl, 11b
  2927 0000252D 8A87[5525]          <1> 	mov al, [.chars + bx]
  2928 00002531 CD10                <1> 	int 10h
  2929 00002533 59                  <1> 	pop cx
  2930                              <1> 	
  2931 00002534 FEC1                <1> 	inc cl
  2932 00002536 3A0E[5925]          <1> 	cmp cl, [.size]
  2933 0000253A 75B8                <1> 	jne .loop
  2934                              <1> 
  2935 0000253C FE06[5425]          <1> 	inc byte [.cursor + 1]
  2936 00002540 8B16[5325]          <1> 	mov dx, [.cursor]
  2937 00002544 E8E0F3              <1> 	call os_move_cursor
  2938                              <1> 	
  2939 00002547 B100                <1> 	mov cl, 0
  2940 00002549 FEC5                <1> 	inc ch
  2941 0000254B 3A2E[5A25]          <1> 	cmp ch, [.size + 1]
  2942 0000254F 75A3                <1> 	jne .loop
  2943                              <1> 	
  2944 00002551 61                  <1> 	popa
  2945 00002552 C3                  <1> 	ret
  2946                              <1> 
  2947 00002553 0000                <1> 	.cursor		dw 0
  2948 00002555 20DCDFDB            <1> 	.chars		db 32, 220, 223, 219
  2949 00002559 0000                <1> 	.size		dw 0
  2950                              <1> 	
  2951                              <1> ; ------------------------------------------------------------------
  2952                              <1> ; os_option_menu -- Show a menu with a list of options
  2953                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated), BX = menu width
  2954                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
  2955                              <1> 
  2956                              <1> os_option_menu:
  2957 0000255B 60                  <1> 	pusha
  2958                              <1> 
  2959 0000255C 803EEFDE00          <1> 	cmp byte [57071], 0
  2960 00002561 741C                <1> 	je .skip
  2961                              <1> 	
  2962                              <1> 	mov16 dx, 0, 1
    18 00002563 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2963                              <1> 
  2964 00002566 E8BEF3              <1> 	call os_move_cursor
  2965                              <1> 	
  2966 00002569 B408                <1> 	mov ah, 08h
  2967 0000256B B700                <1> 	mov bh, 0
  2968 0000256D CD10                <1> 	int 10h				; Get the character's attribute (X = 0, Y = 1)
  2969                              <1> 	
  2970 0000256F 80E4F0              <1> 	and ah, 0F0h		; Keep only the background, set foreground to 0
  2971                              <1> 	
  2972 00002572 0FB6DC              <1> 	movzx bx, ah
  2973 00002575 B8B109              <1> 	mov ax, 09B1h
  2974 00002578 B93007              <1> 	mov cx, 1840
  2975 0000257B CD10                <1> 	int 10h
  2976                              <1> 	
  2977 0000257D 61                  <1> 	popa
  2978 0000257E 60                  <1> 	pusha
  2979                              <1> 
  2980                              <1> .skip:
  2981 0000257F 891E[E926]          <1> 	mov [.width], bx
  2982                              <1> 
  2983 00002583 50                  <1> 	push ax				; Store string list for now
  2984                              <1> 
  2985 00002584 E8E0F3              <1> 	call os_hide_cursor
  2986                              <1> 
  2987 00002587 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  2988 00002589 89C6                <1> 	mov si, ax
  2989                              <1> 	
  2990                              <1> .count_loop:
  2991 0000258B AC                  <1> 	lodsb
  2992 0000258C 3C00                <1> 	cmp al, 0
  2993 0000258E 7408                <1> 	je .done_count
  2994 00002590 3C2C                <1> 	cmp al, ','
  2995 00002592 75F7                <1> 	jne .count_loop
  2996 00002594 FEC1                <1> 	inc cl
  2997 00002596 EBF3                <1> 	jmp .count_loop
  2998                              <1> 
  2999                              <1> .done_count:
  3000 00002598 FEC1                <1> 	inc cl
  3001 0000259A 880E[E526]          <1> 	mov byte [.num_of_entries], cl
  3002                              <1> 
  3003                              <1> 
  3004 0000259E 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  3005 0000259F 8936[E726]          <1> 	mov word [.list_string], si
  3006                              <1> 
  3007                              <1> 
  3008                              <1> 	; Now that we've drawn the list, highlight the currently selected
  3009                              <1> 	; entry and let the user move up and down using the cursor keys
  3010                              <1> 
  3011 000025A3 C606[E626]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  3012                              <1> 
  3013                              <1> 	mov16 dx, 25, 2			; Set up starting position for selector
    18 000025A8 BA1902              <2>  mov %1, (%2 + %3 * 256)
  3014                              <1> 
  3015 000025AB E879F3              <1> 	call os_move_cursor
  3016                              <1> 
  3017                              <1> .more_select:
  3018 000025AE 60                  <1> 	pusha
  3019 000025AF 8A1EF0DE            <1> 	mov bl, [57072]		; Black on white for option list box
  3020                              <1> 	mov16 dx, 1, 1
    18 000025B3 BA0101              <2>  mov %1, (%2 + %3 * 256)
  3021                              <1> 
  3022 000025B6 8B36[E926]          <1> 	mov si, [.width]
  3023 000025BA 0FB63E[E526]        <1> 	movzx di, [.num_of_entries]
  3024 000025BF 83C703              <1> 	add di, 3
  3025 000025C2 E8ACF3              <1> 	call os_draw_block
  3026 000025C5 61                  <1> 	popa
  3027                              <1> 
  3028 000025C6 E8EA00              <1> 	call .draw_black_bar
  3029                              <1> 
  3030 000025C9 8B36[E726]          <1> 	mov word si, [.list_string]
  3031 000025CD E8A000              <1> 	call .draw_list
  3032                              <1> 
  3033                              <1> .another_key:
  3034 000025D0 E864ED              <1> 	call os_wait_for_key		; Move / select option
  3035 000025D3 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  3036 000025D6 7419                <1> 	je .go_up
  3037 000025D8 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  3038 000025DB 7425                <1> 	je .go_down
  3039 000025DD 3C0D                <1> 	cmp al, 13			; Enter pressed?
  3040 000025DF 745A                <1> 	je .option_selected
  3041 000025E1 3C1B                <1> 	cmp al, 27			; Esc pressed?
  3042 000025E3 7470                <1> 	je .esc_pressed
  3043 000025E5 80FC4B              <1> 	cmp ah, 75			; Left pressed?
  3044 000025E8 7474                <1> 	je .left_pressed
  3045 000025EA 80FC4D              <1> 	cmp ah, 77			; Right pressed?
  3046 000025ED 7478                <1> 	je .right_pressed
  3047 000025EF EBDF                <1> 	jmp .another_key		; If not, wait for another key
  3048                              <1> 
  3049                              <1> 
  3050                              <1> .go_up:
  3051 000025F1 80FE02              <1> 	cmp dh, 2			; Already at top?
  3052 000025F4 7E37                <1> 	jle .hit_top
  3053                              <1> 
  3054 000025F6 E8D100              <1> 	call .draw_white_bar
  3055                              <1> 
  3056 000025F9 B219                <1> 	mov dl, 25
  3057 000025FB E829F3              <1> 	call os_move_cursor
  3058                              <1> 
  3059 000025FE FECE                <1> 	dec dh				; Row to select (increasing down)
  3060 00002600 EBAC                <1> 	jmp .more_select
  3061                              <1> 
  3062                              <1> 
  3063                              <1> .go_down:				; Already at bottom of list?
  3064 00002602 8A1E[E526]          <1> 	mov bl, [.num_of_entries]
  3065 00002606 FEC3                <1> 	inc bl
  3066 00002608 38DE                <1> 	cmp dh, bl
  3067 0000260A 742A                <1> 	je .hit_bottom
  3068                              <1> 
  3069 0000260C B90000              <1> 	mov cx, 0
  3070 0000260F 88F1                <1> 	mov byte cl, dh
  3071                              <1> 
  3072 00002611 80E906              <1> 	sub cl, 6
  3073 00002614 FEC1                <1> 	inc cl
  3074 00002616 020E[E626]          <1> 	add byte cl, [.skip_num]
  3075                              <1> 
  3076 0000261A A0[E526]            <1> 	mov byte al, [.num_of_entries]
  3077 0000261D 38C1                <1> 	cmp cl, al
  3078 0000261F 74AF                <1> 	je .another_key
  3079                              <1> 
  3080 00002621 E8A600              <1> 	call .draw_white_bar
  3081                              <1> 
  3082 00002624 B219                <1> 	mov dl, 25
  3083 00002626 E8FEF2              <1> 	call os_move_cursor
  3084                              <1> 
  3085 00002629 FEC6                <1> 	inc dh
  3086 0000262B EB81                <1> 	jmp .more_select
  3087                              <1> 
  3088                              <1> 
  3089                              <1> .hit_top:
  3090 0000262D B601                <1> 	mov dh, 1
  3091 0000262F 0236[E526]          <1> 	add dh, [.num_of_entries]
  3092 00002633 E978FF              <1> 	jmp .more_select
  3093                              <1> 
  3094                              <1> 
  3095                              <1> .hit_bottom:
  3096 00002636 B602                <1> 	mov dh, 2
  3097 00002638 E973FF              <1> 	jmp .more_select
  3098                              <1> 
  3099                              <1> 
  3100                              <1> 
  3101                              <1> .option_selected:
  3102 0000263B E81EF3              <1> 	call os_show_cursor
  3103                              <1> 
  3104 0000263E 80EE02              <1> 	sub dh, 2
  3105                              <1> 
  3106 00002641 B80000              <1> 	mov ax, 0
  3107 00002644 88F0                <1> 	mov al, dh
  3108                              <1> 
  3109 00002646 FEC0                <1> 	inc al				; Options start from 1
  3110 00002648 0206[E626]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  3111                              <1> 
  3112 0000264C A3[E326]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  3113                              <1> 
  3114 0000264F 61                  <1> 	popa
  3115                              <1> 
  3116 00002650 A1[E326]            <1> 	mov word ax, [.tmp]
  3117 00002653 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  3118 00002654 C3                  <1> 	ret
  3119                              <1> 
  3120                              <1> 
  3121                              <1> 
  3122                              <1> .esc_pressed:
  3123 00002655 E804F3              <1> 	call os_show_cursor
  3124 00002658 61                  <1> 	popa
  3125 00002659 B80000              <1> 	mov ax, 0
  3126 0000265C F9                  <1> 	stc
  3127 0000265D C3                  <1> 	ret
  3128                              <1> 
  3129                              <1> .left_pressed:
  3130 0000265E E8FBF2              <1> 	call os_show_cursor
  3131 00002661 61                  <1> 	popa
  3132 00002662 B80100              <1> 	mov ax, 1
  3133 00002665 F9                  <1> 	stc
  3134 00002666 C3                  <1> 	ret
  3135                              <1> 
  3136                              <1> .right_pressed:
  3137 00002667 E8F2F2              <1> 	call os_show_cursor
  3138 0000266A 61                  <1> 	popa
  3139 0000266B B80200              <1> 	mov ax, 2
  3140 0000266E F9                  <1> 	stc
  3141 0000266F C3                  <1> 	ret
  3142                              <1> 
  3143                              <1> .draw_list:
  3144 00002670 60                  <1> 	pusha
  3145                              <1> 
  3146                              <1> 	mov16 dx, 3, 2			; Get into position for option list text
    18 00002671 BA0302              <2>  mov %1, (%2 + %3 * 256)
  3147 00002674 E8B0F2              <1> 	call os_move_cursor
  3148                              <1> 
  3149                              <1> 
  3150 00002677 B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  3151 0000267A 8A0E[E626]          <1> 	mov byte cl, [.skip_num]
  3152                              <1> 
  3153                              <1> .skip_loop:
  3154 0000267E 83F900              <1> 	cmp cx, 0
  3155 00002681 7408                <1> 	je .skip_loop_finished
  3156                              <1> 	
  3157                              <1> .more_lodsb:
  3158 00002683 AC                  <1> 	lodsb
  3159 00002684 3C2C                <1> 	cmp al, ','
  3160 00002686 75FB                <1> 	jne .more_lodsb
  3161 00002688 49                  <1> 	dec cx
  3162 00002689 EBF3                <1> 	jmp .skip_loop
  3163                              <1> 
  3164                              <1> 
  3165                              <1> .skip_loop_finished:
  3166 0000268B BB0000              <1> 	mov bx, 0			; Counter for total number of options
  3167                              <1> 
  3168                              <1> 
  3169                              <1> .more:
  3170 0000268E AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  3171                              <1> 
  3172 0000268F 3C00                <1> 	cmp al, 0			; End of string?
  3173 00002691 741B                <1> 	je .done_list
  3174                              <1> 
  3175 00002693 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  3176 00002695 7406                <1> 	je .newline
  3177                              <1> 
  3178 00002697 B40E                <1> 	mov ah, 0Eh
  3179 00002699 CD10                <1> 	int 10h
  3180 0000269B EBF1                <1> 	jmp .more
  3181                              <1> 
  3182                              <1> .newline:
  3183 0000269D B203                <1> 	mov dl, 3			; Go back to starting X position
  3184 0000269F FEC6                <1> 	inc dh				; But jump down a line
  3185 000026A1 E883F2              <1> 	call os_move_cursor
  3186                              <1> 
  3187 000026A4 43                  <1> 	inc bx				; Update the number-of-options counter
  3188 000026A5 0FB63E[E526]        <1> 	movzx di, [.num_of_entries]	; Low 8 bits of DI = [.items], high 8 bits = 0
  3189 000026AA 39FB                <1> 	cmp bx, di			; Limit to one screen of options
  3190 000026AC 7CE0                <1> 	jl .more
  3191                              <1> 
  3192                              <1> .done_list:
  3193 000026AE 61                  <1> 	popa
  3194 000026AF E875F2              <1> 	call os_move_cursor
  3195                              <1> 
  3196 000026B2 C3                  <1> 	ret
  3197                              <1> 
  3198                              <1> 
  3199                              <1> 
  3200                              <1> .draw_black_bar:
  3201 000026B3 60                  <1> 	pusha
  3202                              <1> 
  3203 000026B4 B202                <1> 	mov dl, 2
  3204 000026B6 E86EF2              <1> 	call os_move_cursor
  3205                              <1> 
  3206 000026B9 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3207 000026BC 8B0E[E926]          <1> 	mov cx, [.width]
  3208 000026C0 83E902              <1> 	sub cx, 2
  3209 000026C3 BB0F00              <1> 	mov bx, 00001111b		; White text on black background
  3210 000026C6 CD10                <1> 	int 10h
  3211                              <1> 
  3212 000026C8 61                  <1> 	popa
  3213 000026C9 C3                  <1> 	ret
  3214                              <1> 
  3215                              <1> .draw_white_bar:
  3216 000026CA 60                  <1> 	pusha
  3217                              <1> 
  3218 000026CB B202                <1> 	mov dl, 2
  3219 000026CD E857F2              <1> 	call os_move_cursor
  3220                              <1> 
  3221 000026D0 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3222 000026D3 8B0E[E926]          <1> 	mov cx, [.width]
  3223 000026D7 83E902              <1> 	sub cx, 2
  3224 000026DA 0FB61EF0DE          <1> 	movzx bx, byte [57072]	; Black text on white background
  3225 000026DF CD10                <1> 	int 10h
  3226                              <1> 
  3227 000026E1 61                  <1> 	popa
  3228 000026E2 C3                  <1> 	ret
  3229                              <1> 
  3230 000026E3 0000                <1> 	.tmp					dw 0
  3231 000026E5 00                  <1> 	.num_of_entries			db 0
  3232 000026E6 00                  <1> 	.skip_num				db 0
  3233 000026E7 0000                <1> 	.list_string			dw 0
  3234 000026E9 0000                <1> 	.width					dw 0
  3235                              <1> 	
  3236                              <1> ; ==================================================================
   820                                  	%INCLUDE "features/sound.asm"
   821                              <1> ; ==================================================================
   822                              <1> ; PC SPEAKER/ADLIB SOUND ROUTINES
   823                              <1> ; ==================================================================
   824                              <1> 
   825                              <1> ; ------------------------------------------------------------------
   826                              <1> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
   827                              <1> ; IN: AX = note frequency; OUT: Nothing (registers preserved)
   828                              <1> 
   829                              <1> os_speaker_tone:
   830 000026EB 60                  <1> 	pusha
   831 000026EC 803E830000          <1> 	cmp byte [0083h], 0
   832 000026F1 0F842600            <1> 	je near .exit
   833 000026F5 61                  <1> 	popa
   834                              <1> 	
   835 000026F6 60                  <1> 	pusha
   836 000026F7 83F800              <1> 	cmp ax, 0
   837 000026FA 0F841D00            <1> 	je near .exit
   838                              <1> 	
   839 000026FE E82A00              <1> 	call os_speaker_off
   840 00002701 89C1                <1> 	mov cx, ax			; Store note value for now
   841                              <1> 
   842 00002703 B0B6                <1> 	mov al, 10110110b
   843 00002705 E643                <1> 	out 43h, al
   844 00002707 BA1200              <1> 	mov dx, 12h			; Set up frequency
   845 0000270A B8DC34              <1> 	mov ax, 34DCh
   846 0000270D F7F1                <1> 	div cx
   847 0000270F E642                <1> 	out 42h, al
   848 00002711 88E0                <1> 	mov al, ah
   849 00002713 E642                <1> 	out 42h, al
   850                              <1> 
   851 00002715 E461                <1> 	in al, 61h			; Switch PC speaker on
   852 00002717 0C03                <1> 	or al, 03h
   853 00002719 E661                <1> 	out 61h, al
   854                              <1> 
   855                              <1> .exit:
   856 0000271B 61                  <1> 	popa
   857 0000271C C3                  <1> 	ret
   858                              <1> 
   859                              <1> ; ------------------------------------------------------------------
   860                              <1> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
   861                              <1> ; IN: AX = note frequency, CX = length (in ticks)
   862                              <1> 
   863                              <1> os_speaker_note_length:
   864 0000271D 60                  <1> 	pusha
   865 0000271E E8CAFF              <1> 	call os_speaker_tone
   866                              <1> 	
   867 00002721 89C8                <1> 	mov ax, cx
   868 00002723 E863EE              <1> 	call os_pause
   869                              <1> 	
   870 00002726 E80200              <1> 	call os_speaker_off
   871 00002729 61                  <1> 	popa
   872 0000272A C3                  <1> 	ret
   873                              <1> 
   874                              <1> ; ------------------------------------------------------------------
   875                              <1> ; os_speaker_off -- Turn off PC speaker
   876                              <1> ; IN/OUT: Nothing (registers preserved)
   877                              <1> 
   878                              <1> os_speaker_off:
   879 0000272B 60                  <1> 	pusha
   880                              <1> 
   881 0000272C E461                <1> 	in al, 61h
   882 0000272E 24FC                <1> 	and al, 0FCh
   883 00002730 E661                <1> 	out 61h, al
   884                              <1> 
   885 00002732 61                  <1> 	popa
   886 00002733 C3                  <1> 	ret
   887                              <1> 
   888                              <1> ; ------------------------------------------------------------------
   889                              <1> ; os_start_adlib -- Starts the selected Adlib driver
   890                              <1> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
   891                              <1> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
   892                              <1> ; Common prescaler values:
   893                              <1> ;		33 = ~1 kHz (1004.362 Hz)
   894                              <1> ;		663 = ~50 Hz (49.991 Hz)
   895                              <1> ;		1820 = ~18.2 Hz (18.211 Hz)
   896                              <1> 
   897                              <1> os_start_adlib:
   898 00002734 60                  <1> 	pusha
   899 00002735 C606[0A29]01        <1> 	mov byte [adlib_running], 1
   900                              <1> 
   901 0000273A 803EEEDE01          <1> 	cmp byte [57070], 1
   902 0000273F 7D16                <1> 	jge .pcspk
   903                              <1> 	
   904 00002741 B80000              <1> 	mov ax, 0
   905                              <1> 	
   906                              <1> .loop:
   907 00002744 E8C700              <1> 	call int_adlib_regwrite
   908 00002747 FEC4                <1> 	inc ah
   909 00002749 75F9                <1> 	jnz .loop
   910                              <1> 	
   911 0000274B B82400              <1> 	mov ax, 36
   912 0000274E F7E1                <1> 	mul cx
   913                              <1> 	
   914 00002750 89C1                <1> 	mov cx, ax
   915 00002752 E81421              <1> 	call os_attach_app_timer
   916                              <1> 	
   917 00002755 61                  <1> 	popa
   918 00002756 C3                  <1> 	ret
   919                              <1> 	
   920                              <1> .pcspk:
   921 00002757 B82400              <1> 	mov ax, 36
   922 0000275A F6F3                <1> 	div bl
   923                              <1> 	
   924 0000275C A2[A529]            <1> 	mov [pwm_channel_amplitude], al
   925                              <1> 
   926 0000275F 8936[9E29]          <1> 	mov [pwm_callback], si
   927 00002763 890E[A029]          <1> 	mov [pwm_callback_ctr], cx
   928 00002767 890E[A229]          <1> 	mov [pwm_callback_ctr_def], cx
   929                              <1> 
   930                              <1> 	; Set up the PC speaker
   931 0000276B E461                <1> 	in al, 0x61
   932 0000276D 0C03                <1> 	or al, 3
   933 0000276F E661                <1> 	out 0x61, al
   934                              <1> 
   935                              <1> 	; Enable the callback
   936 00002771 BE[0B29]            <1> 	mov si, pwm_handler
   937 00002774 8CCF                <1> 	mov di, cs
   938 00002776 B11C                <1> 	mov cl, 01Ch
   939 00002778 E8A820              <1> 	call os_modify_int_handler
   940                              <1> 
   941 0000277B B92400              <1> 	mov cx, 36
   942 0000277E E80F21              <1> 	call os_set_timer_speed
   943                              <1> 	
   944 00002781 61                  <1> 	popa
   945 00002782 C3                  <1> 	ret
   946                              <1> 	
   947                              <1> ; ------------------------------------------------------------------
   948                              <1> ; os_stop_adlib -- Stops the Adlib driver
   949                              <1> 
   950                              <1> os_stop_adlib:
   951 00002783 60                  <1> 	pusha
   952 00002784 803EEEDE01          <1> 	cmp byte [57070], 1
   953 00002789 7D1D                <1> 	jge .pcspk
   954                              <1> 	
   955 0000278B E8EA20              <1> 	call os_return_app_timer
   956                              <1> 
   957 0000278E B400                <1> 	mov ah, 0
   958                              <1> 	
   959                              <1> .loop:
   960 00002790 0FB6DC              <1> 	movzx bx, ah
   961 00002793 C1EB05              <1> 	shr bx, 5
   962 00002796 8A87[CB27]          <1> 	mov al, [adlib_clear_regs + bx]
   963                              <1> 
   964 0000279A E87100              <1> 	call int_adlib_regwrite
   965                              <1> 	
   966 0000279D FEC4                <1> 	inc ah
   967 0000279F 75EF                <1> 	jnz .loop
   968                              <1> 	
   969 000027A1 C606[0A29]00        <1> 	mov byte [adlib_running], 0
   970 000027A6 61                  <1> 	popa
   971 000027A7 C3                  <1> 	ret
   972                              <1> 	
   973                              <1> .pcspk:
   974                              <1> 	; Turn off the PC speaker
   975 000027A8 E461                <1> 	in al, 0x61
   976 000027AA 24FC                <1> 	and al, 0xfc
   977 000027AC E661                <1> 	out 0x61, al
   978                              <1> 
   979 000027AE B90000              <1> 	mov cx, 0
   980 000027B1 E8DC20              <1> 	call os_set_timer_speed
   981                              <1> 	
   982                              <1> 	; Reset the RTC handler
   983 000027B4 B11C                <1> 	mov cl, 1Ch
   984 000027B6 BE[3949]            <1> 	mov si, os_compat_int1C
   985 000027B9 8CCF                <1> 	mov di, cs
   986 000027BB E86520              <1> 	call os_modify_int_handler
   987                              <1> 	
   988                              <1> 	; Turn off all of the channels
   989 000027BE B91200              <1> 	mov cx, 18		; Not only nuke pwm_freq, but also pwm_cntr!
   990 000027C1 BF[7929]            <1> 	mov di, pwm_freq
   991 000027C4 B80000              <1> 	mov ax, 0
   992 000027C7 F3AB                <1> 	rep stosw
   993                              <1> 	
   994 000027C9 61                  <1> 	popa
   995 000027CA C3                  <1> 	ret
   996                              <1> 	
   997                              <1> 	; Registers:    	   0x00  0x20  0x40  0x60  0x80  0xA0  0xC0  0xE0
   998 000027CB 00003FFFFF000000    <1> 	adlib_clear_regs	db 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00
   999                              <1> 	
  1000                              <1> ; ------------------------------------------------------------------
  1001                              <1> ; os_check_adlib -- Checks if YM3812 is present in the system
  1002                              <1> ; OUT: CF clear if YM3812 is present
  1003                              <1> 
  1004                              <1> os_check_adlib:
  1005 000027D3 60                  <1> 	pusha
  1006 000027D4 803EEEDE01          <1> 	cmp byte [57070], 1
  1007 000027D9 7D14                <1> 	jge .ok
  1008                              <1> 
  1009 000027DB B86004              <1> 	mov ax, 0460h
  1010 000027DE E82D00              <1> 	call int_adlib_regwrite
  1011                              <1> 	
  1012 000027E1 B88004              <1> 	mov ax, 0480h
  1013 000027E4 E82700              <1> 	call int_adlib_regwrite
  1014                              <1> 	
  1015 000027E7 BA8803              <1> 	mov dx, 388h
  1016 000027EA EC                  <1> 	in al, dx
  1017 000027EB 3C00                <1> 	cmp al, 0
  1018 000027ED 7503                <1> 	jne .error
  1019                              <1> 	
  1020                              <1> .ok:
  1021 000027EF 61                  <1> 	popa
  1022 000027F0 F8                  <1> 	clc
  1023 000027F1 C3                  <1> 	ret
  1024                              <1> 	
  1025                              <1> .error:
  1026 000027F2 61                  <1> 	popa
  1027 000027F3 F9                  <1> 	stc
  1028 000027F4 C3                  <1> 	ret
  1029                              <1> 	
  1030                              <1> ; ------------------------------------------------------------------
  1031                              <1> ; os_adlib_regwrite -- Write to a YM3812 register
  1032                              <1> ; IN: AH/AL - register address/value to write
  1033                              <1> 
  1034                              <1> os_adlib_regwrite:
  1035 000027F5 60                  <1> 	pusha
  1036                              <1> 	
  1037 000027F6 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1038 000027F9 6488870005          <1> 	mov [fs:ADLIB_BUFFER + bx], al
  1039                              <1> 	
  1040 000027FE E80D00              <1> 	call int_adlib_regwrite
  1041                              <1> 	
  1042 00002801 61                  <1> 	popa
  1043 00002802 C3                  <1> 	ret
  1044                              <1> 	
  1045                              <1> ; ------------------------------------------------------------------
  1046                              <1> ; os_adlib_regread -- Read from a YM3812 register
  1047                              <1> ; IN: AH - register address; OUT: AL - value
  1048                              <1> 
  1049                              <1> os_adlib_regread:
  1050 00002803 53                  <1> 	push bx
  1051                              <1> 	
  1052 00002804 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1053 00002807 648A870005          <1> 	mov al, [fs:ADLIB_BUFFER + bx]
  1054                              <1> 	
  1055 0000280C 5B                  <1> 	pop bx
  1056 0000280D C3                  <1> 	ret
  1057                              <1> 	
  1058                              <1> ; ------------------------------------------------------------------
  1059                              <1> ; int_adlib_regwrite -- Internal kernel function - not available to user programs
  1060                              <1> ; IN: AH/AL - register address/value to write
  1061                              <1> 	
  1062                              <1> int_adlib_regwrite:
  1063 0000280E 60                  <1> 	pusha
  1064                              <1> 
  1065 0000280F 803EEEDE01          <1> 	cmp byte [57070], 1
  1066 00002814 7D21                <1> 	jge .pcspk
  1067                              <1> 
  1068 00002816 803E[0A29]00        <1> 	cmp byte [adlib_running], 0
  1069 0000281B 7418                <1> 	je .no_write
  1070                              <1> 
  1071 0000281D BA8803              <1> 	mov dx, 388h
  1072 00002820 50                  <1> 	push ax
  1073 00002821 88E0                <1> 	mov al, ah
  1074 00002823 EE                  <1> 	out dx, al
  1075                              <1> 
  1076 00002824 EC                  <1> 	in al, dx
  1077 00002825 EC                  <1> 	in al, dx
  1078 00002826 EC                  <1> 	in al, dx
  1079 00002827 EC                  <1> 	in al, dx
  1080 00002828 EC                  <1> 	in al, dx
  1081 00002829 EC                  <1> 	in al, dx
  1082                              <1> 	
  1083 0000282A 58                  <1> 	pop ax
  1084 0000282B 42                  <1> 	inc dx
  1085 0000282C EE                  <1> 	out dx, al
  1086                              <1> 
  1087 0000282D 4A                  <1> 	dec	dx
  1088 0000282E B422                <1> 	mov	ah, 22h
  1089                              <1> 
  1090                              <1> .wait:
  1091 00002830 EC                  <1> 	in al,dx
  1092 00002831 FECC                <1> 	dec ah
  1093 00002833 75FB                <1> 	jnz .wait
  1094                              <1> 	
  1095                              <1> .no_write:
  1096 00002835 61                  <1> 	popa
  1097 00002836 C3                  <1> 	ret
  1098                              <1> 
  1099                              <1> .pcspk:
  1100 00002837 80FCA0              <1> 	cmp ah, 0A0h
  1101 0000283A 7CF9                <1> 	jl .no_write
  1102                              <1> 
  1103 0000283C 80FCB8              <1> 	cmp ah, 0B8h
  1104 0000283F 7FF4                <1> 	jg .no_write
  1105                              <1> 
  1106 00002841 80E40F              <1> 	and ah, 0Fh
  1107 00002844 0FB6DC              <1> 	movzx bx, ah
  1108                              <1> 	
  1109 00002847 648A87A005          <1> 	mov al, [fs:ADLIB_BUFFER + 0A0h + bx]
  1110 0000284C 648AA7B005          <1> 	mov ah, [fs:ADLIB_BUFFER + 0B0h + bx]
  1111                              <1> 	
  1112 00002851 F6C420              <1> 	test ah, 20h
  1113 00002854 7439                <1> 	jz .pcspk_clear
  1114                              <1> 	
  1115 00002856 88E2                <1> 	mov dl, ah		; Get the block number
  1116 00002858 C0EA02              <1> 	shr dl, 2
  1117 0000285B 80E207              <1> 	and dl, 7
  1118                              <1> 	
  1119 0000285E 25FF03              <1> 	and ax, 3FFh	; Get the FNum
  1120                              <1> 	
  1121                              <1> 	; WARNING! Due to the 16-bit integer limit (for speed), the maximum is block = 7, FNum = 511.
  1122                              <1> 	; Quick and dirty formula: freq = (fnum << block) / 21
  1123                              <1> 
  1124 00002861 8816[6728]          <1> 	mov [.shift + 2], dl
  1125                              <1> 	
  1126 00002865 C1E000              <1> 	.shift: db 0C1h, 0E0h, 0	; Shift AX left by the block number
  1127                              <1> 
  1128 00002868 53                  <1> 	push bx
  1129                              <1> 	
  1130 00002869 31D2                <1> 	xor dx, dx
  1131 0000286B BB1500              <1> 	mov bx, 21
  1132 0000286E F7F3                <1> 	div bx						; Calculate the frequency
  1133                              <1> 
  1134 00002870 5B                  <1> 	pop bx
  1135                              <1> 
  1136 00002871 53                  <1> 	push bx						; Apply the frequency multiplier
  1137 00002872 B700                <1> 	mov bh, 0
  1138 00002874 8A9F[A928]          <1> 	mov bl, [adlib_fmul_registers + bx]
  1139 00002878 648A9F0005          <1> 	mov bl, [fs:ADLIB_BUFFER + bx]
  1140 0000287D 80E30F              <1> 	and bl, 0Fh
  1141 00002880 8A9F[9928]          <1> 	mov bl, [adlib_fmul_values + bx]
  1142                              <1> 	
  1143 00002884 F7E3                <1> 	mul bx
  1144 00002886 5B                  <1> 	pop bx
  1145                              <1> 	
  1146 00002887 D1E3                <1> 	shl bx, 1		; Words
  1147 00002889 8987[7929]          <1> 	mov word [pwm_freq + bx], ax
  1148                              <1> 
  1149 0000288D 61                  <1> 	popa
  1150 0000288E C3                  <1> 	ret
  1151                              <1> 	
  1152                              <1> .pcspk_clear:
  1153 0000288F D1E3                <1> 	shl bx, 1		; Words
  1154 00002891 C787[7929]0000      <1> 	mov word [pwm_freq + bx], 0
  1155                              <1> 	
  1156 00002897 61                  <1> 	popa
  1157 00002898 C3                  <1> 	ret
  1158                              <1> 	
  1159 00002899 01020406080A0C0E10- <1> 	adlib_fmul_values		db 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30
  1159 000028A2 12141418181E1E      <1>
  1160 000028A9 2324252B2C2D333435  <1> 	adlib_fmul_registers	db 23h, 24h, 25h, 2Bh, 2Ch, 2Dh, 33h, 34h, 35h
  1161                              <1> 	
  1162                              <1> ; ------------------------------------------------------------------
  1163                              <1> ; os_adlib_mute -- Mute the YM3812's current state
  1164                              <1> ; IN: nothing
  1165                              <1> 
  1166                              <1> os_adlib_mute:
  1167 000028B2 60                  <1> 	pusha
  1168                              <1> 	
  1169 000028B3 803EEEDE01          <1> 	cmp byte [57070], 1
  1170 000028B8 7D15                <1> 	jge .pcspk
  1171                              <1> 	
  1172 000028BA BE[F828]            <1> 	mov si, adlib_volume_registers
  1173 000028BD B91200              <1> 	mov cx, 18
  1174                              <1> 	
  1175                              <1> .loop:
  1176 000028C0 AC                  <1> 	lodsb
  1177 000028C1 88C4                <1> 	mov ah, al
  1178                              <1> 	
  1179 000028C3 E83DFF              <1> 	call os_adlib_regread
  1180 000028C6 0C3F                <1> 	or al, 3Fh
  1181 000028C8 E843FF              <1> 	call int_adlib_regwrite
  1182                              <1> 	
  1183 000028CB E2F3                <1> 	loop .loop
  1184 000028CD 61                  <1> 	popa
  1185 000028CE C3                  <1> 	ret
  1186                              <1> 
  1187                              <1> .pcspk:
  1188 000028CF C606[9D29]01        <1> 	mov byte [pwm_muted], 1
  1189 000028D4 61                  <1> 	popa
  1190 000028D5 C3                  <1> 	ret
  1191                              <1> 	
  1192                              <1> ; ------------------------------------------------------------------
  1193                              <1> ; os_adlib_unmute -- Unmute the YM3812's current state
  1194                              <1> ; IN: nothing
  1195                              <1> 
  1196                              <1> os_adlib_unmute:
  1197 000028D6 60                  <1> 	pusha
  1198                              <1> 
  1199 000028D7 803EEEDE01          <1> 	cmp byte [57070], 1
  1200 000028DC 7D13                <1> 	jge .pcspk
  1201                              <1> 	
  1202 000028DE BE[F828]            <1> 	mov si, adlib_volume_registers
  1203 000028E1 B91200              <1> 	mov cx, 18
  1204                              <1> 	
  1205                              <1> .loop:
  1206 000028E4 AC                  <1> 	lodsb
  1207 000028E5 88C4                <1> 	mov ah, al
  1208                              <1> 	
  1209 000028E7 E819FF              <1> 	call os_adlib_regread
  1210 000028EA E821FF              <1> 	call int_adlib_regwrite
  1211                              <1> 	
  1212 000028ED E2F5                <1> 	loop .loop
  1213 000028EF 61                  <1> 	popa
  1214 000028F0 C3                  <1> 	ret
  1215                              <1> 	
  1216                              <1> .pcspk:
  1217 000028F1 C606[9D29]00        <1> 	mov byte [pwm_muted], 0
  1218 000028F6 61                  <1> 	popa
  1219 000028F7 C3                  <1> 	ret
  1220                              <1> 
  1221 000028F8 40414243444548494A- <1> 	adlib_volume_registers	db 40h, 41h, 42h, 43h, 44h, 45h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 50h, 51h, 52h, 53h, 54h, 55h
  1221 00002901 4B4C4D505152535455  <1>
  1222 0000290A 00                  <1> 	adlib_running			db 0
  1223                              <1> 
  1224                              <1> ; ------------------------------------------------------------------
  1225                              <1> ; PWM DRIVER
  1226                              <1> ; What is emulated: FNum, block number, carrier frequency multiplier
  1227                              <1> ; What is NOT emulated: literally everything else - amplitude, ADSR, waveforms, modulator
  1228                              <1> 
  1229                              <1> pwm_handler:
  1230 0000290B FA                  <1> 	cli
  1231 0000290C 60                  <1> 	pusha
  1232 0000290D 1E                  <1> 	push ds
  1233                              <1> 	
  1234 0000290E 8CC8                <1> 	mov ax, cs
  1235 00002910 8ED8                <1> 	mov ds, ax
  1236                              <1> 	
  1237 00002912 803E[9D29]01        <1> 	cmp byte [pwm_muted], 1
  1238 00002917 744D                <1> 	je .no_spk
  1239                              <1> 
  1240                              <1> 	; Send the PWM value to the PC speaker
  1241 00002919 B0B0                <1> 	mov al, 10110000b
  1242 0000291B E643                <1> 	out 0x43, al
  1243 0000291D A0[A429]            <1> 	mov al, [pwm_val]
  1244 00002920 E642                <1> 	out 0x42, al
  1245 00002922 B000                <1> 	mov al, 0
  1246 00002924 E642                <1> 	out 0x42, al
  1247                              <1> 
  1248                              <1> 	; Calculate the next value
  1249 00002926 B90900              <1> 	mov cx, 9
  1250 00002929 BE[7929]            <1> 	mov si, pwm_freq
  1251 0000292C BF[8929]            <1> 	mov di, pwm_cntr - 2
  1252 0000292F B300                <1> 	mov bl, 0
  1253                              <1> 	
  1254 00002931 8A16[A529]          <1> 	mov dl, [pwm_channel_amplitude]
  1255                              <1> 	
  1256 00002935 803EEEDE02          <1> 	cmp byte [57070], 2
  1257 0000293A 7513                <1> 	jne .handler_loop
  1258                              <1> 	
  1259                              <1> 	; Max volume mode, count the number of active channels
  1260 0000293C 56                  <1> 	push si
  1261 0000293D 51                  <1> 	push cx
  1262                              <1> 	
  1263                              <1> 	clr bx
    14 0000293E 31DB                <2>  xor %1, %1
  1264                              <1> 	
  1265                              <1> .channel_count_loop:
  1266 00002940 AD                  <1> 	lodsw
  1267                              <1> 	
  1268 00002941 83F800              <1> 	cmp ax, 0
  1269 00002944 7401                <1> 	je .channel_count_loop_no_inc
  1270                              <1> 	
  1271 00002946 43                  <1> 	inc bx
  1272                              <1> 	
  1273                              <1> .channel_count_loop_no_inc:
  1274 00002947 E2F7                <1> 	loop .channel_count_loop
  1275                              <1> 	
  1276 00002949 59                  <1> 	pop cx
  1277 0000294A 5E                  <1> 	pop si
  1278                              <1> 	
  1279 0000294B 8A97[A629]          <1> 	mov dl, [pwm_fixed_amplitudes + bx]
  1280                              <1> 
  1281                              <1> 	; Add all of the channels together
  1282                              <1> .handler_loop:
  1283 0000294F AD                  <1> 	lodsw
  1284                              <1> 	
  1285 00002950 83F800              <1> 	cmp ax, 0
  1286 00002953 7409                <1> 	je .handler_loop_no_inc
  1287                              <1> 	
  1288 00002955 83C702              <1> 	add di, 2
  1289 00002958 0105                <1> 	add [di], ax
  1290                              <1> 	
  1291 0000295A 7902                <1> 	jns .handler_loop_no_inc
  1292                              <1> 	
  1293 0000295C 00D3                <1> 	add	bl, dl
  1294                              <1> 
  1295                              <1> .handler_loop_no_inc:
  1296 0000295E E2EF                <1> 	loop .handler_loop
  1297                              <1> 	
  1298 00002960 FEC3                <1> 	inc bl
  1299 00002962 881E[A429]          <1> 	mov [pwm_val], bl
  1300                              <1> 	
  1301                              <1> .no_spk:
  1302                              <1> 	; Have we reached the callback value?	
  1303 00002966 FF0E[A029]          <1> 	dec word [pwm_callback_ctr]
  1304 0000296A 750A                <1> 	jnz .exit
  1305                              <1> 
  1306                              <1> 	; Yes, reset it
  1307 0000296C A1[A229]            <1> 	mov ax, [pwm_callback_ctr_def]
  1308 0000296F A3[A029]            <1> 	mov [pwm_callback_ctr], ax
  1309                              <1> 	
  1310                              <1> 	; Call the callback
  1311 00002972 FF16[9E29]          <1> 	call [pwm_callback]
  1312                              <1> 	
  1313                              <1> .exit:
  1314 00002976 1F                  <1> 	pop ds
  1315 00002977 61                  <1> 	popa
  1316 00002978 CF                  <1> 	iret
  1317                              <1> 
  1318 00002979 0000<rep 9h>        <1> 	pwm_freq				times 9 dw 0
  1319 0000298B 0000<rep 9h>        <1> 	pwm_cntr				times 9 dw 0
  1320 0000299D 00                  <1> 	pwm_muted				db 0
  1321 0000299E 0000                <1> 	pwm_callback			dw 0
  1322 000029A0 0000                <1> 	pwm_callback_ctr		dw 0
  1323 000029A2 0000                <1> 	pwm_callback_ctr_def	dw 0
  1324 000029A4 00                  <1> 	pwm_val					db 0
  1325 000029A5 00                  <1> 	pwm_channel_amplitude	db 0
  1326 000029A6 0024120C0907060504- <1> 	pwm_fixed_amplitudes	db 0, 36, 18, 12, 9, 7, 6, 5, 4, 4
  1326 000029AF 04                  <1>
  1327                              <1> 	
  1328                              <1> ; ------------------------------------------------------------------
  1329                              <1> ; os_adlib_calcfreq -- Play a frequency
  1330                              <1> ; IN: AX - frequency, CL = channel; OUT: nothing
  1331                              <1> 
  1332                              <1> os_adlib_calcfreq:
  1333 000029B0 6660                <1> 	pushad
  1334                              <1> 
  1335 000029B2 803EEEDE01          <1> 	cmp byte [57070], 1
  1336 000029B7 7D54                <1> 	jge .pcspk
  1337                              <1> 
  1338 000029B9 880E[1B2A]          <1> 	mov [.channel], cl
  1339                              <1> 	
  1340 000029BD 660FB7C0            <1> 	movzx eax, ax
  1341 000029C1 B100                <1> 	mov cl, 0		; Block number
  1342                              <1> 	
  1343 000029C3 6650                <1> 	push eax
  1344                              <1> 
  1345                              <1> .block_loop:		; f-num = freq * 2^(20 - block) / 49716
  1346 000029C5 6658                <1> 	pop eax
  1347 000029C7 6650                <1> 	push eax
  1348                              <1> 	
  1349 000029C9 B314                <1> 	mov bl, 20
  1350 000029CB 28CB                <1> 	sub bl, cl
  1351                              <1> 	
  1352 000029CD 881E[D429]          <1> 	mov [.shift + 3], bl
  1353 000029D1 66C1E000            <1> .shift: db 0x66, 0xc1, 0xe0, 0		; shl eax, XX
  1354                              <1> 
  1355                              <1> 	clr edx
    14 000029D5 6631D2              <2>  xor %1, %1
  1356 000029D8 66BB34C20000        <1> 	mov ebx, 49716	; Divide by the sample rate
  1357 000029DE 66F7F3              <1> 	div ebx
  1358                              <1> 
  1359 000029E1 FEC1                <1> 	inc cl
  1360                              <1> 	
  1361 000029E3 3D0004              <1> 	cmp ax, 1024	; Is the result too large?
  1362 000029E6 7DDD                <1> 	jge .block_loop
  1363                              <1> 	
  1364 000029E8 FEC9                <1> 	dec cl
  1365                              <1> 	
  1366 000029EA C0E102              <1> 	shl cl, 2		; Write the block number
  1367 000029ED 00CC                <1> 	add ah, cl
  1368                              <1> 
  1369 000029EF 80CC20              <1> 	or ah, 20h		; Note on
  1370                              <1> 	
  1371 000029F2 50                  <1> 	push ax
  1372 000029F3 B4A0                <1> 	mov ah, 0A0h
  1373 000029F5 0226[1B2A]          <1> 	add ah, [.channel]
  1374 000029F9 E8F9FD              <1> 	call os_adlib_regwrite
  1375 000029FC 58                  <1> 	pop ax
  1376                              <1> 	
  1377 000029FD 88E0                <1> 	mov al, ah
  1378 000029FF B4B0                <1> 	mov ah, 0B0h
  1379 00002A01 0226[1B2A]          <1> 	add ah, [.channel]
  1380 00002A05 E8EDFD              <1> 	call os_adlib_regwrite
  1381                              <1> 	
  1382 00002A08 6658                <1> 	pop eax
  1383 00002A0A 6661                <1> 	popad
  1384 00002A0C C3                  <1> 	ret
  1385                              <1> 	
  1386                              <1> .pcspk:
  1387 00002A0D 0FB6D9              <1> 	movzx bx, cl
  1388 00002A10 D1E3                <1> 	shl bx, 1
  1389 00002A12 D1E0                <1> 	shl ax, 1
  1390 00002A14 8987[7929]          <1> 	mov [pwm_freq + bx], ax
  1391 00002A18 6661                <1> 	popad
  1392 00002A1A C3                  <1> 	ret
  1393                              <1> 	
  1394 00002A1B 00                  <1> 	.channel	db 0
  1395                              <1> 	
  1396                              <1> ; ------------------------------------------------------------------
  1397                              <1> ; os_adlib_noteoff -- Turns off a note
  1398                              <1> ; IN: CL = channel; OUT: nothing
  1399                              <1> 
  1400                              <1> os_adlib_noteoff:
  1401 00002A1C 803EEEDE01          <1> 	cmp byte [57070], 1
  1402 00002A21 7D0F                <1> 	jge .pcspk
  1403                              <1> 	
  1404 00002A23 60                  <1> 	pusha
  1405                              <1> 
  1406 00002A24 B4B0                <1> 	mov ah, 0B0h
  1407 00002A26 00CC                <1> 	add ah, cl
  1408 00002A28 E8D8FD              <1> 	call os_adlib_regread
  1409                              <1> 	
  1410 00002A2B 24DF                <1> 	and al, 11011111b
  1411 00002A2D E8C5FD              <1> 	call os_adlib_regwrite
  1412                              <1> 	
  1413 00002A30 61                  <1> 	popa
  1414 00002A31 C3                  <1> 	ret
  1415                              <1> 	
  1416                              <1> .pcspk:
  1417 00002A32 60                  <1> 	pusha
  1418 00002A33 0FB6D9              <1> 	movzx bx, cl
  1419 00002A36 D1E3                <1> 	shl bx, 1
  1420 00002A38 C787[7929]0000      <1> 	mov word [pwm_freq + bx], 0
  1421 00002A3E 61                  <1> 	popa
  1422 00002A3F C3                  <1> 	ret	
  1423                              <1> 	
  1424                              <1> ; ==================================================================
  1425                              <1> 
   821                                  	%INCLUDE "features/string.asm"
   822                              <1> ; ==================================================================
   823                              <1> ; STRING MANIPULATION ROUTINES
   824                              <1> ; ==================================================================
   825                              <1> 
   826                              <1> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   827                              <1> ; IN: SI = Input string/Output string
   828                              <1> 
   829                              <1> os_string_encrypt:
   830 00002A40 60                  <1> 	pusha
   831 00002A41 89F7                <1> 	mov di, si
   832                              <1> 
   833 00002A43 89F0                <1> 	mov ax, si
   834 00002A45 E82C00              <1> 	call os_string_length
   835 00002A48 C0E002              <1> 	shl al, 2
   836 00002A4B 347B                <1> 	xor al, 123
   837                              <1> 	
   838 00002A4D B17B                <1> 	mov cl, 123
   839 00002A4F 00C1                <1> 	add cl, al
   840 00002A51 80F1DB              <1> 	xor cl, 219
   841                              <1> 	
   842                              <1> .loop:
   843 00002A54 AC                  <1> 	lodsb
   844 00002A55 3C00                <1> 	cmp al, 0
   845 00002A57 740A                <1> 	je .exit
   846                              <1> 	
   847 00002A59 00C8                <1> 	add al, cl
   848 00002A5B 34AA                <1> 	xor al, 10101010b
   849 00002A5D AA                  <1> 	stosb
   850                              <1> 	
   851 00002A5E 80C14D              <1> 	add cl, 77
   852 00002A61 EBF1                <1> 	jmp .loop
   853                              <1> 	
   854                              <1> .exit:
   855 00002A63 61                  <1> 	popa
   856 00002A64 C3                  <1> 	ret
   857                              <1> 	
   858                              <1> ; os_string_add -- Add a string on top of another string
   859                              <1> ; IN: AX/BX = Main string/Added string
   860                              <1> 
   861                              <1> os_string_add:
   862 00002A65 60                  <1> 	pusha
   863 00002A66 50                  <1> 	push ax
   864 00002A67 E80A00              <1> 	call os_string_length		; Get the length of the main string
   865 00002A6A 5F                  <1> 	pop di
   866 00002A6B 01C7                <1> 	add di, ax					; Add it to the pointer
   867 00002A6D 89DE                <1> 	mov si, bx
   868 00002A6F E89500              <1>  	call os_string_copy			; Copy the string
   869 00002A72 61                  <1>  	popa
   870 00002A73 C3                  <1>  	ret
   871                              <1> 	
   872                              <1> ; ------------------------------------------------------------------
   873                              <1> ; os_string_length -- Return length of a string
   874                              <1> ; IN: AX = string location
   875                              <1> ; OUT AX = length (other regs preserved)
   876                              <1> 
   877                              <1> os_string_length:
   878 00002A74 60                  <1> 	pusha
   879                              <1> 
   880 00002A75 89C3                <1> 	mov bx, ax			; Move location of string to BX
   881                              <1> 
   882 00002A77 31C9                <1> 	xor cx, cx			; Counter
   883                              <1> 
   884                              <1> .more:
   885 00002A79 803F00              <1> 	cmp byte [bx], 0		; Zero (end of string) yet?
   886 00002A7C 7404                <1> 	je .done
   887 00002A7E 43                  <1> 	inc bx				; If not, keep adding
   888 00002A7F 41                  <1> 	inc cx
   889 00002A80 EBF7                <1> 	jmp .more
   890                              <1> 
   891                              <1> 
   892                              <1> .done:
   893 00002A82 890E[8B2A]          <1> 	mov word [.tmp_counter], cx	; Store count before restoring other registers
   894 00002A86 61                  <1> 	popa
   895                              <1> 
   896 00002A87 A1[8B2A]            <1> 	mov ax, [.tmp_counter]		; Put count back into AX before returning
   897 00002A8A C3                  <1> 	ret
   898                              <1> 
   899                              <1> 
   900 00002A8B 0000                <1> 	.tmp_counter	dw 0
   901                              <1> 
   902                              <1> 
   903                              <1> ; ------------------------------------------------------------------
   904                              <1> ; os_string_reverse -- Reverse the characters in a string
   905                              <1> ; IN: SI = string location
   906                              <1> 
   907                              <1> os_string_reverse:
   908 00002A8D 60                  <1> 	pusha
   909                              <1> 
   910 00002A8E 803C00              <1> 	cmp byte [si], 0		; Don't attempt to reverse empty string
   911 00002A91 7418                <1> 	je .end
   912                              <1> 
   913 00002A93 89F0                <1> 	mov ax, si
   914 00002A95 E8DCFF              <1> 	call os_string_length
   915                              <1> 
   916 00002A98 89F7                <1> 	mov di, si
   917 00002A9A 01C7                <1> 	add di, ax
   918 00002A9C 4F                  <1> 	dec di				; DI now points to last char in string
   919                              <1> 
   920                              <1> .loop:
   921 00002A9D 8A04                <1> 	mov byte al, [si]		; Swap bytes
   922 00002A9F 8A1D                <1> 	mov byte bl, [di]
   923                              <1> 
   924 00002AA1 881C                <1> 	mov byte [si], bl
   925 00002AA3 8805                <1> 	mov byte [di], al
   926                              <1> 
   927 00002AA5 46                  <1> 	inc si				; Move towards string centre
   928 00002AA6 4F                  <1> 	dec di
   929                              <1> 
   930 00002AA7 39F7                <1> 	cmp di, si			; Both reached the centre?
   931 00002AA9 77F2                <1> 	ja .loop
   932                              <1> 
   933                              <1> .end:
   934 00002AAB 61                  <1> 	popa
   935 00002AAC C3                  <1> 	ret
   936                              <1> 
   937                              <1> 
   938                              <1> ; ------------------------------------------------------------------
   939                              <1> ; os_find_char_in_string -- Find location of character in a string
   940                              <1> ; IN: SI = string location, AL = character to find
   941                              <1> ; OUT: AX = location in string, or 0 if char not present
   942                              <1> 
   943                              <1> os_find_char_in_string:
   944 00002AAD 60                  <1> 	pusha
   945                              <1> 
   946 00002AAE B90100              <1> 	mov cx, 1			; Counter -- start at first char (we count
   947                              <1> 					; from 1 in chars here, so that we can
   948                              <1> 					; return 0 if the source char isn't found)
   949                              <1> 
   950                              <1> .more:
   951 00002AB1 3804                <1> 	cmp byte [si], al
   952 00002AB3 7409                <1> 	je .done
   953 00002AB5 803C00              <1> 	cmp byte [si], 0
   954 00002AB8 740D                <1> 	je .notfound
   955 00002ABA 46                  <1> 	inc si
   956 00002ABB 41                  <1> 	inc cx
   957 00002ABC EBF3                <1> 	jmp .more
   958                              <1> 
   959                              <1> .done:
   960 00002ABE 890E[CB2A]          <1> 	mov [.tmp], cx
   961 00002AC2 61                  <1> 	popa
   962 00002AC3 A1[CB2A]            <1> 	mov ax, [.tmp]
   963 00002AC6 C3                  <1> 	ret
   964                              <1> 
   965                              <1> .notfound:
   966 00002AC7 61                  <1> 	popa
   967 00002AC8 31C0                <1> 	xor ax, ax
   968 00002ACA C3                  <1> 	ret
   969                              <1> 
   970                              <1> 
   971 00002ACB 0000                <1> 	.tmp	dw 0
   972                              <1> 
   973                              <1> 
   974                              <1> ; ------------------------------------------------------------------
   975                              <1> ; os_string_uppercase -- Convert zero-terminated string to upper case
   976                              <1> ; IN/OUT: AX = string location
   977                              <1> 
   978                              <1> os_string_uppercase:
   979 00002ACD 60                  <1> 	pusha
   980                              <1> 
   981 00002ACE 89C6                <1> 	mov si, ax			; Use SI to access string
   982                              <1> 
   983                              <1> .more:
   984 00002AD0 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   985 00002AD3 7413                <1> 	je .done			; If so, quit
   986                              <1> 
   987 00002AD5 803C61              <1> 	cmp byte [si], 'a'		; In the lower case A to Z range?
   988 00002AD8 720B                <1> 	jb .noatoz
   989 00002ADA 803C7A              <1> 	cmp byte [si], 'z'
   990 00002ADD 7706                <1> 	ja .noatoz
   991                              <1> 
   992 00002ADF 802C20              <1> 	sub byte [si], 20h		; If so, convert input char to upper case
   993                              <1> 
   994 00002AE2 46                  <1> 	inc si
   995 00002AE3 EBEB                <1> 	jmp .more
   996                              <1> 
   997                              <1> .noatoz:
   998 00002AE5 46                  <1> 	inc si
   999 00002AE6 EBE8                <1> 	jmp .more
  1000                              <1> 
  1001                              <1> .done:
  1002 00002AE8 61                  <1> 	popa
  1003 00002AE9 C3                  <1> 	ret
  1004                              <1> 
  1005                              <1> 
  1006                              <1> ; ------------------------------------------------------------------
  1007                              <1> ; os_string_lowercase -- Convert zero-terminated string to lower case
  1008                              <1> ; IN/OUT: AX = string location
  1009                              <1> 
  1010                              <1> os_string_lowercase:
  1011 00002AEA 60                  <1> 	pusha
  1012                              <1> 
  1013 00002AEB 89C6                <1> 	mov si, ax			; Use SI to access string
  1014                              <1> 
  1015                              <1> .more:
  1016 00002AED 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
  1017 00002AF0 7413                <1> 	je .done			; If so, quit
  1018                              <1> 
  1019 00002AF2 803C41              <1> 	cmp byte [si], 'A'		; In the upper case A to Z range?
  1020 00002AF5 720B                <1> 	jb .noatoz
  1021 00002AF7 803C5A              <1> 	cmp byte [si], 'Z'
  1022 00002AFA 7706                <1> 	ja .noatoz
  1023                              <1> 
  1024 00002AFC 800420              <1> 	add byte [si], 20h		; If so, convert input char to lower case
  1025                              <1> 
  1026 00002AFF 46                  <1> 	inc si
  1027 00002B00 EBEB                <1> 	jmp .more
  1028                              <1> 
  1029                              <1> .noatoz:
  1030 00002B02 46                  <1> 	inc si
  1031 00002B03 EBE8                <1> 	jmp .more
  1032                              <1> 
  1033                              <1> .done:
  1034 00002B05 61                  <1> 	popa
  1035 00002B06 C3                  <1> 	ret
  1036                              <1> 
  1037                              <1> 
  1038                              <1> ; ------------------------------------------------------------------
  1039                              <1> ; os_string_copy -- Copy one string into another
  1040                              <1> ; IN/OUT: SI = source, DI = destination (programmer ensure sufficient room)
  1041                              <1> 
  1042                              <1> os_string_copy:
  1043 00002B07 60                  <1> 	pusha
  1044                              <1> 
  1045                              <1> .more:
  1046 00002B08 AC                  <1> 	lodsb
  1047 00002B09 AA                  <1> 	stosb
  1048 00002B0A 3C00                <1> 	cmp byte al, 0			; If source string is empty, quit out
  1049 00002B0C 75FA                <1> 	jne .more
  1050 00002B0E 61                  <1> 	popa
  1051 00002B0F C3                  <1> 	ret
  1052                              <1> 
  1053                              <1> 
  1054                              <1> ; ------------------------------------------------------------------
  1055                              <1> ; os_string_join -- Join two strings into a third string
  1056                              <1> ; IN/OUT: AX = string one, BX = string two, CX = destination string
  1057                              <1> 
  1058                              <1> os_string_join:
  1059 00002B10 60                  <1> 	pusha
  1060                              <1> 
  1061 00002B11 89C6                <1> 	mov si, ax
  1062 00002B13 89CF                <1> 	mov di, cx
  1063 00002B15 E8EFFF              <1> 	call os_string_copy
  1064                              <1> 
  1065 00002B18 E859FF              <1> 	call os_string_length		; Get length of first string
  1066                              <1> 
  1067 00002B1B 01C1                <1> 	add cx, ax			; Position at end of first string
  1068                              <1> 
  1069 00002B1D 89DE                <1> 	mov si, bx			; Add second string onto it
  1070 00002B1F 89CF                <1> 	mov di, cx
  1071 00002B21 E8E3FF              <1> 	call os_string_copy
  1072                              <1> 
  1073 00002B24 61                  <1> 	popa
  1074 00002B25 C3                  <1> 	ret
  1075                              <1> 
  1076                              <1> 
  1077                              <1> ; ------------------------------------------------------------------
  1078                              <1> ; os_string_chomp -- Strip leading and trailing spaces from a string
  1079                              <1> ; IN: AX = string location
  1080                              <1> 
  1081                              <1> os_string_chomp:
  1082 00002B26 60                  <1> 	pusha
  1083                              <1> 
  1084 00002B27 89C2                <1> 	mov dx, ax			; Save string location
  1085                              <1> 
  1086 00002B29 89C7                <1> 	mov di, ax			; Put location into DI
  1087 00002B2B 31C9                <1> 	xor cx, cx			; Space counter
  1088                              <1> 
  1089                              <1> .keepcounting:				; Get number of leading spaces into BX
  1090 00002B2D 803D20              <1> 	cmp byte [di], ' '
  1091 00002B30 7504                <1> 	jne .counted
  1092 00002B32 41                  <1> 	inc cx
  1093 00002B33 47                  <1> 	inc di
  1094 00002B34 EBF7                <1> 	jmp .keepcounting
  1095                              <1> 
  1096                              <1> .counted:
  1097 00002B36 83F900              <1> 	cmp cx, 0			; No leading spaces?
  1098 00002B39 7410                <1> 	je .finished_copy
  1099                              <1> 
  1100 00002B3B 89FE                <1> 	mov si, di			; Address of first non-space character
  1101 00002B3D 89D7                <1> 	mov di, dx			; DI = original string start
  1102                              <1> 
  1103                              <1> .keep_copying:
  1104 00002B3F 8A04                <1> 	mov al, [si]			; Copy SI into DI
  1105 00002B41 8805                <1> 	mov [di], al			; Including terminator
  1106 00002B43 3C00                <1> 	cmp al, 0
  1107 00002B45 7404                <1> 	je .finished_copy
  1108 00002B47 46                  <1> 	inc si
  1109 00002B48 47                  <1> 	inc di
  1110 00002B49 EBF4                <1> 	jmp .keep_copying
  1111                              <1> 
  1112                              <1> .finished_copy:
  1113 00002B4B 89D0                <1> 	mov ax, dx			; AX = original string start
  1114                              <1> 
  1115 00002B4D E824FF              <1> 	call os_string_length
  1116 00002B50 83F800              <1> 	cmp ax, 0			; If empty or all blank, done, return 'null'
  1117 00002B53 740F                <1> 	je .done
  1118                              <1> 
  1119 00002B55 89D6                <1> 	mov si, dx
  1120 00002B57 01C6                <1> 	add si, ax			; Move to end of string
  1121                              <1> 
  1122                              <1> .more:
  1123 00002B59 4E                  <1> 	dec si
  1124 00002B5A 803C20              <1> 	cmp byte [si], ' '
  1125 00002B5D 7505                <1> 	jne .done
  1126 00002B5F C60400              <1> 	mov byte [si], 0		; Fill end spaces with 0s
  1127 00002B62 EBF5                <1> 	jmp .more			; (First 0 will be the string terminator)
  1128                              <1> 
  1129                              <1> .done:
  1130 00002B64 61                  <1> 	popa
  1131 00002B65 C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> 
  1134                              <1> ; ------------------------------------------------------------------
  1135                              <1> ; os_string_compare -- See if two strings match
  1136                              <1> ; IN: SI = string one, DI = string two
  1137                              <1> ; OUT: carry set if same, clear if different
  1138                              <1> 
  1139                              <1> os_string_compare:
  1140 00002B66 60                  <1> 	pusha
  1141                              <1> 
  1142                              <1> .more:
  1143 00002B67 8A04                <1> 	mov al, [si]			; Retrieve string contents
  1144 00002B69 8A1D                <1> 	mov bl, [di]
  1145                              <1> 
  1146 00002B6B 38D8                <1> 	cmp al, bl			; Compare characters at current location
  1147 00002B6D 7508                <1> 	jne .not_same
  1148                              <1> 
  1149 00002B6F 3C00                <1> 	cmp al, 0			; End of first string? Must also be end of second
  1150 00002B71 7407                <1> 	je .terminated
  1151                              <1> 
  1152 00002B73 46                  <1> 	inc si
  1153 00002B74 47                  <1> 	inc di
  1154 00002B75 EBF0                <1> 	jmp .more
  1155                              <1> 
  1156                              <1> 
  1157                              <1> .not_same:				; If unequal lengths with same beginning, the byte
  1158 00002B77 61                  <1> 	popa				; comparison fails at shortest string terminator
  1159 00002B78 F8                  <1> 	clc				; Clear carry flag
  1160 00002B79 C3                  <1> 	ret
  1161                              <1> 
  1162                              <1> 
  1163                              <1> .terminated:				; Both strings terminated at the same position
  1164 00002B7A 61                  <1> 	popa
  1165 00002B7B F9                  <1> 	stc				; Set carry flag
  1166 00002B7C C3                  <1> 	ret
  1167                              <1> 
  1168                              <1> 
  1169                              <1> ; ------------------------------------------------------------------
  1170                              <1> ; os_string_parse -- Take string (eg "run foo bar baz") and return
  1171                              <1> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
  1172                              <1> ; IN: SI = string; OUT: AX, BX, CX, DX = individual strings
  1173                              <1> 
  1174                              <1> os_string_parse:
  1175 00002B7D 56                  <1> 	push si
  1176                              <1> 
  1177 00002B7E 89F0                <1> 	mov ax, si			; AX = start of first string
  1178                              <1> 
  1179 00002B80 31DB                <1> 	xor bx, bx			; By default, other strings start empty
  1180 00002B82 31C9                <1> 	xor cx, cx
  1181 00002B84 31D2                <1> 	xor dx, dx
  1182                              <1> 
  1183 00002B86 50                  <1> 	push ax				; Save to retrieve at end
  1184                              <1> 
  1185                              <1> .loop1:
  1186 00002B87 AC                  <1> 	lodsb				; Get a byte
  1187 00002B88 3C00                <1> 	cmp al, 0			; End of string?
  1188 00002B8A 742B                <1> 	je .finish
  1189 00002B8C 3C20                <1> 	cmp al, ' '			; A space?
  1190 00002B8E 75F7                <1> 	jne .loop1
  1191 00002B90 4E                  <1> 	dec si
  1192 00002B91 C60400              <1> 	mov byte [si], 0		; If so, zero-terminate this bit of the string
  1193                              <1> 
  1194 00002B94 46                  <1> 	inc si				; Store start of next string in BX
  1195 00002B95 89F3                <1> 	mov bx, si
  1196                              <1> 
  1197                              <1> .loop2:					; Repeat the above for CX and DX...
  1198 00002B97 AC                  <1> 	lodsb
  1199 00002B98 3C00                <1> 	cmp al, 0
  1200 00002B9A 741B                <1> 	je .finish
  1201 00002B9C 3C20                <1> 	cmp al, ' '
  1202 00002B9E 75F7                <1> 	jne .loop2
  1203 00002BA0 4E                  <1> 	dec si
  1204 00002BA1 C60400              <1> 	mov byte [si], 0
  1205                              <1> 
  1206 00002BA4 46                  <1> 	inc si
  1207 00002BA5 89F1                <1> 	mov cx, si
  1208                              <1> 
  1209                              <1> .loop3:
  1210 00002BA7 AC                  <1> 	lodsb
  1211 00002BA8 3C00                <1> 	cmp al, 0
  1212 00002BAA 740B                <1> 	je .finish
  1213 00002BAC 3C20                <1> 	cmp al, ' '
  1214 00002BAE 75F7                <1> 	jne .loop3
  1215 00002BB0 4E                  <1> 	dec si
  1216 00002BB1 C60400              <1> 	mov byte [si], 0
  1217                              <1> 
  1218 00002BB4 46                  <1> 	inc si
  1219 00002BB5 89F2                <1> 	mov dx, si
  1220                              <1> 
  1221                              <1> .finish:
  1222 00002BB7 58                  <1> 	pop ax
  1223                              <1> 
  1224 00002BB8 5E                  <1> 	pop si
  1225 00002BB9 C3                  <1> 	ret
  1226                              <1> 
  1227                              <1> 
  1228                              <1> ; ------------------------------------------------------------------
  1229                              <1> ; os_string_to_int -- Convert decimal string to integer value
  1230                              <1> ; IN: SI = string location (max 5 chars, up to '65535')
  1231                              <1> ; OUT: AX = number
  1232                              <1> 
  1233                              <1> os_string_to_int:
  1234 00002BBA E88E01              <1> 	call os_string_to_32int		; This function only exists for compatibility reasons
  1235 00002BBD C3                  <1> 	ret
  1236                              <1> 
  1237                              <1> ; ------------------------------------------------------------------
  1238                              <1> ; os_string_to_hex -- Convert hexadecimal string to integer value
  1239                              <1> ; IN: SI = string location (max 8 chars, up to 'FFFFFFFF')
  1240                              <1> ; OUT: EAX = number
  1241                              <1> 
  1242                              <1> os_string_to_hex:
  1243 00002BBE 6660                <1> 	pushad
  1244                              <1> 	
  1245 00002BC0 89F0                <1> 	mov ax, si			; First, uppercase the string
  1246 00002BC2 E808FF              <1> 	call os_string_uppercase
  1247                              <1> 
  1248 00002BC5 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1249                              <1> 	
  1250                              <1> .loop:
  1251 00002BC8 6650                <1> 	push eax
  1252 00002BCA AC                  <1> 	lodsb					; Load a byte from SI
  1253 00002BCB 88C1                <1> 	mov cl, al
  1254 00002BCD 6658                <1> 	pop eax
  1255 00002BCF 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1256 00002BD2 0F842000            <1> 	je near .exit			; If we have, exit
  1257                              <1> 	
  1258 00002BD6 80F939              <1> 	cmp cl, '9'
  1259 00002BD9 7E03                <1> 	jle .no_change
  1260                              <1> 	
  1261 00002BDB 80E907              <1> 	sub cl, 7
  1262                              <1> 	
  1263                              <1> .no_change:
  1264 00002BDE 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1265 00002BE1 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1266 00002BE8 66BB10000000        <1> 	mov ebx, 16 
  1267 00002BEE 66F7E3              <1> 	mul ebx					; Multiply EAX by 16
  1268 00002BF1 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1269 00002BF4 EBD2                <1> 	jmp .loop				; Loop again
  1270                              <1> 	
  1271                              <1> .exit:
  1272 00002BF6 66A3[012C]          <1> 	mov [.tmp_dword], eax
  1273 00002BFA 6661                <1> 	popad
  1274 00002BFC 66A1[012C]          <1> 	mov eax, [.tmp_dword]
  1275 00002C00 C3                  <1> 	ret
  1276                              <1> 	
  1277 00002C01 00000000            <1> 	.tmp_dword	dd 0
  1278                              <1> 
  1279                              <1> ; ------------------------------------------------------------------
  1280                              <1> ; os_int_to_string -- Convert unsigned integer to string
  1281                              <1> ; IN: AX = unsigned int
  1282                              <1> ; OUT: AX = string location
  1283                              <1> 
  1284                              <1> os_int_to_string:
  1285 00002C05 60                  <1> 	pusha
  1286                              <1> 
  1287 00002C06 31C9                <1> 	xor cx, cx
  1288 00002C08 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1289 00002C0B BF[2C2C]            <1> 	mov di, .t			; Get our pointer ready
  1290                              <1> 
  1291                              <1> .push:
  1292 00002C0E 31D2                <1> 	xor dx, dx
  1293 00002C10 F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1294 00002C12 41                  <1> 	inc cx				; Increase pop loop counter
  1295 00002C13 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1296 00002C14 85C0                <1> 	test ax, ax			; Is quotient zero?
  1297 00002C16 75F6                <1> 	jnz .push			; If not, loop again
  1298                              <1> .pop:
  1299 00002C18 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1300 00002C19 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1301 00002C1C 2E8815              <1> 	mov [cs:di], dl
  1302 00002C1F 47                  <1> 	inc di
  1303 00002C20 49                  <1> 	dec cx
  1304 00002C21 75F5                <1> 	jnz .pop
  1305                              <1> 
  1306 00002C23 2EC60500            <1> 	mov byte [cs:di], 0		; Zero-terminate string
  1307                              <1> 
  1308 00002C27 61                  <1> 	popa
  1309 00002C28 B8[2C2C]            <1> 	mov ax, .t			; Return location of string
  1310 00002C2B C3                  <1> 	ret
  1311                              <1> 
  1312                              <1> 
  1313 00002C2C 00<rep 7h>          <1> 	.t times 7 db 0
  1314                              <1> 
  1315                              <1> 
  1316                              <1> ; ------------------------------------------------------------------
  1317                              <1> ; os_sint_to_string -- Convert signed integer to string
  1318                              <1> ; IN: AX = signed int
  1319                              <1> ; OUT: AX = string location
  1320                              <1> 
  1321                              <1> os_sint_to_string:
  1322 00002C33 60                  <1> 	pusha
  1323                              <1> 
  1324 00002C34 31C9                <1> 	xor cx, cx
  1325 00002C36 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1326 00002C39 BF[662C]            <1> 	mov di, .t			; Get our pointer ready
  1327                              <1> 
  1328 00002C3C 85C0                <1> 	test ax, ax			; Find out if X > 0 or not, force a sign
  1329 00002C3E 7802                <1> 	js .neg				; If negative...
  1330 00002C40 EB08                <1> 	jmp .push			; ...or if positive
  1331                              <1> .neg:
  1332 00002C42 F7D8                <1> 	neg ax				; Make AX positive
  1333 00002C44 C606[662C]2D        <1> 	mov byte [.t], '-'		; Add a minus sign to our string
  1334 00002C49 47                  <1> 	inc di				; Update the index
  1335                              <1> .push:
  1336 00002C4A 31D2                <1> 	xor dx, dx
  1337 00002C4C F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1338 00002C4E 41                  <1> 	inc cx				; Increase pop loop counter
  1339 00002C4F 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1340 00002C50 85C0                <1> 	test ax, ax			; Is quotient zero?
  1341 00002C52 75F6                <1> 	jnz .push			; If not, loop again
  1342                              <1> .pop:
  1343 00002C54 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1344 00002C55 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1345 00002C58 8815                <1> 	mov [di], dl
  1346 00002C5A 47                  <1> 	inc di
  1347 00002C5B 49                  <1> 	dec cx
  1348 00002C5C 75F6                <1> 	jnz .pop
  1349                              <1> 
  1350 00002C5E C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1351                              <1> 
  1352 00002C61 61                  <1> 	popa
  1353 00002C62 B8[662C]            <1> 	mov ax, .t			; Return location of string
  1354 00002C65 C3                  <1> 	ret
  1355                              <1> 
  1356                              <1> 
  1357 00002C66 00<rep 7h>          <1> 	.t times 7 db 0
  1358                              <1> 
  1359                              <1> ; ------------------------------------------------------------------
  1360                              <1> ; os_get_time_string -- Get current time in a string (eg '10:25')
  1361                              <1> ; IN/OUT: BX = string location
  1362                              <1> 
  1363                              <1> os_get_time_string:
  1364 00002C6D 60                  <1> 	pusha
  1365                              <1> 	
  1366 00002C6E 89DF                <1> 	mov di, bx			; Location to place the string
  1367                              <1> 
  1368 00002C70 B402                <1> 	mov ah, 02h			; Get the current time
  1369 00002C72 E805EB              <1> 	call os_int_1Ah
  1370                              <1> 	
  1371 00002C75 723B                <1> 	jc .exit
  1372                              <1> 
  1373 00002C77 51                  <1> 	push cx	
  1374                              <1> 
  1375 00002C78 88E8                <1> 	mov al, ch
  1376 00002C7A E843E8              <1> 	call os_bcd_to_int
  1377 00002C7D 83F80A              <1> 	cmp ax, 10
  1378 00002C80 7D05                <1> 	jge .hour_10
  1379                              <1> 	
  1380 00002C82 50                  <1> 	push ax
  1381 00002C83 B030                <1> 	mov al, '0'
  1382 00002C85 AA                  <1> 	stosb
  1383 00002C86 58                  <1> 	pop ax
  1384                              <1> 	
  1385                              <1> .hour_10:
  1386 00002C87 E87BFF              <1> 	call os_int_to_string
  1387 00002C8A 89C6                <1> 	mov si, ax
  1388                              <1> 	
  1389                              <1> .hour_loop:	
  1390 00002C8C AC                  <1> 	lodsb
  1391 00002C8D 3C00                <1> 	cmp al, 0
  1392 00002C8F 7403                <1> 	je .hour_loop_end
  1393 00002C91 AA                  <1> 	stosb
  1394 00002C92 EBF8                <1> 	jmp .hour_loop
  1395                              <1> 	
  1396                              <1> .hour_loop_end:
  1397 00002C94 B03A                <1> 	mov al, ':'			; Insert the time separator (or whatever it's called)
  1398 00002C96 AA                  <1> 	stosb
  1399                              <1> 		
  1400 00002C97 59                  <1> 	pop cx
  1401 00002C98 88C8                <1> 	mov al, cl
  1402 00002C9A E823E8              <1> 	call os_bcd_to_int
  1403 00002C9D 83F80A              <1> 	cmp ax, 10
  1404 00002CA0 7D05                <1> 	jge .minute_10
  1405                              <1> 	
  1406 00002CA2 50                  <1> 	push ax
  1407 00002CA3 B030                <1> 	mov al, '0'
  1408 00002CA5 AA                  <1> 	stosb
  1409 00002CA6 58                  <1> 	pop ax
  1410                              <1> 	
  1411                              <1> .minute_10:
  1412 00002CA7 E85BFF              <1> 	call os_int_to_string
  1413 00002CAA 89C6                <1> 	mov si, ax
  1414                              <1> 		
  1415                              <1> .minute_loop:	
  1416 00002CAC AC                  <1> 	lodsb
  1417 00002CAD AA                  <1> 	stosb
  1418                              <1> 	
  1419 00002CAE 3C00                <1> 	cmp al, 0
  1420 00002CB0 75FA                <1> 	jne .minute_loop
  1421                              <1> 
  1422                              <1> .exit:
  1423 00002CB2 61                  <1> 	popa
  1424 00002CB3 C3                  <1> 	ret
  1425                              <1> 
  1426                              <1> ; ------------------------------------------------------------------
  1427                              <1> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
  1428                              <1> ; IN/OUT: BX = string location
  1429                              <1> 
  1430                              <1> os_get_date_string:
  1431 00002CB4 60                  <1> 	pusha
  1432                              <1> 
  1433 00002CB5 89DF                <1> 	mov di, bx
  1434                              <1> 	
  1435 00002CB7 F8                  <1> 	clc				; For buggy BIOSes
  1436 00002CB8 B404                <1> 	mov ah, 4			; Get date data from BIOS in BCD format
  1437 00002CBA E8BDEA              <1> 	call os_int_1Ah
  1438 00002CBD 7306                <1> 	jnc .fmt1_day
  1439                              <1> 
  1440 00002CBF F8                  <1> 	clc
  1441 00002CC0 B404                <1> 	mov ah, 4			; BIOS was updating (~1 in 500 chance), so try again
  1442 00002CC2 E8B5EA              <1> 	call os_int_1Ah
  1443                              <1> 
  1444                              <1> .fmt1_day:
  1445 00002CC5 88D4                <1> 	mov ah, dl			; Day
  1446 00002CC7 E81A00              <1> 	call .add_2digits
  1447                              <1> 
  1448 00002CCA B02F                <1> 	mov al, '/'
  1449 00002CCC AA                  <1> 	stosb				; Day-month separator
  1450                              <1> 
  1451                              <1> .fmt1_month:
  1452 00002CCD 88F4                <1> 	mov ah,	dh			; Month
  1453 00002CCF E81200              <1> 	call .add_2digits
  1454                              <1> 
  1455 00002CD2 B02F                <1> 	mov al, '/'
  1456 00002CD4 AA                  <1> 	stosb
  1457                              <1> 
  1458                              <1> .fmt1_century:
  1459 00002CD5 88EC                <1> 	mov ah,	ch			; Century
  1460 00002CD7 E80A00              <1> 	call .add_2digits
  1461                              <1> 
  1462                              <1> .fmt1_year:
  1463 00002CDA 88CC                <1> 	mov ah, cl			; Year
  1464 00002CDC E80500              <1> 	call .add_2digits
  1465                              <1> 
  1466 00002CDF B000                <1> 	mov al, 0			; Terminate date string
  1467 00002CE1 AA                  <1> 	stosb
  1468                              <1> 
  1469 00002CE2 61                  <1> 	popa
  1470 00002CE3 C3                  <1> 	ret
  1471                              <1> 
  1472                              <1> .add_2digits:
  1473 00002CE4 88E0                <1> 	mov al, ah			; Convert AH to 2 ASCII digits
  1474 00002CE6 C0E804              <1> 	shr al, 4
  1475 00002CE9 E80800              <1> 	call .add_digit
  1476 00002CEC 88E0                <1> 	mov al, ah
  1477 00002CEE 240F                <1> 	and al, 0Fh
  1478 00002CF0 E80100              <1> 	call .add_digit
  1479 00002CF3 C3                  <1> 	ret
  1480                              <1> 
  1481                              <1> .add_digit:
  1482 00002CF4 0430                <1> 	add al, '0'			; Convert AL to ASCII
  1483 00002CF6 AA                  <1> 	stosb				; Put into string buffer
  1484 00002CF7 C3                  <1> 	ret
  1485                              <1> 	
  1486                              <1> 	
  1487                              <1> ; ------------------------------------------------------------------
  1488                              <1> ; os_string_tokenize -- Reads tokens separated by specified char from
  1489                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1490                              <1> ; IN: AL = separator char, SI = beginning; OUT: DI = next token or 0 if none
  1491                              <1> 
  1492                              <1> os_string_tokenize:
  1493 00002CF8 56                  <1> 	push si
  1494                              <1> 
  1495                              <1> .next_char:
  1496 00002CF9 3804                <1> 	cmp byte [si], al
  1497 00002CFB 7408                <1> 	je .return_token
  1498 00002CFD 803C00              <1> 	cmp byte [si], 0
  1499 00002D00 740B                <1> 	jz .no_more
  1500 00002D02 46                  <1> 	inc si
  1501 00002D03 EBF4                <1> 	jmp .next_char
  1502                              <1> 
  1503                              <1> .return_token:
  1504 00002D05 C60400              <1> 	mov byte [si], 0
  1505 00002D08 46                  <1> 	inc si
  1506 00002D09 89F7                <1> 	mov di, si
  1507 00002D0B 5E                  <1> 	pop si
  1508 00002D0C C3                  <1> 	ret
  1509                              <1> 
  1510                              <1> .no_more:
  1511 00002D0D 31FF                <1> 	xor di, di
  1512 00002D0F 5E                  <1> 	pop si
  1513 00002D10 C3                  <1> 	ret
  1514                              <1> 
  1515                              <1> ; Converts an unsigned 32-bit integer into a string.
  1516                              <1> ; IN: EAX = unsigned int
  1517                              <1> ; OUT: AX = string location
  1518                              <1> 
  1519                              <1> os_32int_to_string:
  1520 00002D11 6660                <1> 	pushad
  1521                              <1> 
  1522 00002D13 31C9                <1> 	xor cx, cx
  1523 00002D15 66BB0A000000        <1> 	mov ebx, 10			; Set BX 10, for division and mod
  1524 00002D1B BF[402D]            <1> 	mov di, .t			; Get our pointer ready
  1525                              <1> 
  1526                              <1> .push:
  1527 00002D1E 6631D2              <1> 	xor edx, edx
  1528 00002D21 66F7F3              <1> 	div ebx				; Remainder in DX, quotient in AX
  1529 00002D24 41                  <1> 	inc cx				; Increase pop loop counter
  1530 00002D25 6652                <1> 	push edx			; Push remainder, so as to reverse order when popping
  1531 00002D27 6685C0              <1> 	test eax, eax		; Is quotient zero?
  1532 00002D2A 75F2                <1> 	jnz .push			; If not, loop again
  1533                              <1> 
  1534                              <1> .pop:
  1535 00002D2C 665A                <1> 	pop edx				; Pop off values in reverse order, and add 48 to make them digits
  1536 00002D2E 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1537 00002D31 8815                <1> 	mov [di], dl
  1538 00002D33 47                  <1> 	inc di
  1539 00002D34 49                  <1> 	dec cx
  1540 00002D35 75F5                <1> 	jnz .pop
  1541                              <1> 
  1542 00002D37 C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1543                              <1> 
  1544 00002D3A 6661                <1> 	popad
  1545 00002D3C B8[402D]            <1> 	mov ax, .t			; Return location of string
  1546 00002D3F C3                  <1> 	ret
  1547                              <1> 
  1548                              <1> 
  1549 00002D40 00<rep Bh>          <1> 	.t times 11 db 0
  1550                              <1> 
  1551                              <1> ; Converts a string into a 32-bit integer.
  1552                              <1> ; IN: SI = string location
  1553                              <1> ; OUT: EAX = unsigned integer
  1554                              <1> 
  1555                              <1> os_string_to_32int:
  1556 00002D4B 6660                <1> 	pushad
  1557 00002D4D 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1558                              <1> 	
  1559                              <1> .loop:
  1560 00002D50 6650                <1> 	push eax
  1561 00002D52 AC                  <1> 	lodsb					; Load a byte from SI
  1562 00002D53 88C1                <1> 	mov cl, al
  1563 00002D55 6658                <1> 	pop eax
  1564 00002D57 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1565 00002D5A 0F841400            <1> 	je near .exit			; If we have, exit
  1566 00002D5E 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1567 00002D61 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1568 00002D68 66F726[812D]        <1> 	mul dword [.divisor]	; Multiply EAX by 10
  1569 00002D6D 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1570 00002D70 EBDE                <1> 	jmp .loop				; Loop again
  1571                              <1> 	
  1572                              <1> .exit:
  1573 00002D72 66A3[7D2D]          <1> 	mov [.tmp_dword], eax
  1574 00002D76 6661                <1> 	popad
  1575 00002D78 66A1[7D2D]          <1> 	mov eax, [.tmp_dword]
  1576 00002D7C C3                  <1> 	ret
  1577                              <1> 	
  1578 00002D7D 00000000            <1> 	.tmp_dword	dd 0
  1579 00002D81 0A000000            <1> 	.divisor	dd 10
  1580                              <1> 	
  1581                              <1> ; Prints a 32 bit integer in decimal.
  1582                              <1> ; IN: EAX = unsigned integer
  1583                              <1> ; OUT: nothing
  1584                              <1> 
  1585                              <1> os_print_32int:
  1586 00002D85 6660                <1> 	pushad
  1587 00002D87 E887FF              <1> 	call os_32int_to_string
  1588 00002D8A 89C6                <1> 	mov si, ax
  1589 00002D8C E827EB              <1> 	call os_print_string
  1590 00002D8F 6661                <1> 	popad
  1591 00002D91 C3                  <1> 	ret
  1592                              <1> 	
  1593                              <1> ; ==================================================================
  1594                              <1> 
   822                                  	%INCLUDE "features/basic.asm"
   823                              <1> ; ==================================================================
   824                              <1> ; BASIC CODE INTERPRETER (4.5)
   825                              <1> ; ==================================================================
   826                              <1> 
   827                              <1> ; ------------------------------------------------------------------
   828                              <1> ; Token types
   829                              <1> 
   830                              <1> %DEFINE VARIABLE 1
   831                              <1> %DEFINE STRING_VAR 2
   832                              <1> %DEFINE NUMBER 3
   833                              <1> %DEFINE STRING 4
   834                              <1> %DEFINE QUOTE 5
   835                              <1> %DEFINE CHAR 6
   836                              <1> %DEFINE UNKNOWN 7
   837                              <1> %DEFINE LABEL 8
   838                              <1> 
   839                              <1> ; ------------------------------------------------------------------
   840                              <1> ; The BASIC interpreter execution starts here -- a parameter string
   841                              <1> ; is passed in SI and copied into the first string, unless SI = 0
   842                              <1> 
   843                              <1> os_run_basic:
   844 00002D92 C606820001          <1> 	mov byte [0082h], 1
   845                              <1> 	
   846 00002D97 8926[A946]          <1> 	mov word [orig_stack], sp		; Save stack pointer -- we might jump to the
   847                              <1> 						; error printing code and quit in the middle
   848                              <1> 						; some nested loops, and we want to preserve
   849                              <1> 						; the stack
   850                              <1> 
   851 00002D9B A3[AF46]            <1> 	mov word [load_point], ax		; AX was passed as starting location of code
   852                              <1> 
   853 00002D9E A3[AB46]            <1> 	mov word [prog], ax			; prog = pointer to current execution point in code
   854                              <1> 
   855 00002DA1 01C3                <1> 	add bx, ax				; We were passed the .BAS byte size in BX
   856 00002DA3 4B                  <1> 	dec bx
   857 00002DA4 4B                  <1> 	dec bx
   858 00002DA5 891E[AD46]          <1> 	mov word [prog_end], bx			; Make note of program end point
   859                              <1> 
   860                              <1> 
   861 00002DA9 E81D02              <1> 	call clear_ram				; Clear variables etc. from previous run
   862                              <1> 						; of a BASIC program
   863                              <1> 
   864 00002DAC 83FE00              <1> 	cmp si, 0				; Passed a parameter string?
   865 00002DAF 7406                <1> 	je mainloop
   866                              <1> 
   867 00002DB1 BF007C              <1> 	mov di, string_vars			; If so, copy it into $1
   868 00002DB4 E850FD              <1> 	call os_string_copy
   869                              <1> 
   870                              <1> 
   871                              <1> 
   872                              <1> mainloop:
   873 00002DB7 E86D17              <1> 	call get_token				; Get a token from the start of the line
   874                              <1> 
   875 00002DBA 83F804              <1> 	cmp ax, STRING				; Is the type a string of characters?
   876 00002DBD 7418                <1> 	je .keyword				; If so, let's see if it's a keyword to process
   877                              <1> 
   878 00002DBF 83F801              <1> 	cmp ax, VARIABLE			; If it's a variable at the start of the line,
   879 00002DC2 0F844702            <1> 	je near assign				; this is an assign (eg "X = Y + 5")
   880                              <1> 
   881 00002DC6 83F802              <1> 	cmp ax, STRING_VAR			; Same for a string variable (eg $1)
   882 00002DC9 0F844002            <1> 	je near assign
   883                              <1> 
   884 00002DCD 83F808              <1> 	cmp ax, LABEL				; Don't need to do anything here - skip
   885 00002DD0 74E5                <1> 	je mainloop
   886                              <1> 
   887 00002DD2 B314                <1> 	mov bl, err_syntax			; Otherwise show an error and quit
   888 00002DD4 E96918              <1> 	jmp error
   889                              <1> 
   890                              <1> 
   891                              <1> .keyword:
   892 00002DD7 BE007B              <1> 	mov si, token				; Start trying to match commands
   893                              <1> 
   894 00002DDA BF[B746]            <1> 	mov di, alert_cmd
   895 00002DDD E886FD              <1> 	call os_string_compare
   896 00002DE0 0F82CD04            <1> 	jc near do_alert
   897                              <1> 
   898 00002DE4 BF[BD46]            <1> 	mov di, askfile_cmd
   899 00002DE7 E87CFD              <1> 	call os_string_compare
   900 00002DEA 0F820005            <1> 	jc near do_askfile
   901                              <1> 
   902 00002DEE BF[C546]            <1> 	mov di, break_cmd
   903 00002DF1 E872FD              <1> 	call os_string_compare
   904 00002DF4 0F823105            <1> 	jc near do_break
   905                              <1> 
   906 00002DF8 BF[D046]            <1> 	mov di, case_cmd
   907 00002DFB E868FD              <1> 	call os_string_compare
   908 00002DFE 0F825305            <1> 	jc near do_case
   909                              <1> 
   910 00002E02 BF[CB46]            <1> 	mov di, call_cmd
   911 00002E05 E85EFD              <1> 	call os_string_compare
   912 00002E08 0F822205            <1> 	jc near do_call
   913                              <1> 
   914 00002E0C BF[D546]            <1> 	mov di, cls_cmd
   915 00002E0F E854FD              <1> 	call os_string_compare
   916 00002E12 0F829105            <1> 	jc near do_cls
   917                              <1> 
   918 00002E16 BF[D946]            <1> 	mov di, cursor_cmd
   919 00002E19 E84AFD              <1> 	call os_string_compare
   920 00002E1C 0F829B05            <1> 	jc near do_cursor
   921                              <1> 
   922 00002E20 BF[E046]            <1> 	mov di, curschar_cmd
   923 00002E23 E840FD              <1> 	call os_string_compare
   924 00002E26 0F82C205            <1> 	jc near do_curschar
   925                              <1> 
   926 00002E2A BF[E946]            <1> 	mov di, curscol_cmd
   927 00002E2D E836FD              <1> 	call os_string_compare
   928 00002E30 0F82E005            <1> 	jc near do_curscol
   929                              <1> 
   930 00002E34 BF[F146]            <1> 	mov di, curspos_cmd
   931 00002E37 E82CFD              <1> 	call os_string_compare
   932 00002E3A 0F82FE05            <1> 	jc near do_curspos
   933                              <1> 	
   934 00002E3E BF[F946]            <1> 	mov di, delete_cmd
   935 00002E41 E822FD              <1> 	call os_string_compare
   936 00002E44 0F822C06            <1> 	jc near do_delete
   937                              <1> 	
   938 00002E48 BF[0047]            <1> 	mov di, do_cmd
   939 00002E4B E818FD              <1> 	call os_string_compare
   940 00002E4E 0F827906            <1> 	jc near do_do
   941                              <1> 
   942 00002E52 BF[0847]            <1> 	mov di, end_cmd
   943 00002E55 E80EFD              <1> 	call os_string_compare
   944 00002E58 0F82B606            <1> 	jc near do_end
   945                              <1> 
   946 00002E5C BF[0347]            <1> 	mov di, else_cmd
   947 00002E5F E804FD              <1> 	call os_string_compare
   948 00002E62 0F828D06            <1> 	jc near do_else
   949                              <1> 
   950 00002E66 BF[0C47]            <1> 	mov di, files_cmd
   951 00002E69 E8FAFC              <1> 	call os_string_compare
   952 00002E6C 0F82B706            <1> 	jc near do_files
   953                              <1> 
   954 00002E70 BF[1247]            <1> 	mov di, for_cmd
   955 00002E73 E8F0FC              <1> 	call os_string_compare
   956 00002E76 0F821107            <1> 	jc near do_for
   957                              <1> 
   958 00002E7A BF[2147]            <1> 	mov di, getkey_cmd
   959 00002E7D E8E6FC              <1> 	call os_string_compare
   960 00002E80 0F82B507            <1> 	jc near do_getkey
   961                              <1> 
   962 00002E84 BF[1647]            <1> 	mov di, gosub_cmd
   963 00002E87 E8DCFC              <1> 	call os_string_compare
   964 00002E8A 0F82F307            <1> 	jc near do_gosub
   965                              <1> 
   966 00002E8E BF[1C47]            <1> 	mov di, goto_cmd
   967 00002E91 E8D2FC              <1> 	call os_string_compare
   968 00002E94 0F828608            <1> 	jc near do_goto
   969                              <1> 
   970 00002E98 BF[2847]            <1> 	mov di, if_cmd
   971 00002E9B E8C8FC              <1> 	call os_string_compare
   972 00002E9E 0F82FC08            <1> 	jc near do_if
   973                              <1> 
   974 00002EA2 BF[2B47]            <1> 	mov di, include_cmd
   975 00002EA5 E8BEFC              <1> 	call os_string_compare
   976 00002EA8 0F82490A            <1> 	jc near do_include
   977                              <1> 
   978 00002EAC BF[3347]            <1> 	mov di, ink_cmd
   979 00002EAF E8B4FC              <1> 	call os_string_compare
   980 00002EB2 0F826E0A            <1> 	jc near do_ink
   981                              <1> 
   982 00002EB6 BF[3747]            <1> 	mov di, input_cmd
   983 00002EB9 E8AAFC              <1> 	call os_string_compare
   984 00002EBC 0F82870A            <1> 	jc near do_input
   985                              <1> 	
   986 00002EC0 BF[3D47]            <1> 	mov di, len_cmd
   987 00002EC3 E8A0FC              <1> 	call os_string_compare
   988 00002EC6 0F82E90A            <1> 	jc near do_len
   989                              <1> 
   990 00002ECA BF[4147]            <1> 	mov di, listbox_cmd
   991 00002ECD E896FC              <1> 	call os_string_compare
   992 00002ED0 0F82270B            <1> 	jc near do_listbox
   993                              <1> 
   994 00002ED4 BF[4947]            <1> 	mov di, load_cmd
   995 00002ED7 E88CFC              <1> 	call os_string_compare
   996 00002EDA 0F82B60B            <1> 	jc near do_load
   997                              <1> 
   998 00002EDE BF[4E47]            <1> 	mov di, loop_cmd
   999 00002EE1 E882FC              <1> 	call os_string_compare
  1000 00002EE4 0F821E0C            <1> 	jc near do_loop
  1001                              <1> 
  1002 00002EE8 BF[5347]            <1> 	mov di, move_cmd
  1003 00002EEB E878FC              <1> 	call os_string_compare
  1004 00002EEE 0F82080D            <1> 	jc near do_move
  1005                              <1> 
  1006 00002EF2 BF[5847]            <1> 	mov di, next_cmd
  1007 00002EF5 E86EFC              <1> 	call os_string_compare
  1008 00002EF8 0F82410D            <1> 	jc near do_next
  1009                              <1> 
  1010 00002EFC BF[5D47]            <1> 	mov di, number_cmd
  1011 00002EFF E864FC              <1> 	call os_string_compare
  1012 00002F02 0F82840D            <1> 	jc near do_number
  1013                              <1> 
  1014 00002F06 BF[6447]            <1> 	mov di, page_cmd
  1015 00002F09 E85AFC              <1> 	call os_string_compare
  1016 00002F0C 0F82E50D            <1> 	jc near do_page
  1017                              <1> 
  1018 00002F10 BF[6947]            <1> 	mov di, pause_cmd
  1019 00002F13 E850FC              <1> 	call os_string_compare
  1020 00002F16 0F820A0E            <1> 	jc near do_pause
  1021                              <1> 
  1022 00002F1A BF[6F47]            <1> 	mov di, peek_cmd
  1023 00002F1D E846FC              <1> 	call os_string_compare
  1024 00002F20 0F821E0E            <1> 	jc near do_peek
  1025                              <1> 
  1026 00002F24 BF[7447]            <1> 	mov di, peekint_cmd
  1027 00002F27 E83CFC              <1> 	call os_string_compare
  1028 00002F2A 0F82560E            <1> 	jc near do_peekint
  1029                              <1> 	
  1030 00002F2E BF[7C47]            <1> 	mov di, poke_cmd
  1031 00002F31 E832FC              <1> 	call os_string_compare
  1032 00002F34 0F82860E            <1> 	jc near do_poke
  1033                              <1> 	
  1034 00002F38 BF[8147]            <1> 	mov di, pokeint_cmd
  1035 00002F3B E828FC              <1> 	call os_string_compare
  1036 00002F3E 0F82D40E            <1> 	jc near do_pokeint
  1037                              <1> 
  1038 00002F42 BF[8947]            <1> 	mov di, port_cmd
  1039 00002F45 E81EFC              <1> 	call os_string_compare
  1040 00002F48 0F820F0F            <1> 	jc near do_port
  1041                              <1> 
  1042 00002F4C BF[8E47]            <1> 	mov di, print_cmd
  1043 00002F4F E814FC              <1> 	call os_string_compare
  1044 00002F52 0F82870F            <1> 	jc near do_print
  1045                              <1> 
  1046 00002F56 BF[9447]            <1> 	mov di, rand_cmd
  1047 00002F59 E80AFC              <1> 	call os_string_compare
  1048 00002F5C 0F82AA10            <1> 	jc near do_rand
  1049                              <1> 
  1050 00002F60 BF[9947]            <1> 	mov di, read_cmd
  1051 00002F63 E800FC              <1> 	call os_string_compare
  1052 00002F66 0F82F210            <1> 	jc near do_read
  1053                              <1> 
  1054 00002F6A BF[9E47]            <1> 	mov di, rem_cmd
  1055 00002F6D E8F6FB              <1> 	call os_string_compare
  1056 00002F70 0F82BE11            <1> 	jc near do_rem
  1057                              <1> 
  1058 00002F74 BF[A247]            <1> 	mov di, rename_cmd
  1059 00002F77 E8ECFB              <1> 	call os_string_compare
  1060 00002F7A 0F82C511            <1> 	jc near do_rename
  1061                              <1> 
  1062 00002F7E BF[A947]            <1> 	mov di, return_cmd
  1063 00002F81 E8E2FB              <1> 	call os_string_compare
  1064 00002F84 0F827012            <1> 	jc near do_return
  1065                              <1> 
  1066 00002F88 BF[B047]            <1> 	mov di, save_cmd
  1067 00002F8B E8D8FB              <1> 	call os_string_compare
  1068 00002F8E 0F828712            <1> 	jc near do_save
  1069                              <1> 
  1070 00002F92 BF[B547]            <1> 	mov di, serial_cmd
  1071 00002F95 E8CEFB              <1> 	call os_string_compare
  1072 00002F98 0F823C13            <1> 	jc near do_serial
  1073                              <1> 
  1074 00002F9C BF[BC47]            <1> 	mov di, size_cmd
  1075 00002F9F E8C4FB              <1> 	call os_string_compare
  1076 00002FA2 0F82D613            <1> 	jc near do_size
  1077                              <1> 
  1078 00002FA6 BF[C147]            <1> 	mov di, sound_cmd
  1079 00002FA9 E8BAFB              <1> 	call os_string_compare
  1080 00002FAC 0F822114            <1> 	jc near do_sound
  1081                              <1> 	
  1082 00002FB0 BF[C747]            <1> 	mov di, string_cmd
  1083 00002FB3 E8B0FB              <1> 	call os_string_compare
  1084 00002FB6 0F825314            <1> 	jc near do_string
  1085                              <1> 
  1086 00002FBA BF[CE47]            <1> 	mov di, waitkey_cmd
  1087 00002FBD E8A6FB              <1> 	call os_string_compare
  1088 00002FC0 0F82FE14            <1> 	jc near do_waitkey
  1089                              <1> 
  1090 00002FC4 B301                <1> 	mov bl, err_cmd_unknown			; Command not found?
  1091 00002FC6 E97716              <1> 	jmp error
  1092                              <1> 
  1093                              <1> 
  1094                              <1> ; ------------------------------------------------------------------
  1095                              <1> ; CLEAR RAM
  1096                              <1> 
  1097                              <1> clear_ram:
  1098 00002FC9 60                  <1> 	pusha
  1099 00002FCA B000                <1> 	mov al, 0
  1100                              <1> 
  1101 00002FCC BF4C7A              <1> 	mov di, variables
  1102 00002FCF B93400              <1> 	mov cx, 52
  1103 00002FD2 F3AA                <1> 	rep stosb
  1104                              <1> 
  1105 00002FD4 BF187A              <1> 	mov di, for_variables
  1106 00002FD7 B93400              <1> 	mov cx, 52
  1107 00002FDA F3AA                <1> 	rep stosb
  1108                              <1> 
  1109 00002FDC BFE479              <1> 	mov di, for_code_points
  1110 00002FDF B93400              <1> 	mov cx, 52
  1111 00002FE2 F3AA                <1> 	rep stosb
  1112                              <1> 	
  1113 00002FE4 BFD079              <1> 	mov di, do_loop_store
  1114 00002FE7 B90A00              <1> 	mov cx, 10
  1115 00002FEA F3AA                <1> 	rep stosb
  1116                              <1> 
  1117 00002FEC C606[2248]00        <1> 	mov byte [gosub_depth], 0
  1118 00002FF1 C606[B246]00        <1> 	mov byte [loop_in], 0
  1119                              <1> 
  1120 00002FF6 BFBC79              <1> 	mov di, gosub_points
  1121 00002FF9 B91400              <1> 	mov cx, 20
  1122 00002FFC F3AA                <1> 	rep stosb
  1123                              <1> 
  1124 00002FFE BF007C              <1> 	mov di, string_vars
  1125 00003001 B90004              <1> 	mov cx, 1024
  1126 00003004 F3AA                <1> 	rep stosb
  1127                              <1> 
  1128 00003006 C606[B446]07        <1> 	mov byte [ink_colour], 7		; White ink
  1129                              <1> 
  1130 0000300B 61                  <1> 	popa
  1131 0000300C C3                  <1> 	ret
  1132                              <1> 
  1133                              <1> 
  1134                              <1> ; ------------------------------------------------------------------
  1135                              <1> ; ASSIGNMENT
  1136                              <1> 
  1137                              <1> assign:
  1138 0000300D 83F801              <1> 	cmp ax, VARIABLE			; Are we starting with a number var?
  1139 00003010 0F84A700            <1> 	je .do_num_var
  1140                              <1> 
  1141 00003014 BF007C              <1> 	mov di, string_vars			; Otherwise it's a string var
  1142 00003017 B88000              <1> 	mov ax, 128
  1143 0000301A F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1144 0000301C 01C7                <1> 	add di, ax
  1145                              <1> 
  1146 0000301E 57                  <1> 	push di
  1147                              <1> 
  1148 0000301F E80515              <1> 	call get_token
  1149 00003022 A0007B              <1> 	mov byte al, [token]
  1150 00003025 3C3D                <1> 	cmp al, '='
  1151 00003027 0F857D02            <1> 	jne near .error
  1152                              <1> 
  1153 0000302B E8F914              <1> 	call get_token				; See if second is quote
  1154 0000302E 83F805              <1> 	cmp ax, QUOTE
  1155 00003031 7417                <1> 	je .second_is_quote
  1156                              <1> 
  1157 00003033 83F802              <1> 	cmp ax, STRING_VAR
  1158 00003036 0F856E02            <1> 	jne near .error
  1159                              <1> 
  1160 0000303A BE007C              <1> 	mov si, string_vars			; Otherwise it's a string var
  1161 0000303D B88000              <1> 	mov ax, 128
  1162 00003040 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1163 00003042 01C6                <1> 	add si, ax
  1164                              <1> 
  1165 00003044 5F                  <1> 	pop di
  1166 00003045 E8BFFA              <1> 	call os_string_copy
  1167                              <1> 
  1168 00003048 EB07                <1> 	jmp .string_check_for_more
  1169                              <1> 
  1170                              <1> 
  1171                              <1> .second_is_quote:
  1172 0000304A BE007B              <1> 	mov si, token
  1173 0000304D 5F                  <1> 	pop di
  1174 0000304E E8B6FA              <1> 	call os_string_copy
  1175                              <1> 
  1176                              <1> 
  1177                              <1> .string_check_for_more:
  1178 00003051 57                  <1> 	push di
  1179 00003052 A1[AB46]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1180 00003055 A3[AE32]            <1> 	mov word [.tmp_loc], ax
  1181                              <1> 
  1182 00003058 E8CC14              <1> 	call get_token				; Any more to deal with in this assignment?
  1183 0000305B A0007B              <1> 	mov byte al, [token]
  1184 0000305E 3C2B                <1> 	cmp al, '+'
  1185 00003060 740A                <1> 	je .string_theres_more
  1186                              <1> 
  1187 00003062 A1[AE32]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1188 00003065 A3[AB46]            <1> 	mov word [prog], ax			; that we just grabbed
  1189                              <1> 
  1190 00003068 5F                  <1> 	pop di
  1191 00003069 E94BFD              <1> 	jmp mainloop				; And go back to the code interpreter!
  1192                              <1> 
  1193                              <1> 
  1194                              <1> .string_theres_more:
  1195 0000306C E8B814              <1> 	call get_token
  1196 0000306F 83F802              <1> 	cmp ax, STRING_VAR
  1197 00003072 740D                <1> 	je .another_string_var
  1198 00003074 83F805              <1> 	cmp ax, QUOTE
  1199 00003077 741E                <1> 	je .another_quote
  1200 00003079 83F801              <1> 	cmp ax, VARIABLE
  1201 0000307C 7426                <1> 	je .add_number_var
  1202 0000307E E92702              <1> 	jmp .error
  1203                              <1> 
  1204                              <1> 
  1205                              <1> .another_string_var:
  1206 00003081 5F                  <1> 	pop di
  1207                              <1> 
  1208 00003082 BE007C              <1> 	mov si, string_vars
  1209 00003085 B88000              <1> 	mov ax, 128
  1210 00003088 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1211 0000308A 01C6                <1> 	add si, ax
  1212                              <1> 
  1213 0000308C 89F8                <1> 	mov ax, di
  1214 0000308E 89F9                <1> 	mov cx, di
  1215 00003090 89F3                <1> 	mov bx, si
  1216 00003092 E87BFA              <1> 	call os_string_join
  1217                              <1> 
  1218 00003095 EBBA                <1> 	jmp .string_check_for_more
  1219                              <1> 
  1220                              <1> 
  1221                              <1> 
  1222                              <1> .another_quote:
  1223 00003097 5F                  <1> 	pop di
  1224                              <1> 
  1225 00003098 89F8                <1> 	mov ax, di
  1226 0000309A 89F9                <1> 	mov cx, di
  1227 0000309C BB007B              <1> 	mov bx, token
  1228 0000309F E86EFA              <1> 	call os_string_join
  1229                              <1> 
  1230 000030A2 EBAD                <1> 	jmp .string_check_for_more
  1231                              <1> 
  1232                              <1> 
  1233                              <1> .add_number_var:
  1234 000030A4 31C0                <1> 	xor ax, ax
  1235 000030A6 A0007B              <1> 	mov byte al, [token]
  1236 000030A9 E85F14              <1> 	call get_var
  1237 000030AC E856FB              <1> 	call os_int_to_string
  1238                              <1> 
  1239 000030AF 89C3                <1> 	mov bx, ax
  1240 000030B1 5F                  <1> 	pop di
  1241 000030B2 89F8                <1> 	mov ax, di
  1242 000030B4 89F9                <1> 	mov cx, di
  1243 000030B6 E857FA              <1> 	call os_string_join
  1244                              <1> 
  1245 000030B9 EB96                <1> 	jmp .string_check_for_more
  1246                              <1> 	
  1247                              <1> 
  1248                              <1> 
  1249                              <1> 
  1250                              <1> .do_num_var:
  1251 000030BB 31C0                <1> 	xor ax, ax
  1252 000030BD A0007B              <1> 	mov byte al, [token]
  1253 000030C0 A2[AD32]            <1> 	mov byte [.tmp], al
  1254                              <1> 
  1255 000030C3 E86114              <1> 	call get_token
  1256 000030C6 A0007B              <1> 	mov byte al, [token]
  1257 000030C9 3C3D                <1> 	cmp al, '='
  1258 000030CB 0F85D901            <1> 	jne near .error
  1259                              <1> 
  1260 000030CF E85514              <1> 	call get_token
  1261 000030D2 83F803              <1> 	cmp ax, NUMBER
  1262 000030D5 744D                <1> 	je .second_is_num
  1263                              <1> 
  1264 000030D7 83F801              <1> 	cmp ax, VARIABLE
  1265 000030DA 7436                <1> 	je .second_is_variable
  1266                              <1> 
  1267 000030DC 83F804              <1> 	cmp ax, STRING
  1268 000030DF 0F842F01            <1> 	je near .second_is_string
  1269                              <1> 
  1270 000030E3 83F807              <1> 	cmp ax, UNKNOWN
  1271 000030E6 0F85BE01            <1> 	jne near .error
  1272                              <1> 
  1273 000030EA A0007B              <1> 	mov byte al, [token]			; Address of string var?
  1274 000030ED 3C26                <1> 	cmp al, '&'
  1275 000030EF 0F85B501            <1> 	jne near .error
  1276                              <1> 
  1277 000030F3 E83114              <1> 	call get_token				; Let's see if there's a string var
  1278 000030F6 83F802              <1> 	cmp ax, STRING_VAR
  1279 000030F9 0F85AB01            <1> 	jne near .error
  1280                              <1> 
  1281 000030FD BF007C              <1> 	mov di, string_vars
  1282 00003100 B88000              <1> 	mov ax, 128
  1283 00003103 F7E3                <1> 	mul bx
  1284 00003105 01C7                <1> 	add di, ax
  1285                              <1> 
  1286 00003107 89FB                <1> 	mov bx, di
  1287                              <1> 
  1288 00003109 A0[AD32]            <1> 	mov byte al, [.tmp]
  1289 0000310C E80914              <1> 	call set_var
  1290                              <1> 
  1291 0000310F E9A5FC              <1> 	jmp mainloop
  1292                              <1> 
  1293                              <1> 
  1294                              <1> .second_is_variable:
  1295 00003112 31C0                <1> 	xor ax, ax
  1296 00003114 A0007B              <1> 	mov byte al, [token]
  1297                              <1> 
  1298 00003117 E8F113              <1> 	call get_var
  1299 0000311A 89C3                <1> 	mov bx, ax
  1300 0000311C A0[AD32]            <1> 	mov byte al, [.tmp]
  1301 0000311F E8F613              <1> 	call set_var
  1302                              <1> 
  1303 00003122 EB10                <1> 	jmp .check_for_more
  1304                              <1> 
  1305                              <1> 
  1306                              <1> .second_is_num:
  1307 00003124 BE007B              <1> 	mov si, token
  1308 00003127 E890FA              <1> 	call os_string_to_int
  1309                              <1> 
  1310 0000312A 89C3                <1> 	mov bx, ax				; Number to insert in variable table
  1311                              <1> 
  1312 0000312C 31C0                <1> 	xor ax, ax
  1313 0000312E A0[AD32]            <1> 	mov byte al, [.tmp]
  1314                              <1> 
  1315 00003131 E8E413              <1> 	call set_var
  1316                              <1> 
  1317                              <1> 
  1318                              <1> 	; The assignment could be simply "X = 5" etc. Or it could be
  1319                              <1> 	; "X = Y + 5" -- ie more complicated. So here we check to see if
  1320                              <1> 	; there's a delimiter...
  1321                              <1> 
  1322                              <1> .check_for_more:
  1323 00003134 A1[AB46]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1324 00003137 A3[AE32]            <1> 	mov word [.tmp_loc], ax
  1325                              <1> 
  1326 0000313A E8EA13              <1> 	call get_token				; Any more to deal with in this assignment?
  1327 0000313D A0007B              <1> 	mov byte al, [token]
  1328 00003140 3C2B                <1> 	cmp al, '+'
  1329 00003142 7419                <1> 	je .theres_more
  1330 00003144 3C2D                <1> 	cmp al, '-'
  1331 00003146 7415                <1> 	je .theres_more
  1332 00003148 3C2A                <1> 	cmp al, '*'
  1333 0000314A 7411                <1> 	je .theres_more
  1334 0000314C 3C2F                <1> 	cmp al, '/'
  1335 0000314E 740D                <1> 	je .theres_more
  1336 00003150 3C25                <1> 	cmp al, '%'
  1337 00003152 7409                <1> 	je .theres_more
  1338                              <1> 
  1339 00003154 A1[AE32]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1340 00003157 A3[AB46]            <1> 	mov word [prog], ax			; that we just grabbed
  1341                              <1> 
  1342 0000315A E95AFC              <1> 	jmp mainloop				; And go back to the code interpreter!
  1343                              <1> 
  1344                              <1> 
  1345                              <1> .theres_more:
  1346 0000315D A2[B032]            <1> 	mov byte [.delim], al
  1347                              <1> 
  1348 00003160 E8C413              <1> 	call get_token
  1349 00003163 83F801              <1> 	cmp ax, VARIABLE
  1350 00003166 7459                <1> 	je .handle_variable
  1351                              <1> 
  1352 00003168 BE007B              <1> 	mov si, token
  1353 0000316B E84CFA              <1> 	call os_string_to_int
  1354 0000316E 89C3                <1> 	mov bx, ax
  1355                              <1> 
  1356 00003170 31C0                <1> 	xor ax, ax
  1357 00003172 A0[AD32]            <1> 	mov byte al, [.tmp]
  1358                              <1> 
  1359 00003175 E89313              <1> 	call get_var				; This also points SI at right place in variable table
  1360                              <1> 
  1361 00003178 803E[B032]2B        <1> 	cmp byte [.delim], '+'
  1362 0000317D 7504                <1> 	jne .not_plus
  1363                              <1> 
  1364 0000317F 01D8                <1> 	add ax, bx
  1365 00003181 EB2E                <1> 	jmp .finish
  1366                              <1> 
  1367                              <1> .not_plus:
  1368 00003183 803E[B032]2D        <1> 	cmp byte [.delim], '-'
  1369 00003188 7504                <1> 	jne .not_minus
  1370                              <1> 
  1371 0000318A 29D8                <1> 	sub ax, bx
  1372 0000318C EB23                <1> 	jmp .finish
  1373                              <1> 
  1374                              <1> .not_minus:
  1375 0000318E 803E[B032]2A        <1> 	cmp byte [.delim], '*'
  1376 00003193 7504                <1> 	jne .not_times
  1377                              <1> 
  1378 00003195 F7E3                <1> 	mul bx
  1379 00003197 EB18                <1> 	jmp .finish
  1380                              <1> 
  1381                              <1> .not_times:
  1382 00003199 803E[B032]2F        <1> 	cmp byte [.delim], '/'
  1383 0000319E 750B                <1> 	jne .not_divide
  1384                              <1> 
  1385 000031A0 83FB00              <1> 	cmp bx, 0
  1386 000031A3 7417                <1> 	je .divide_zero
  1387                              <1> 	
  1388 000031A5 31D2                <1> 	xor dx, dx
  1389 000031A7 F7F3                <1> 	div bx
  1390 000031A9 EB06                <1> 	jmp .finish
  1391                              <1> 
  1392                              <1> .not_divide:
  1393 000031AB 31D2                <1> 	xor dx, dx
  1394 000031AD F7F3                <1> 	div bx
  1395 000031AF 89D0                <1> 	mov ax, dx				; Get remainder
  1396                              <1> 
  1397                              <1> .finish:
  1398 000031B1 89C3                <1> 	mov bx, ax
  1399 000031B3 A0[AD32]            <1> 	mov byte al, [.tmp]
  1400 000031B6 E85F13              <1> 	call set_var
  1401                              <1> 
  1402 000031B9 E978FF              <1> 	jmp .check_for_more
  1403                              <1> 
  1404                              <1> .divide_zero:
  1405 000031BC B302                <1> 	mov bl, err_divide_by_zero
  1406 000031BE E97F14              <1> 	jmp error
  1407                              <1> 	
  1408                              <1> .handle_variable:
  1409 000031C1 31C0                <1> 	xor ax, ax
  1410 000031C3 A0007B              <1> 	mov byte al, [token]
  1411                              <1> 
  1412 000031C6 E84213              <1> 	call get_var
  1413                              <1> 
  1414 000031C9 89C3                <1> 	mov bx, ax
  1415                              <1> 
  1416 000031CB 31C0                <1> 	xor ax, ax
  1417 000031CD A0[AD32]            <1> 	mov byte al, [.tmp]
  1418                              <1> 
  1419 000031D0 E83813              <1> 	call get_var
  1420                              <1> 
  1421 000031D3 803E[B032]2B        <1> 	cmp byte [.delim], '+'
  1422 000031D8 7504                <1> 	jne .vnot_plus
  1423                              <1> 
  1424 000031DA 01D8                <1> 	add ax, bx
  1425 000031DC EB29                <1> 	jmp .vfinish
  1426                              <1> 
  1427                              <1> .vnot_plus:
  1428 000031DE 803E[B032]2D        <1> 	cmp byte [.delim], '-'
  1429 000031E3 7504                <1> 	jne .vnot_minus
  1430                              <1> 
  1431 000031E5 29D8                <1> 	sub ax, bx
  1432 000031E7 EB1E                <1> 	jmp .vfinish
  1433                              <1> 
  1434                              <1> .vnot_minus:
  1435 000031E9 803E[B032]2A        <1> 	cmp byte [.delim], '*'
  1436 000031EE 7504                <1> 	jne .vnot_times
  1437                              <1> 
  1438 000031F0 F7E3                <1> 	mul bx
  1439 000031F2 EB13                <1> 	jmp .vfinish
  1440                              <1> 
  1441                              <1> .vnot_times:
  1442 000031F4 803E[B032]2F        <1> 	cmp byte [.delim], '/'
  1443 000031F9 7506                <1> 	jne .vnot_divide
  1444                              <1> 
  1445 000031FB 31D2                <1> 	xor dx, dx
  1446 000031FD F7F3                <1> 	div bx
  1447 000031FF EBB0                <1> 	jmp .finish
  1448                              <1> 
  1449                              <1> .vnot_divide:
  1450 00003201 31D2                <1> 	xor dx, dx
  1451 00003203 F7F3                <1> 	div bx
  1452 00003205 89D0                <1> 	mov ax, dx				; Get remainder
  1453                              <1> 
  1454                              <1> .vfinish:
  1455 00003207 89C3                <1> 	mov bx, ax
  1456 00003209 A0[AD32]            <1> 	mov byte al, [.tmp]
  1457 0000320C E80913              <1> 	call set_var
  1458                              <1> 
  1459 0000320F E922FF              <1> 	jmp .check_for_more
  1460                              <1> 
  1461                              <1> 
  1462                              <1> .second_is_string:				; These are "X = word" functions
  1463 00003212 BF007B              <1> 	mov di, token
  1464                              <1> 	
  1465 00003215 BE[F347]            <1> 	mov si, ink_keyword
  1466 00003218 E84BF9              <1> 	call os_string_compare
  1467 0000321B 742A                <1> 	je .is_ink
  1468                              <1> 	
  1469 0000321D BE[F747]            <1> 	mov si, progstart_keyword
  1470 00003220 E843F9              <1> 	call os_string_compare
  1471 00003223 7433                <1> 	je .is_progstart
  1472                              <1> 
  1473 00003225 BE[0148]            <1> 	mov si, ramstart_keyword
  1474 00003228 E83BF9              <1> 	call os_string_compare
  1475 0000322B 743A                <1> 	je .is_ramstart
  1476                              <1> 
  1477 0000322D BE[0A48]            <1> 	mov si, timer_keyword
  1478 00003230 E833F9              <1> 	call os_string_compare
  1479 00003233 7444                <1> 	je .is_timer
  1480                              <1> 	
  1481 00003235 BE[1048]            <1> 	mov si, variables_keyword
  1482 00003238 E82BF9              <1> 	call os_string_compare
  1483 0000323B 744E                <1> 	je .is_variables
  1484                              <1> 	
  1485 0000323D BE[1A48]            <1> 	mov si, version_keyword
  1486 00003240 E823F9              <1> 	call os_string_compare
  1487 00003243 7454                <1> 	je .is_version
  1488                              <1> 
  1489 00003245 EB61                <1> 	jmp .error
  1490                              <1> 
  1491                              <1> 
  1492                              <1> .is_ink:
  1493 00003247 0FB606[AD32]        <1> 	movzx ax, byte [.tmp]
  1494                              <1> 	
  1495 0000324C 31C0                <1> 	xor ax, ax
  1496 0000324E 8A1E[B446]          <1> 	mov byte bl, [ink_colour]
  1497 00003252 E8C312              <1> 	call set_var
  1498                              <1> 	
  1499 00003255 E95FFB              <1> 	jmp mainloop
  1500                              <1> 
  1501                              <1> 
  1502                              <1> .is_progstart:
  1503 00003258 0FB606[AD32]        <1> 	movzx ax, byte [.tmp]
  1504                              <1> 
  1505 0000325D 8B1E[AF46]          <1> 	mov word bx, [load_point]
  1506 00003261 E8B412              <1> 	call set_var
  1507                              <1> 
  1508 00003264 E950FB              <1> 	jmp mainloop
  1509                              <1> 
  1510                              <1> 
  1511                              <1> .is_ramstart:
  1512 00003267 31C0                <1> 	xor ax, ax
  1513 00003269 A0[AD32]            <1> 	mov byte al, [.tmp]
  1514                              <1> 
  1515 0000326C 8B1E[AD46]          <1> 	mov word bx, [prog_end]
  1516 00003270 43                  <1> 	inc bx
  1517 00003271 43                  <1> 	inc bx
  1518 00003272 43                  <1> 	inc bx
  1519 00003273 E8A212              <1> 	call set_var
  1520                              <1> 
  1521 00003276 E93EFB              <1> 	jmp mainloop
  1522                              <1> 
  1523                              <1> 
  1524                              <1> .is_timer:
  1525 00003279 B400                <1> 	mov ah, 0
  1526 0000327B E8FCE4              <1> 	call os_int_1Ah
  1527 0000327E 89D3                <1> 	mov bx, dx
  1528                              <1> 
  1529 00003280 31C0                <1> 	xor ax, ax
  1530 00003282 A0[AD32]            <1> 	mov byte al, [.tmp]
  1531 00003285 E89012              <1> 	call set_var
  1532                              <1> 
  1533 00003288 E92CFB              <1> 	jmp mainloop
  1534                              <1> 
  1535                              <1> 
  1536                              <1> .is_variables:
  1537 0000328B BB[B246]            <1> 	mov bx, vars_loc
  1538 0000328E 31C0                <1> 	xor ax, ax
  1539 00003290 A0[AD32]            <1> 	mov byte al, [.tmp]
  1540 00003293 E88212              <1> 	call set_var
  1541                              <1> 
  1542 00003296 E91EFB              <1> 	jmp mainloop
  1543                              <1> 
  1544                              <1> 
  1545                              <1> .is_version:
  1546 00003299 B0FF                <1> 	mov al, 255
  1547                              <1> 	
  1548 0000329B B700                <1> 	mov bh, 0
  1549 0000329D 88C3                <1> 	mov bl, al
  1550 0000329F A0[AD32]            <1> 	mov al, [.tmp]
  1551 000032A2 E87312              <1> 	call set_var
  1552                              <1> 	
  1553 000032A5 E90FFB              <1> 	jmp mainloop 
  1554                              <1> 
  1555                              <1> 
  1556                              <1> .error:
  1557 000032A8 B314                <1> 	mov bl, err_syntax
  1558 000032AA E99313              <1> 	jmp error
  1559                              <1> 
  1560                              <1> 
  1561 000032AD 00                  <1> 	.tmp		db 0
  1562 000032AE 0000                <1> 	.tmp_loc	dw 0
  1563 000032B0 00                  <1> 	.delim		db 0
  1564                              <1> 
  1565                              <1> 
  1566                              <1> ; ==================================================================
  1567                              <1> ; SPECIFIC COMMAND CODE STARTS HERE
  1568                              <1> 
  1569                              <1> ; ------------------------------------------------------------------
  1570                              <1> ; ALERT
  1571                              <1> 
  1572                              <1> do_alert:
  1573 000032B1 8A3E[B546]          <1> 	mov bh, [work_page]			; Store the cursor position
  1574 000032B5 B403                <1> 	mov ah, 03h
  1575 000032B7 CD10                <1> 	int 10h
  1576                              <1> 
  1577 000032B9 E86B12              <1> 	call get_token
  1578                              <1> 
  1579 000032BC 83F805              <1> 	cmp ax, QUOTE
  1580 000032BF 7416                <1> 	je .is_quote
  1581                              <1> 	
  1582 000032C1 83F802              <1> 	cmp ax, STRING_VAR
  1583 000032C4 7405                <1> 	je .is_string
  1584                              <1> 
  1585 000032C6 B314                <1> 	mov bl, err_syntax
  1586 000032C8 E97513              <1> 	jmp error
  1587                              <1> 
  1588                              <1> .is_string:
  1589 000032CB BE007C              <1> 	mov si, string_vars
  1590 000032CE B88000              <1> 	mov ax, 128
  1591 000032D1 F7E3                <1> 	mul bx
  1592 000032D3 01F0                <1> 	add ax, si
  1593 000032D5 EB03                <1> 	jmp .display_message
  1594                              <1> 	
  1595                              <1> .is_quote:
  1596 000032D7 B8007B              <1> 	mov ax, token				; First string for alert box
  1597                              <1> 	
  1598                              <1> .display_message:
  1599 000032DA 31DB                <1> 	xor bx, bx				; Others are blank
  1600 000032DC 31C9                <1> 	xor cx, cx
  1601 000032DE 31D2                <1> 	xor dx, dx				; One-choice box
  1602 000032E0 E816EE              <1> 	call os_dialog_box
  1603                              <1> 	
  1604 000032E3 8A3E[B546]          <1> 	mov bh, [work_page]			; Move the cursor back
  1605 000032E7 B402                <1> 	mov ah, 02h
  1606 000032E9 CD10                <1> 	int 10h
  1607                              <1> 	
  1608 000032EB E9C9FA              <1> 	jmp mainloop
  1609                              <1> 
  1610                              <1> 
  1611                              <1> ;-------------------------------------------------------------------
  1612                              <1> ; ASKFILE
  1613                              <1> 
  1614                              <1> do_askfile:
  1615 000032EE 8A3E[B546]          <1> 	mov bh, [work_page]			; Store the cursor position
  1616 000032F2 B403                <1> 	mov ah, 03h
  1617 000032F4 CD10                <1> 	int 10h
  1618                              <1> 	
  1619 000032F6 E82E12              <1> 	call get_token
  1620                              <1> 	
  1621 000032F9 83F802              <1> 	cmp ax, STRING_VAR
  1622 000032FC 7524                <1> 	jne .error
  1623                              <1> 	
  1624 000032FE BE007C              <1> 	mov si, string_vars			; Get the string location
  1625 00003301 B88000              <1> 	mov ax, 128
  1626 00003304 F7E3                <1> 	mul bx
  1627 00003306 01F0                <1> 	add ax, si
  1628 00003308 A3[2733]            <1> 	mov word [.tmp], ax
  1629                              <1> 	
  1630 0000330B E87BE6              <1> 	call os_file_selector			; Present the selector
  1631                              <1> 	
  1632 0000330E 8B3E[2733]          <1> 	mov word di, [.tmp]			; Copy the string
  1633 00003312 89C6                <1> 	mov si, ax
  1634 00003314 E8F0F7              <1> 	call os_string_copy
  1635                              <1> 
  1636 00003317 8A3E[B546]          <1> 	mov bh, [work_page]			; Move the cursor back
  1637 0000331B B402                <1> 	mov ah, 02h
  1638 0000331D CD10                <1> 	int 10h
  1639                              <1> 	
  1640 0000331F E995FA              <1> 	jmp mainloop
  1641                              <1> 	
  1642                              <1> .error:
  1643 00003322 B314                <1> 	mov bl, err_syntax
  1644 00003324 E91913              <1> 	jmp error
  1645                              <1> 
  1646                              <1> .data:
  1647 00003327 0000                <1> 	.tmp					dw 0
  1648                              <1> 
  1649                              <1> 
  1650                              <1> ; ------------------------------------------------------------------
  1651                              <1> ; BREAK
  1652                              <1> 
  1653                              <1> do_break:
  1654 00003329 B3[93]              <1> 	mov bl, err_break
  1655 0000332B E91213              <1> 	jmp error
  1656                              <1> 
  1657                              <1> 
  1658                              <1> ; ------------------------------------------------------------------
  1659                              <1> ; CALL
  1660                              <1> 
  1661                              <1> do_call:
  1662 0000332E E8F611              <1> 	call get_token
  1663 00003331 83F803              <1> 	cmp ax, NUMBER
  1664 00003334 740A                <1> 	je .is_number
  1665                              <1> 
  1666 00003336 31C0                <1> 	xor ax, ax
  1667 00003338 A0007B              <1> 	mov byte al, [token]
  1668 0000333B E8CD11              <1> 	call get_var
  1669 0000333E EB06                <1> 	jmp .execute_call
  1670                              <1> 
  1671                              <1> .is_number:
  1672 00003340 BE007B              <1> 	mov si, token
  1673 00003343 E874F8              <1> 	call os_string_to_int
  1674                              <1> 
  1675                              <1> .execute_call:
  1676 00003346 31DB                <1> 	xor bx, bx
  1677 00003348 31C9                <1> 	xor cx, cx
  1678 0000334A 31D2                <1> 	xor dx, dx
  1679 0000334C 31FF                <1> 	xor di, di
  1680 0000334E 31F6                <1> 	xor si, si
  1681                              <1> 
  1682 00003350 FFD0                <1> 	call ax
  1683                              <1> 
  1684 00003352 E962FA              <1> 	jmp mainloop
  1685                              <1> 
  1686                              <1> 
  1687                              <1> ; ------------------------------------------------------------------
  1688                              <1> ; CASE
  1689                              <1> 
  1690                              <1> do_case:
  1691 00003355 E8CF11              <1> 	call get_token
  1692 00003358 83F804              <1> 	cmp ax, STRING
  1693 0000335B 7545                <1> 	jne .error
  1694                              <1> 	
  1695 0000335D BE007B              <1> 	mov si, token
  1696                              <1> 
  1697 00003360 BF[ED47]            <1> 	mov di, upper_keyword
  1698 00003363 E800F8              <1> 	call os_string_compare
  1699 00003366 720A                <1> 	jc .uppercase
  1700                              <1> 	
  1701 00003368 BF[E747]            <1> 	mov di, lower_keyword
  1702 0000336B E8F8F7              <1> 	call os_string_compare
  1703 0000336E 721A                <1> 	jc .lowercase
  1704                              <1> 	
  1705 00003370 EB30                <1> 	jmp .error
  1706                              <1> 	
  1707                              <1> .uppercase:
  1708 00003372 E8B211              <1> 	call get_token
  1709 00003375 83F802              <1> 	cmp ax, STRING_VAR
  1710 00003378 7528                <1> 	jne .error
  1711                              <1> 	
  1712 0000337A BE007C              <1> 	mov si, string_vars
  1713 0000337D B88000              <1> 	mov ax, 128
  1714 00003380 F7E3                <1> 	mul bx
  1715 00003382 01F0                <1> 	add ax, si
  1716                              <1> 	
  1717 00003384 E846F7              <1> 	call os_string_uppercase
  1718                              <1> 	
  1719 00003387 E92DFA              <1> 	jmp mainloop
  1720                              <1> 	
  1721                              <1> .lowercase:
  1722 0000338A E89A11              <1> 	call get_token
  1723 0000338D 83F802              <1> 	cmp ax, STRING_VAR
  1724 00003390 7510                <1> 	jne .error
  1725                              <1> 	
  1726 00003392 BE007C              <1> 	mov si, string_vars
  1727 00003395 B88000              <1> 	mov ax, 128
  1728 00003398 F7E3                <1> 	mul bx
  1729 0000339A 01F0                <1> 	add ax, si
  1730                              <1> 	
  1731 0000339C E84BF7              <1> 	call os_string_lowercase
  1732                              <1> 	
  1733 0000339F E915FA              <1> 	jmp mainloop
  1734                              <1> 	
  1735                              <1> .error:
  1736 000033A2 B314                <1> 	mov bl, err_syntax
  1737 000033A4 E99912              <1> 	jmp error
  1738                              <1> 
  1739                              <1> 
  1740                              <1> ; ------------------------------------------------------------------
  1741                              <1> ; CLS
  1742                              <1> 
  1743                              <1> do_cls:
  1744 000033A7 B405                <1> 	mov ah, 5
  1745 000033A9 A0[B546]            <1> 	mov byte al, [work_page]
  1746 000033AC CD10                <1> 	int 10h
  1747                              <1> 
  1748 000033AE E860E5              <1> 	call os_clear_screen
  1749                              <1> 
  1750 000033B1 B405                <1> 	mov ah, 5
  1751 000033B3 A0[B646]            <1> 	mov byte al, [disp_page]
  1752 000033B6 CD10                <1> 	int 10h
  1753                              <1> 
  1754 000033B8 E9FCF9              <1> 	jmp mainloop
  1755                              <1> 
  1756                              <1> 
  1757                              <1> 
  1758                              <1> ; ------------------------------------------------------------------
  1759                              <1> ; CURSOR
  1760                              <1> 
  1761                              <1> do_cursor:
  1762 000033BB E86911              <1> 	call get_token
  1763                              <1> 
  1764 000033BE BE007B              <1> 	mov si, token
  1765 000033C1 BF[E533]            <1> 	mov di, .on_str
  1766 000033C4 E89FF7              <1> 	call os_string_compare
  1767 000033C7 7210                <1> 	jc .turn_on
  1768                              <1> 
  1769 000033C9 BE007B              <1> 	mov si, token
  1770 000033CC BF[E833]            <1> 	mov di, .off_str
  1771 000033CF E894F7              <1> 	call os_string_compare
  1772 000033D2 720B                <1> 	jc .turn_off
  1773                              <1> 
  1774 000033D4 B314                <1> 	mov bl, err_syntax
  1775 000033D6 E96712              <1> 	jmp error
  1776                              <1> 
  1777                              <1> .turn_on:
  1778 000033D9 E880E5              <1> 	call os_show_cursor
  1779 000033DC E9D8F9              <1> 	jmp mainloop
  1780                              <1> 
  1781                              <1> .turn_off:
  1782 000033DF E885E5              <1> 	call os_hide_cursor
  1783 000033E2 E9D2F9              <1> 	jmp mainloop
  1784                              <1> 
  1785                              <1> 
  1786 000033E5 4F4E00              <1> 	.on_str db "ON", 0
  1787 000033E8 4F464600            <1> 	.off_str db "OFF", 0
  1788                              <1> 
  1789                              <1> 
  1790                              <1> ; ------------------------------------------------------------------
  1791                              <1> ; CURSCHAR
  1792                              <1> 
  1793                              <1> do_curschar:
  1794 000033EC E83811              <1> 	call get_token
  1795                              <1> 
  1796 000033EF 83F801              <1> 	cmp ax, VARIABLE
  1797 000033F2 7405                <1> 	je .is_variable
  1798                              <1> 
  1799 000033F4 B314                <1> 	mov bl, err_syntax
  1800 000033F6 E94712              <1> 	jmp error
  1801                              <1> 
  1802                              <1> .is_variable:
  1803 000033F9 31C0                <1> 	xor ax, ax
  1804 000033FB A0007B              <1> 	mov byte al, [token]
  1805                              <1> 
  1806 000033FE 50                  <1> 	push ax				; Store variable we're going to use
  1807                              <1> 
  1808 000033FF B408                <1> 	mov ah, 08h
  1809 00003401 31DB                <1> 	xor bx, bx
  1810 00003403 8A3E[B546]          <1> 	mov byte bh, [work_page]
  1811 00003407 CD10                <1> 	int 10h				; Get char at current cursor location
  1812                              <1> 
  1813 00003409 31DB                <1> 	xor bx, bx			; We only want the lower byte (the char, not attribute)
  1814 0000340B 88C3                <1> 	mov bl, al
  1815                              <1> 
  1816 0000340D 58                  <1> 	pop ax				; Get the variable back
  1817                              <1> 
  1818 0000340E E80711              <1> 	call set_var			; And store the value
  1819                              <1> 
  1820 00003411 E9A3F9              <1> 	jmp mainloop
  1821                              <1> 
  1822                              <1> 
  1823                              <1> ; ------------------------------------------------------------------
  1824                              <1> ; CURSCOL
  1825                              <1> 
  1826                              <1> do_curscol:
  1827 00003414 E81011              <1> 	call get_token
  1828                              <1> 
  1829 00003417 83F801              <1> 	cmp ax, VARIABLE
  1830 0000341A 751B                <1> 	jne .error
  1831                              <1> 
  1832 0000341C B400                <1> 	mov ah, 0
  1833 0000341E A0007B              <1> 	mov byte al, [token]
  1834 00003421 50                  <1> 	push ax
  1835                              <1> 
  1836 00003422 B408                <1> 	mov ah, 8
  1837 00003424 31DB                <1> 	xor bx, bx
  1838 00003426 8A3E[B546]          <1> 	mov byte bh, [work_page]
  1839 0000342A CD10                <1> 	int 10h
  1840 0000342C B700                <1> 	mov bh, 0
  1841 0000342E 88E3                <1> 	mov bl, ah			; Get colour for higher byte; ignore lower byte (char)
  1842                              <1> 
  1843 00003430 58                  <1> 	pop ax
  1844 00003431 E8E410              <1> 	call set_var
  1845                              <1> 
  1846 00003434 E980F9              <1> 	jmp mainloop
  1847                              <1> 
  1848                              <1> .error:
  1849 00003437 B314                <1> 	mov bl, err_syntax
  1850 00003439 E90412              <1> 	jmp error
  1851                              <1> 
  1852                              <1> 
  1853                              <1> ; ------------------------------------------------------------------
  1854                              <1> ; CURSPOS
  1855                              <1> 
  1856                              <1> do_curspos:
  1857 0000343C 8A3E[B546]          <1> 	mov byte bh, [work_page]
  1858 00003440 B403                <1> 	mov ah, 3
  1859 00003442 CD10                <1> 	int 10h
  1860                              <1> 
  1861 00003444 E8E010              <1> 	call get_token
  1862 00003447 83F801              <1> 	cmp ax, VARIABLE
  1863 0000344A 7523                <1> 	jne .error
  1864                              <1> 
  1865 0000344C 0FB606007B          <1> 	movzx ax, byte [token]
  1866 00003451 31DB                <1> 	xor bx, bx
  1867 00003453 88D3                <1> 	mov bl, dl
  1868 00003455 E8C010              <1> 	call set_var
  1869                              <1> 
  1870 00003458 E8CC10              <1> 	call get_token
  1871 0000345B 83F801              <1> 	cmp ax, VARIABLE
  1872 0000345E 750F                <1> 	jne .error
  1873                              <1> 
  1874 00003460 0FB606007B          <1> 	movzx ax, byte [token]
  1875 00003465 31DB                <1> 	xor bx, bx
  1876 00003467 88F3                <1> 	mov bl, dh
  1877 00003469 E8AC10              <1> 	call set_var
  1878                              <1> 
  1879 0000346C E948F9              <1> 	jmp mainloop
  1880                              <1> 
  1881                              <1> .error:
  1882 0000346F B314                <1> 	mov bl, err_syntax
  1883 00003471 E9CC11              <1> 	jmp error
  1884                              <1> 
  1885                              <1> 
  1886                              <1> ; ------------------------------------------------------------------
  1887                              <1> ; DELETE
  1888                              <1> 
  1889                              <1> do_delete:
  1890 00003474 E8B010              <1> 	call get_token
  1891 00003477 83F805              <1> 	cmp ax, QUOTE
  1892 0000347A 7413                <1> 	je .is_quote
  1893                              <1> 
  1894 0000347C 83F802              <1> 	cmp ax, STRING_VAR
  1895 0000347F 0F854300            <1> 	jne near .error
  1896                              <1> 
  1897 00003483 BE007C              <1> 	mov si, string_vars
  1898 00003486 B88000              <1> 	mov ax, 128
  1899 00003489 F7E3                <1> 	mul bx
  1900 0000348B 01C6                <1> 	add si, ax
  1901 0000348D EB03                <1> 	jmp .get_filename
  1902                              <1> 
  1903                              <1> .is_quote:
  1904 0000348F BE007B              <1> 	mov si, token
  1905                              <1> 
  1906                              <1> .get_filename:
  1907 00003492 89F0                <1> 	mov ax, si
  1908 00003494 E8F7DA              <1> 	call os_file_exists
  1909 00003497 7207                <1> 	jc .no_file
  1910                              <1> 
  1911 00003499 E8F1DB              <1> 	call os_remove_file
  1912 0000349C 721B                <1> 	jc .del_fail
  1913                              <1> 
  1914 0000349E EB0D                <1> 	jmp .returngood
  1915                              <1> 
  1916                              <1> .no_file:
  1917 000034A0 31C0                <1> 	xor ax, ax
  1918 000034A2 B052                <1> 	mov byte al, 'R'
  1919 000034A4 BB0200              <1> 	mov bx, 2
  1920 000034A7 E86E10              <1> 	call set_var
  1921 000034AA E90AF9              <1> 	jmp mainloop
  1922                              <1> 
  1923                              <1> .returngood:
  1924 000034AD 31C0                <1> 	xor ax, ax
  1925 000034AF B052                <1> 	mov byte al, 'R'
  1926 000034B1 31DB                <1> 	xor bx, bx
  1927 000034B3 E86210              <1> 	call set_var
  1928 000034B6 E9FEF8              <1> 	jmp mainloop
  1929                              <1> 
  1930                              <1> .del_fail:
  1931 000034B9 31C0                <1> 	xor ax, ax
  1932 000034BB B052                <1> 	mov byte al, 'R'
  1933 000034BD BB0100              <1> 	mov bx, 1
  1934 000034C0 E85510              <1> 	call set_var
  1935 000034C3 E9F1F8              <1> 	jmp mainloop
  1936                              <1> 
  1937                              <1> .error:
  1938 000034C6 B314                <1> 	mov bl, err_syntax
  1939 000034C8 E97511              <1> 	jmp error
  1940                              <1> 	
  1941                              <1> 
  1942                              <1> ; ------------------------------------------------------------------
  1943                              <1> ; DO
  1944                              <1> 
  1945                              <1> do_do:
  1946 000034CB 803E[B246]14        <1> 	cmp byte [loop_in], 20
  1947 000034D0 741C                <1> 	je .loop_max
  1948 000034D2 BFD079              <1> 	mov word di, do_loop_store
  1949 000034D5 A0[B246]            <1> 	mov byte al, [loop_in]
  1950 000034D8 B400                <1> 	mov ah, 0
  1951 000034DA 01C7                <1> 	add di, ax
  1952 000034DC A1[AB46]            <1> 	mov word ax, [prog]
  1953 000034DF 83E803              <1> 	sub ax, 3
  1954 000034E2 AB                  <1> 	stosw
  1955 000034E3 FE06[B246]          <1> 	inc byte [loop_in]
  1956 000034E7 FE06[B246]          <1> 	inc byte [loop_in]
  1957 000034EB E9C9F8              <1> 	jmp mainloop
  1958                              <1> 
  1959                              <1> .loop_max:
  1960 000034EE B303                <1> 	mov bl, err_doloop_maximum
  1961 000034F0 E94D11              <1> 	jmp error
  1962                              <1> 
  1963                              <1> 	
  1964                              <1> ;-------------------------------------------------------------------
  1965                              <1> ; ELSE
  1966                              <1> 
  1967                              <1> do_else:
  1968 000034F3 803E[B346]01        <1> 	cmp byte [last_if_true], 1
  1969 000034F8 7407                <1> 	je .last_true
  1970                              <1> 	
  1971 000034FA FF06[AB46]          <1> 	inc word [prog]
  1972 000034FE E9B6F8              <1> 	jmp mainloop
  1973                              <1> 	
  1974                              <1> .last_true:
  1975 00003501 8B36[AB46]          <1> 	mov word si, [prog]
  1976                              <1> 	
  1977                              <1> .next_line:
  1978 00003505 AC                  <1> 	lodsb
  1979 00003506 3C0A                <1> 	cmp al, 10
  1980 00003508 75FB                <1> 	jne .next_line
  1981                              <1> 	
  1982 0000350A 4E                  <1> 	dec si
  1983 0000350B 8936[AB46]          <1> 	mov word [prog], si
  1984                              <1> 	
  1985 0000350F E9A5F8              <1> 	jmp mainloop
  1986                              <1> 
  1987                              <1> 
  1988                              <1> ; ------------------------------------------------------------------
  1989                              <1> ; END
  1990                              <1> 
  1991                              <1> do_end:
  1992 00003512 B405                <1> 	mov ah, 5				; Restore active page
  1993 00003514 B000                <1> 	mov al, 0
  1994 00003516 CD10                <1> 	int 10h
  1995                              <1> 
  1996 00003518 C606[B546]00        <1> 	mov byte [work_page], 0
  1997 0000351D C606[B646]00        <1> 	mov byte [disp_page], 0
  1998                              <1> 
  1999 00003522 8B26[A946]          <1> 	mov word sp, [orig_stack]
  2000 00003526 C3                  <1> 	ret
  2001                              <1> 
  2002                              <1> 
  2003                              <1> ; ------------------------------------------------------------------
  2004                              <1> ; FILES
  2005                              <1> 
  2006                              <1> do_files:
  2007 00003527 B800FA              <1> 	mov ax, .filelist			; get a copy of the filelist
  2008 0000352A E8F0D5              <1> 	call os_get_file_list
  2009                              <1> 	
  2010 0000352D 89C6                <1> 	mov si, ax
  2011                              <1> 
  2012 0000352F E8FEE3              <1> 	call os_get_cursor_pos			; move cursor to start of line
  2013 00003532 B200                <1> 	mov dl, 0
  2014 00003534 E8F0E3              <1> 	call os_move_cursor
  2015                              <1> 	
  2016 00003537 B409                <1> 	mov ah, 9				; print character function
  2017 00003539 8A3E[B546]          <1> 	mov bh, [work_page]			; define parameters (page, colour, times)
  2018 0000353D 8A1E[B446]          <1> 	mov bl, [ink_colour]
  2019 00003541 B90100              <1> 	mov cx, 1
  2020                              <1> .file_list_loop:
  2021 00003544 AC                  <1> 	lodsb					; get a byte from the list
  2022 00003545 3C2C                <1> 	cmp al, ','				; a comma means the next file, so create a new line for it
  2023 00003547 7410                <1> 	je .nextfile
  2024                              <1> 	
  2025 00003549 3C00                <1> 	cmp al, 0				; the list is null terminated
  2026 0000354B 7438                <1> 	je .end_of_list
  2027                              <1> 	
  2028 0000354D CD10                <1> 	int 10h					; okay, it's not a comma or a null so print it
  2029                              <1> 
  2030 0000354F E8DEE3              <1> 	call os_get_cursor_pos			; find the location of the cursor
  2031 00003552 FEC2                <1> 	inc dl					; move the cursor forward
  2032 00003554 E8D0E3              <1> 	call os_move_cursor
  2033                              <1> 
  2034 00003557 EBEB                <1> 	jmp .file_list_loop			; keep going until the list is finished
  2035                              <1> 	
  2036                              <1> .nextfile:
  2037 00003559 E8D4E3              <1> 	call os_get_cursor_pos			; if the column is over 60 we need a new line
  2038 0000355C 80FA3C              <1> 	cmp dl, 60
  2039 0000355F 7D1F                <1> 	jge .newline
  2040                              <1> 
  2041                              <1> .next_column:					; print spaces until the next column
  2042 00003561 B020                <1> 	mov al, ' '
  2043 00003563 CD10                <1> 	int 10h
  2044                              <1> 	
  2045 00003565 FEC2                <1> 	inc dl
  2046 00003567 E8BDE3              <1> 	call os_move_cursor
  2047                              <1> 	
  2048 0000356A 80FA0F              <1> 	cmp dl, 15
  2049 0000356D 74D5                <1> 	je .file_list_loop
  2050                              <1> 	
  2051 0000356F 80FA1E              <1> 	cmp dl, 30
  2052 00003572 74D0                <1> 	je .file_list_loop
  2053                              <1> 	
  2054 00003574 80FA2D              <1> 	cmp dl, 45
  2055 00003577 74CB                <1> 	je .file_list_loop
  2056                              <1> 	
  2057 00003579 80FA3C              <1> 	cmp dl, 60
  2058 0000357C 74C6                <1> 	je .file_list_loop
  2059                              <1> 	
  2060 0000357E EBE1                <1> 	jmp .next_column
  2061                              <1> 	
  2062                              <1> .newline:
  2063 00003580 E87CEA              <1> 	call os_print_newline			; create a new line
  2064 00003583 EBBF                <1> 	jmp .file_list_loop
  2065                              <1> 	
  2066                              <1> .end_of_list:
  2067 00003585 E877EA              <1> 	call os_print_newline
  2068 00003588 E92CF8              <1> 	jmp mainloop				; preform next command
  2069                              <1> 	
  2070                              <1> .data:
  2071                              <1> 	.filelist		equ 64000
  2072                              <1> 	
  2073                              <1> 
  2074                              <1> 
  2075                              <1> ; ------------------------------------------------------------------
  2076                              <1> ; FOR
  2077                              <1> 
  2078                              <1> do_for:
  2079 0000358B E8990F              <1> 	call get_token				; Get the variable we're using in this loop
  2080                              <1> 
  2081 0000358E 83F801              <1> 	cmp ax, VARIABLE
  2082 00003591 0F859B00            <1> 	jne near .error
  2083                              <1> 
  2084 00003595 0FB606007B          <1> 	movzx ax, byte [token]
  2085 0000359A A2[3536]            <1> 	mov byte [.tmp_var], al			; Store it in a temporary location for now
  2086                              <1> 
  2087 0000359D E8870F              <1> 	call get_token
  2088                              <1> 
  2089 000035A0 0FB606007B          <1> 	movzx ax, byte [token]
  2090 000035A5 3C3D                <1> 	cmp al, '='
  2091 000035A7 0F858500            <1> 	jne .error
  2092                              <1> 
  2093 000035AB E8790F              <1> 	call get_token				; Next we want a number
  2094                              <1> 
  2095 000035AE 83F801              <1> 	cmp ax, VARIABLE
  2096 000035B1 740D                <1> 	je .first_is_var
  2097                              <1> 
  2098 000035B3 83F803              <1> 	cmp ax, NUMBER
  2099 000035B6 7578                <1> 	jne .error
  2100                              <1> 
  2101 000035B8 BE007B              <1> 	mov si, token				; Convert it
  2102 000035BB E8FCF5              <1> 	call os_string_to_int
  2103 000035BE EB08                <1> 	jmp .continue
  2104                              <1> 
  2105                              <1> .first_is_var:
  2106 000035C0 0FB606007B          <1> 	movzx ax, byte [token]
  2107 000035C5 E8430F              <1> 	call get_var
  2108                              <1> 	
  2109                              <1> 	; At this stage, we've read something like "FOR X = 1"
  2110                              <1> 	; so let's store that 1 in the variable table
  2111                              <1> 
  2112                              <1> .continue:
  2113 000035C8 89C3                <1> 	mov bx, ax
  2114 000035CA 0FB606[3536]        <1> 	movzx ax, byte [.tmp_var]
  2115 000035CF E8460F              <1> 	call set_var
  2116                              <1> 
  2117                              <1> 
  2118 000035D2 E8520F              <1> 	call get_token				; Next we're looking for "TO"
  2119                              <1> 
  2120 000035D5 83F804              <1> 	cmp ax, STRING
  2121 000035D8 7556                <1> 	jne .error
  2122                              <1> 
  2123 000035DA B8007B              <1> 	mov ax, token
  2124 000035DD E8EDF4              <1> 	call os_string_uppercase
  2125                              <1> 
  2126 000035E0 BE007B              <1> 	mov si, token
  2127 000035E3 BF[3636]            <1> 	mov di, .to_string
  2128 000035E6 E87DF5              <1> 	call os_string_compare
  2129 000035E9 7345                <1> 	jnc .error
  2130                              <1> 
  2131                              <1> 
  2132                              <1> 	; So now we're at "FOR X = 1 TO"
  2133                              <1> 
  2134 000035EB E8390F              <1> 	call get_token
  2135                              <1> 
  2136 000035EE 83F801              <1> 	cmp ax, VARIABLE
  2137 000035F1 740D                <1> 	je .second_is_var
  2138                              <1> 
  2139 000035F3 83F803              <1> 	cmp ax, NUMBER
  2140 000035F6 7538                <1> 	jne .error
  2141                              <1> 
  2142                              <1> .second_is_number:
  2143 000035F8 BE007B              <1> 	mov si, token					; Get target number
  2144 000035FB E8BCF5              <1> 	call os_string_to_int
  2145 000035FE EB08                <1> 	jmp .continue2
  2146                              <1> 
  2147                              <1> .second_is_var:
  2148 00003600 0FB606007B          <1> 	movzx ax, byte [token]
  2149 00003605 E8030F              <1> 	call get_var
  2150                              <1> 
  2151                              <1> .continue2:
  2152 00003608 89C3                <1> 	mov bx, ax
  2153                              <1> 
  2154 0000360A 0FB606[3536]        <1> 	movzx ax, byte [.tmp_var]
  2155                              <1> 
  2156 0000360F 2C41                <1> 	sub al, 65					; Store target number in table
  2157 00003611 BF187A              <1> 	mov di, for_variables
  2158 00003614 01C7                <1> 	add di, ax
  2159 00003616 01C7                <1> 	add di, ax
  2160 00003618 89D8                <1> 	mov ax, bx
  2161 0000361A AB                  <1> 	stosw
  2162                              <1> 
  2163                              <1> 
  2164                              <1> 	; So we've got the variable, assigned it the starting number, and put into
  2165                              <1> 	; our table the limit it should reach. But we also need to store the point in
  2166                              <1> 	; code after the FOR line we should return to if NEXT X doesn't complete the loop...
  2167                              <1> 
  2168 0000361B 0FB606[3536]        <1> 	movzx ax, byte [.tmp_var]
  2169                              <1> 
  2170 00003620 2C41                <1> 	sub al, 65					; Store code position to return to in table
  2171 00003622 BFE479              <1> 	mov di, for_code_points
  2172 00003625 01C7                <1> 	add di, ax
  2173 00003627 01C7                <1> 	add di, ax
  2174 00003629 A1[AB46]            <1> 	mov word ax, [prog]
  2175 0000362C AB                  <1> 	stosw
  2176                              <1> 
  2177 0000362D E987F7              <1> 	jmp mainloop
  2178                              <1> 
  2179                              <1> 
  2180                              <1> .error:
  2181 00003630 B314                <1> 	mov bl, err_syntax
  2182 00003632 E90B10              <1> 	jmp error
  2183                              <1> 
  2184                              <1> 
  2185 00003635 00                  <1> 	.tmp_var	db 0
  2186 00003636 544F00              <1> 	.to_string	db 'TO', 0
  2187                              <1> 
  2188                              <1> 
  2189                              <1> ; ------------------------------------------------------------------
  2190                              <1> ; GETKEY
  2191                              <1> 
  2192                              <1> do_getkey:
  2193 00003639 E8EB0E              <1> 	call get_token
  2194 0000363C 83F801              <1> 	cmp ax, VARIABLE
  2195 0000363F 7405                <1> 	je .is_variable
  2196                              <1> 
  2197 00003641 B314                <1> 	mov bl, err_syntax
  2198 00003643 E9FA0F              <1> 	jmp error
  2199                              <1> 
  2200                              <1> .is_variable:
  2201 00003646 0FB606007B          <1> 	movzx ax, byte [token]
  2202                              <1> 
  2203 0000364B 50                  <1> 	push ax
  2204                              <1> 
  2205 0000364C E88BDD              <1> 	call os_check_for_key
  2206                              <1> 
  2207 0000364F 3DE048              <1> 	cmp ax, 48E0h
  2208 00003652 7419                <1> 	je .up_pressed
  2209                              <1> 
  2210 00003654 3DE050              <1> 	cmp ax, 50E0h
  2211 00003657 7419                <1> 	je .down_pressed
  2212                              <1> 
  2213 00003659 3DE04B              <1> 	cmp ax, 4BE0h
  2214 0000365C 7419                <1> 	je .left_pressed
  2215                              <1> 
  2216 0000365E 3DE04D              <1> 	cmp ax, 4DE0h
  2217 00003661 7419                <1> 	je .right_pressed
  2218                              <1> 
  2219                              <1> .store:	
  2220 00003663 0FB6D8              <1> 	movzx bx, al
  2221                              <1> 	
  2222 00003666 58                  <1> 	pop ax
  2223                              <1> 
  2224 00003667 E8AE0E              <1> 	call set_var
  2225                              <1> 
  2226 0000366A E94AF7              <1> 	jmp mainloop
  2227                              <1> 
  2228                              <1> .up_pressed:
  2229 0000366D B80100              <1> 	mov ax, 1
  2230 00003670 EBF1                <1> 	jmp .store
  2231                              <1> 
  2232                              <1> .down_pressed:
  2233 00003672 B80200              <1> 	mov ax, 2
  2234 00003675 EBEC                <1> 	jmp .store
  2235                              <1> 
  2236                              <1> .left_pressed:
  2237 00003677 B80300              <1> 	mov ax, 3
  2238 0000367A EBE7                <1> 	jmp .store
  2239                              <1> 
  2240                              <1> .right_pressed:
  2241 0000367C B80400              <1> 	mov ax, 4
  2242 0000367F EBE2                <1> 	jmp .store
  2243                              <1> 
  2244                              <1> ; ------------------------------------------------------------------
  2245                              <1> ; GOSUB
  2246                              <1> 
  2247                              <1> do_gosub:
  2248 00003681 E8A30E              <1> 	call get_token				; Get the number (label)
  2249                              <1> 
  2250 00003684 83F804              <1> 	cmp ax, STRING
  2251 00003687 7405                <1> 	je .is_ok
  2252                              <1> 
  2253 00003689 B305                <1> 	mov bl, err_goto_notlabel
  2254 0000368B E9B20F              <1> 	jmp error
  2255                              <1> 
  2256                              <1> .is_ok:
  2257 0000368E BE007B              <1> 	mov si, token				; Back up this label
  2258 00003691 BF[0037]            <1> 	mov di, .tmp_token
  2259 00003694 E870F4              <1> 	call os_string_copy
  2260                              <1> 
  2261 00003697 B8[0037]            <1> 	mov ax, .tmp_token
  2262 0000369A E8D7F3              <1> 	call os_string_length
  2263                              <1> 
  2264 0000369D BF[0037]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2265 000036A0 01C7                <1> 	add di, ax
  2266 000036A2 B03A                <1> 	mov al, ':'
  2267 000036A4 AA                  <1> 	stosb
  2268 000036A5 B000                <1> 	mov al, 0
  2269 000036A7 AA                  <1> 	stosb	
  2270                              <1> 
  2271                              <1> 
  2272 000036A8 FE06[2248]          <1> 	inc byte [gosub_depth]
  2273                              <1> 
  2274 000036AC 0FB606[2248]        <1> 	movzx ax, byte [gosub_depth]		; Get current GOSUB nest level
  2275                              <1> 
  2276 000036B1 3C09                <1> 	cmp al, 9
  2277 000036B3 7E05                <1> 	jle .within_limit
  2278                              <1> 
  2279 000036B5 B307                <1> 	mov bl, err_nest_limit
  2280 000036B7 E9860F              <1> 	jmp error
  2281                              <1> 
  2282                              <1> 
  2283                              <1> .within_limit:
  2284 000036BA BFBC79              <1> 	mov di, gosub_points			; Move into our table of pointers
  2285 000036BD 01C7                <1> 	add di, ax				; Table is words (not bytes)
  2286 000036BF 01C7                <1> 	add di, ax
  2287 000036C1 A1[AB46]            <1> 	mov word ax, [prog]
  2288 000036C4 AB                  <1> 	stosw					; Store current location before jump
  2289                              <1> 
  2290                              <1> 
  2291 000036C5 A1[AF46]            <1> 	mov word ax, [load_point]
  2292 000036C8 A3[AB46]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2293                              <1> 
  2294                              <1> .loop:
  2295 000036CB E8590E              <1> 	call get_token
  2296                              <1> 
  2297 000036CE 83F808              <1> 	cmp ax, LABEL
  2298 000036D1 750D                <1> 	jne .line_loop
  2299                              <1> 
  2300 000036D3 BE007B              <1> 	mov si, token
  2301 000036D6 BF[0037]            <1> 	mov di, .tmp_token
  2302 000036D9 E88AF4              <1> 	call os_string_compare
  2303 000036DC 0F82D7F6            <1> 	jc mainloop
  2304                              <1> 
  2305                              <1> 
  2306                              <1> .line_loop:					; Go to end of line
  2307 000036E0 8B36[AB46]          <1> 	mov word si, [prog]
  2308 000036E4 8A04                <1> 	mov byte al, [si]
  2309 000036E6 FF06[AB46]          <1> 	inc word [prog]
  2310 000036EA 3C0A                <1> 	cmp al, 10
  2311 000036EC 75F2                <1> 	jne .line_loop
  2312                              <1> 
  2313 000036EE A1[AB46]            <1> 	mov word ax, [prog]
  2314 000036F1 8B1E[AD46]          <1> 	mov word bx, [prog_end]
  2315 000036F5 39D8                <1> 	cmp ax, bx
  2316 000036F7 7F02                <1> 	jg .past_end
  2317                              <1> 
  2318 000036F9 EBD0                <1> 	jmp .loop
  2319                              <1> 
  2320                              <1> 
  2321                              <1> .past_end:
  2322 000036FB B306                <1> 	mov bl, err_label_notfound
  2323 000036FD E9400F              <1> 	jmp error
  2324                              <1> 
  2325                              <1> 
  2326 00003700 00<rep 1Eh>         <1> 	.tmp_token	times 30 db 0
  2327                              <1> 
  2328                              <1> 
  2329                              <1> ; ------------------------------------------------------------------
  2330                              <1> ; GOTO
  2331                              <1> 
  2332                              <1> do_goto:
  2333 0000371E E8060E              <1> 	call get_token				; Get the next token
  2334                              <1> 
  2335 00003721 83F804              <1> 	cmp ax, STRING
  2336 00003724 7405                <1> 	je .is_ok
  2337                              <1> 
  2338 00003726 B305                <1> 	mov bl, err_goto_notlabel
  2339 00003728 E9150F              <1> 	jmp error
  2340                              <1> 
  2341                              <1> .is_ok:
  2342 0000372B BE007B              <1> 	mov si, token				; Back up this label
  2343 0000372E BF[8037]            <1> 	mov di, .tmp_token
  2344 00003731 E8D3F3              <1> 	call os_string_copy
  2345                              <1> 
  2346 00003734 B8[8037]            <1> 	mov ax, .tmp_token
  2347 00003737 E83AF3              <1> 	call os_string_length
  2348                              <1> 
  2349 0000373A BF[8037]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2350 0000373D 01C7                <1> 	add di, ax
  2351 0000373F B03A                <1> 	mov al, ':'
  2352 00003741 AA                  <1> 	stosb
  2353 00003742 B000                <1> 	mov al, 0
  2354 00003744 AA                  <1> 	stosb	
  2355                              <1> 
  2356 00003745 A1[AF46]            <1> 	mov word ax, [load_point]
  2357 00003748 A3[AB46]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2358                              <1> 
  2359                              <1> .loop:
  2360 0000374B E8D90D              <1> 	call get_token
  2361                              <1> 
  2362 0000374E 83F808              <1> 	cmp ax, LABEL
  2363 00003751 750D                <1> 	jne .line_loop
  2364                              <1> 
  2365 00003753 BE007B              <1> 	mov si, token
  2366 00003756 BF[8037]            <1> 	mov di, .tmp_token
  2367 00003759 E80AF4              <1> 	call os_string_compare
  2368 0000375C 0F8257F6            <1> 	jc mainloop
  2369                              <1> 
  2370                              <1> .line_loop:					; Go to end of line
  2371 00003760 8B36[AB46]          <1> 	mov word si, [prog]
  2372 00003764 8A04                <1> 	mov byte al, [si]
  2373 00003766 FF06[AB46]          <1> 	inc word [prog]
  2374                              <1> 
  2375 0000376A 3C0A                <1> 	cmp al, 10
  2376 0000376C 75F2                <1> 	jne .line_loop
  2377                              <1> 
  2378 0000376E A1[AB46]            <1> 	mov word ax, [prog]
  2379 00003771 8B1E[AD46]          <1> 	mov word bx, [prog_end]
  2380 00003775 39D8                <1> 	cmp ax, bx
  2381 00003777 7F02                <1> 	jg .past_end
  2382                              <1> 
  2383 00003779 EBD0                <1> 	jmp .loop
  2384                              <1> 
  2385                              <1> .past_end:
  2386 0000377B B306                <1> 	mov bl, err_label_notfound
  2387 0000377D E9C00E              <1> 	jmp error
  2388                              <1> 
  2389                              <1> 
  2390 00003780 00<rep 1Eh>         <1> 	.tmp_token 	times 30 db 0
  2391                              <1> 
  2392                              <1> 
  2393                              <1> ; ------------------------------------------------------------------
  2394                              <1> ; IF
  2395                              <1> 
  2396                              <1> do_if:
  2397 0000379E E8860D              <1> 	call get_token
  2398                              <1> 
  2399 000037A1 83F801              <1> 	cmp ax, VARIABLE			; If can only be followed by a variable
  2400 000037A4 740C                <1> 	je .num_var
  2401                              <1> 
  2402 000037A6 83F802              <1> 	cmp ax, STRING_VAR
  2403 000037A9 0F84B300            <1> 	je near .string_var
  2404                              <1> 
  2405 000037AD B314                <1> 	mov bl, err_syntax
  2406 000037AF E98E0E              <1> 	jmp error
  2407                              <1> 
  2408                              <1> .num_var:
  2409 000037B2 0FB606007B          <1> 	movzx ax, byte [token]
  2410 000037B7 E8510D              <1> 	call get_var
  2411                              <1> 
  2412 000037BA 89C2                <1> 	mov dx, ax				; Store value of first part of comparison
  2413                              <1> 
  2414 000037BC E8680D              <1> 	call get_token				; Get the delimiter
  2415 000037BF A0007B              <1> 	mov byte al, [token]
  2416 000037C2 3C3D                <1> 	cmp al, '='
  2417 000037C4 740D                <1> 	je .equals
  2418 000037C6 3C3E                <1> 	cmp al, '>'
  2419 000037C8 7447                <1> 	je .greater
  2420 000037CA 3C3C                <1> 	cmp al, '<'
  2421 000037CC 746C                <1> 	je .less
  2422                              <1> 
  2423 000037CE B314                <1> 	mov bl, err_syntax			; If not one of the above, error out
  2424 000037D0 E96D0E              <1> 	jmp error
  2425                              <1> 
  2426                              <1> .equals:
  2427 000037D3 E8510D              <1> 	call get_token				; Is this 'X = Y' (equals another variable?)
  2428                              <1> 
  2429 000037D6 83F806              <1> 	cmp ax, CHAR
  2430 000037D9 7417                <1> 	je .equals_char
  2431                              <1> 
  2432 000037DB A0007B              <1> 	mov byte al, [token]
  2433 000037DE E8530E              <1> 	call is_letter
  2434 000037E1 721D                <1> 	jc .equals_var
  2435                              <1> 
  2436 000037E3 BE007B              <1> 	mov si, token				; Otherwise it's, eg 'X = 1' (a number)
  2437 000037E6 E8D1F3              <1> 	call os_string_to_int
  2438                              <1> 
  2439 000037E9 39D0                <1> 	cmp ax, dx				; On to the THEN bit if 'X = num' matches
  2440 000037EB 0F84C200            <1> 	je near .on_to_then
  2441                              <1> 
  2442 000037EF E9E700              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2443                              <1> 
  2444                              <1> 
  2445                              <1> .equals_char:
  2446 000037F2 0FB606007B          <1> 	movzx ax, byte [token]
  2447                              <1> 
  2448 000037F7 39D0                <1> 	cmp ax, dx
  2449 000037F9 0F84B400            <1> 	je near .on_to_then
  2450                              <1> 
  2451 000037FD E9D900              <1> 	jmp .finish_line
  2452                              <1> 
  2453                              <1> 
  2454                              <1> .equals_var:
  2455 00003800 0FB606007B          <1> 	movzx ax, byte [token]
  2456                              <1> 
  2457 00003805 E8030D              <1> 	call get_var
  2458                              <1> 
  2459 00003808 39D0                <1> 	cmp ax, dx				; Do the variables match?
  2460 0000380A 0F84A300            <1> 	je near .on_to_then				; On to the THEN bit if so
  2461                              <1> 
  2462 0000380E E9C800              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2463                              <1> 
  2464                              <1> 
  2465                              <1> .greater:
  2466 00003811 E8130D              <1> 	call get_token				; Greater than a variable or number?
  2467 00003814 A0007B              <1> 	mov byte al, [token]
  2468 00003817 E81A0E              <1> 	call is_letter
  2469 0000381A 720F                <1> 	jc .greater_var
  2470                              <1> 
  2471 0000381C BE007B              <1> 	mov si, token				; Must be a number here...
  2472 0000381F E898F3              <1> 	call os_string_to_int
  2473                              <1> 
  2474 00003822 39D0                <1> 	cmp ax, dx
  2475 00003824 0F8C8900            <1> 	jl near .on_to_then
  2476                              <1> 
  2477 00003828 E9AE00              <1> 	jmp .finish_line
  2478                              <1> 
  2479                              <1> .greater_var:					; Variable in this case
  2480 0000382B 0FB606007B          <1> 	movzx ax, byte [token]
  2481                              <1> 
  2482 00003830 E8D80C              <1> 	call get_var
  2483                              <1> 
  2484 00003833 39D0                <1> 	cmp ax, dx				; Make the comparison!
  2485 00003835 7C7A                <1> 	jl .on_to_then
  2486                              <1> 
  2487 00003837 E99F00              <1> 	jmp .finish_line
  2488                              <1> 
  2489                              <1> .less:
  2490 0000383A E8EA0C              <1> 	call get_token
  2491 0000383D A0007B              <1> 	mov byte al, [token]
  2492 00003840 E8F10D              <1> 	call is_letter
  2493 00003843 720D                <1> 	jc .less_var
  2494                              <1> 
  2495 00003845 BE007B              <1> 	mov si, token
  2496 00003848 E86FF3              <1> 	call os_string_to_int
  2497                              <1> 
  2498 0000384B 39D0                <1> 	cmp ax, dx
  2499 0000384D 7F62                <1> 	jg .on_to_then
  2500                              <1> 
  2501 0000384F E98700              <1> 	jmp .finish_line
  2502                              <1> 
  2503                              <1> .less_var:
  2504 00003852 0FB606007B          <1> 	movzx ax, byte [token]
  2505                              <1> 
  2506 00003857 E8B10C              <1> 	call get_var
  2507                              <1> 
  2508 0000385A 39D0                <1> 	cmp ax, dx
  2509 0000385C 7F53                <1> 	jg .on_to_then
  2510                              <1> 
  2511 0000385E EB79                <1> 	jmp .finish_line
  2512                              <1> 
  2513                              <1> 
  2514                              <1> 
  2515                              <1> .string_var:
  2516 00003860 881E[F438]          <1> 	mov byte [.tmp_string_var], bl
  2517                              <1> 
  2518 00003864 E8C00C              <1> 	call get_token
  2519                              <1> 
  2520 00003867 A0007B              <1> 	mov byte al, [token]
  2521 0000386A 3C3D                <1> 	cmp al, '='
  2522 0000386C 0F857F00            <1> 	jne .error
  2523                              <1> 
  2524 00003870 E8B40C              <1> 	call get_token
  2525 00003873 83F802              <1> 	cmp ax, STRING_VAR
  2526 00003876 7419                <1> 	je .second_is_string_var
  2527                              <1> 
  2528 00003878 83F805              <1> 	cmp ax, QUOTE
  2529 0000387B 7572                <1> 	jne .error
  2530                              <1> 
  2531 0000387D BE007C              <1> 	mov si, string_vars
  2532 00003880 B88000              <1> 	mov ax, 128
  2533 00003883 F7E3                <1> 	mul bx
  2534 00003885 01C6                <1> 	add si, ax
  2535 00003887 BF007B              <1> 	mov di, token
  2536 0000388A E8D9F2              <1> 	call os_string_compare
  2537 0000388D 7422                <1> 	je .on_to_then
  2538                              <1> 
  2539 0000388F EB48                <1> 	jmp .finish_line
  2540                              <1> 
  2541                              <1> 
  2542                              <1> .second_is_string_var:
  2543 00003891 BE007C              <1> 	mov si, string_vars
  2544 00003894 B88000              <1> 	mov ax, 128
  2545 00003897 F7E3                <1> 	mul bx
  2546 00003899 01C6                <1> 	add si, ax
  2547                              <1> 
  2548 0000389B BF007C              <1> 	mov di, string_vars
  2549 0000389E 0FB61E[F438]        <1> 	movzx bx, byte [.tmp_string_var]
  2550 000038A3 B88000              <1> 	mov ax, 128
  2551 000038A6 F7E3                <1> 	mul bx
  2552 000038A8 01C7                <1> 	add di, ax
  2553                              <1> 
  2554 000038AA E8B9F2              <1> 	call os_string_compare
  2555 000038AD 7202                <1> 	jc .on_to_then
  2556                              <1> 
  2557 000038AF EB28                <1> 	jmp .finish_line
  2558                              <1> 
  2559                              <1> 
  2560                              <1> .on_to_then:
  2561 000038B1 E8730C              <1> 	call get_token
  2562                              <1> 
  2563 000038B4 BE007B              <1> 	mov si, token			; Look for AND for more comparison
  2564 000038B7 BF[D647]            <1> 	mov di, and_keyword
  2565 000038BA E8A9F2              <1> 	call os_string_compare
  2566 000038BD 0F82DDFE            <1> 	jc do_if
  2567                              <1> 
  2568 000038C1 BE007B              <1> 	mov si, token			; Look for THEN to perform more operations
  2569 000038C4 BF[DA47]            <1> 	mov di, then_keyword
  2570 000038C7 E89CF2              <1> 	call os_string_compare
  2571 000038CA 7205                <1> 	jc .then_present
  2572                              <1> 
  2573 000038CC B314                <1> 	mov bl, err_syntax
  2574 000038CE E96F0D              <1> 	jmp error
  2575                              <1> 
  2576                              <1> .then_present:				; Continue rest of line like any other command!
  2577 000038D1 C606[B346]01        <1> 	mov byte [last_if_true], 1
  2578 000038D6 E9DEF4              <1> 	jmp mainloop
  2579                              <1> 
  2580                              <1> 
  2581                              <1> .finish_line:				; IF wasn't fulfilled, so skip rest of line
  2582 000038D9 8B36[AB46]          <1> 	mov word si, [prog]
  2583 000038DD 8A04                <1> 	mov byte al, [si]
  2584 000038DF FF06[AB46]          <1> 	inc word [prog]
  2585 000038E3 3C0A                <1> 	cmp al, 10
  2586 000038E5 75F2                <1> 	jne .finish_line
  2587                              <1> 
  2588 000038E7 C606[B346]00        <1> 	mov byte [last_if_true], 0
  2589 000038EC E9C8F4              <1> 	jmp mainloop
  2590                              <1> 
  2591                              <1> 
  2592                              <1> .error:
  2593 000038EF B314                <1> 	mov bl, err_syntax
  2594 000038F1 E94C0D              <1> 	jmp error
  2595                              <1> 
  2596                              <1> 
  2597 000038F4 00                  <1> 	.tmp_string_var		db 0
  2598                              <1> 
  2599                              <1> 
  2600                              <1> ; ------------------------------------------------------------------
  2601                              <1> ; INCLUDE
  2602                              <1> 
  2603                              <1> do_include:
  2604 000038F5 E82F0C              <1> 	call get_token
  2605 000038F8 83F805              <1> 	cmp ax, QUOTE
  2606 000038FB 7406                <1> 	je .is_ok
  2607                              <1> 
  2608 000038FD BE1400              <1> 	mov si, err_syntax
  2609 00003900 E93D0D              <1> 	jmp error
  2610                              <1> 
  2611                              <1> .is_ok:
  2612 00003903 B8007B              <1> 	mov ax, token
  2613 00003906 8B0E[AD46]          <1> 	mov word cx, [prog_end]
  2614 0000390A 41                  <1> 	inc cx				; Add a bit of space after original code
  2615 0000390B 41                  <1> 	inc cx
  2616 0000390C 41                  <1> 	inc cx
  2617 0000390D 51                  <1> 	push cx
  2618 0000390E E839D3              <1> 	call os_load_file
  2619 00003911 720A                <1> 	jc .load_fail
  2620                              <1> 
  2621 00003913 59                  <1> 	pop cx
  2622 00003914 01D9                <1> 	add cx, bx
  2623 00003916 890E[AD46]          <1> 	mov word [prog_end], cx
  2624                              <1> 
  2625 0000391A E99AF4              <1> 	jmp mainloop
  2626                              <1> 
  2627                              <1> 
  2628                              <1> .load_fail:
  2629 0000391D 59                  <1> 	pop cx
  2630 0000391E BE0400              <1> 	mov si, err_file_notfound
  2631 00003921 E91C0D              <1> 	jmp error
  2632                              <1> 
  2633                              <1> 
  2634                              <1> ; ------------------------------------------------------------------
  2635                              <1> ; INK
  2636                              <1> 
  2637                              <1> do_ink:
  2638 00003924 E8000C              <1> 	call get_token				; Get column
  2639                              <1> 
  2640 00003927 83F801              <1> 	cmp ax, VARIABLE
  2641 0000392A 740C                <1> 	je .first_is_var
  2642                              <1> 
  2643 0000392C BE007B              <1> 	mov si, token
  2644 0000392F E888F2              <1> 	call os_string_to_int
  2645 00003932 A2[B446]            <1> 	mov byte [ink_colour], al
  2646 00003935 E97FF4              <1> 	jmp mainloop
  2647                              <1> 
  2648                              <1> .first_is_var:
  2649 00003938 B80000              <1> 	mov ax, 0
  2650 0000393B A0007B              <1> 	mov byte al, [token]
  2651 0000393E E8CA0B              <1> 	call get_var
  2652 00003941 A2[B446]            <1> 	mov byte [ink_colour], al
  2653 00003944 E970F4              <1> 	jmp mainloop
  2654                              <1> 
  2655                              <1> 
  2656                              <1> ; ------------------------------------------------------------------
  2657                              <1> ; INPUT
  2658                              <1> 
  2659                              <1> do_input:
  2660 00003947 B000                <1> 	mov al, 0				; Clear string from previous usage
  2661 00003949 BF807A              <1> 	mov di, .tmpstring
  2662 0000394C B98000              <1> 	mov cx, 128
  2663 0000394F F3AA                <1> 	rep stosb
  2664                              <1> 
  2665 00003951 E8D30B              <1> 	call get_token
  2666                              <1> 
  2667 00003954 83F801              <1> 	cmp ax, VARIABLE			; We can only INPUT to variables!
  2668 00003957 740B                <1> 	je .number_var
  2669                              <1> 
  2670 00003959 83F802              <1> 	cmp ax, STRING_VAR
  2671 0000395C 7437                <1> 	je .string_var
  2672                              <1> 
  2673 0000395E BE1400              <1> 	mov si, err_syntax
  2674 00003961 E9DC0C              <1> 	jmp error
  2675                              <1> 
  2676                              <1> .number_var:
  2677 00003964 B8807A              <1> 	mov ax, .tmpstring			; Get input from the user
  2678 00003967 E804E9              <1> 	call os_input_string
  2679                              <1> 
  2680 0000396A B8807A              <1> 	mov ax, .tmpstring
  2681 0000396D E804F1              <1> 	call os_string_length
  2682 00003970 83F800              <1> 	cmp ax, 0
  2683 00003973 750A                <1> 	jne .char_entered
  2684                              <1> 
  2685 00003975 C606807A30          <1> 	mov byte [.tmpstring], '0'		; If enter hit, fill variable with zero
  2686 0000397A C606817A00          <1> 	mov byte [.tmpstring + 1], 0
  2687                              <1> 
  2688                              <1> .char_entered:
  2689 0000397F BE807A              <1> 	mov si, .tmpstring			; Convert to integer format
  2690 00003982 E835F2              <1> 	call os_string_to_int
  2691 00003985 89C3                <1> 	mov bx, ax
  2692                              <1> 
  2693 00003987 0FB606007B          <1> 	movzx ax, byte [token]
  2694 0000398C E8890B              <1> 	call set_var				; ...and store it!
  2695                              <1> 
  2696 0000398F E86DE6              <1> 	call os_print_newline
  2697                              <1> 
  2698 00003992 E922F4              <1> 	jmp mainloop
  2699                              <1> 
  2700                              <1> 
  2701                              <1> .string_var:
  2702 00003995 53                  <1> 	push bx
  2703                              <1> 
  2704 00003996 B8807A              <1> 	mov ax, .tmpstring
  2705 00003999 E8D2E8              <1> 	call os_input_string
  2706                              <1> 
  2707 0000399C BE807A              <1> 	mov si, .tmpstring
  2708 0000399F BF007C              <1> 	mov di, string_vars
  2709                              <1> 
  2710 000039A2 5B                  <1> 	pop bx
  2711                              <1> 
  2712 000039A3 B88000              <1> 	mov ax, 128
  2713 000039A6 F7E3                <1> 	mul bx
  2714                              <1> 
  2715 000039A8 01C7                <1> 	add di, ax
  2716 000039AA E85AF1              <1> 	call os_string_copy
  2717                              <1> 
  2718 000039AD E84FE6              <1> 	call os_print_newline
  2719                              <1> 
  2720 000039B0 E904F4              <1> 	jmp mainloop
  2721                              <1> 
  2722                              <1> 
  2723                              <1> ;	.tmpstring	times 128 db 0
  2724                              <1> 	.tmpstring	equ 32768-1024-256-128
  2725                              <1> 
  2726                              <1> ; -----------------------------------------------------------
  2727                              <1> ; LEN
  2728                              <1> 
  2729                              <1> do_len:
  2730 000039B3 E8710B              <1> 	call get_token
  2731 000039B6 83F802              <1> 	cmp ax, STRING_VAR
  2732 000039B9 7538                <1> 	jne .error
  2733                              <1>  
  2734 000039BB BE007C              <1> 	mov si, string_vars
  2735 000039BE B88000              <1> 	mov ax, 128
  2736 000039C1 F7E3                <1> 	mul bx
  2737 000039C3 01C6                <1> 	add si, ax
  2738                              <1> 
  2739 000039C5 89F0                <1> 	mov ax, si
  2740 000039C7 E8AAF0              <1> 	call os_string_length
  2741 000039CA A3[F939]            <1> 	mov word [.num1], ax
  2742                              <1> 
  2743 000039CD E8570B              <1> 	call get_token
  2744 000039D0 83F801              <1> 	cmp ax, VARIABLE
  2745 000039D3 7406                <1> 	je .is_ok
  2746                              <1> 	
  2747 000039D5 BE1400              <1> 	mov si, err_syntax
  2748 000039D8 E9650C              <1> 	jmp error
  2749                              <1> 
  2750                              <1> .is_ok:
  2751 000039DB 0FB606007B          <1> 	movzx ax, byte [token]
  2752 000039E0 88C3                <1> 	mov bl, al
  2753 000039E2 EB00                <1> 	jmp .finish
  2754                              <1> 
  2755                              <1> .finish:	
  2756 000039E4 8B1E[F939]          <1> 	mov bx, [.num1]
  2757 000039E8 A0007B              <1> 	mov byte al, [token]
  2758 000039EB E82A0B              <1> 	call set_var
  2759 000039EE 31C0                <1> 	xor ax, ax
  2760 000039F0 E9C4F3              <1> 	jmp mainloop
  2761                              <1>  
  2762                              <1> .error:
  2763 000039F3 BE1400              <1> 	mov si, err_syntax
  2764 000039F6 E9470C              <1> 	jmp error
  2765                              <1> 
  2766                              <1> 
  2767 000039F9 0000                <1> 	.num1 dw 0
  2768                              <1> 
  2769                              <1> 
  2770                              <1> ; ------------------------------------------------------------------
  2771                              <1> ; LISTBOX
  2772                              <1> 
  2773                              <1> do_listbox:
  2774 000039FB 8A3E[B546]          <1> 	mov bh, [work_page]			; Store the cursor position
  2775 000039FF B403                <1> 	mov ah, 03h
  2776 00003A01 CD10                <1> 	int 10h
  2777                              <1> 	
  2778 00003A03 E8210B              <1> 	call get_token
  2779 00003A06 83F802              <1> 	cmp ax, STRING_VAR
  2780 00003A09 757C                <1> 	jne .error
  2781                              <1> 
  2782 00003A0B BE007C              <1> 	mov si, string_vars
  2783 00003A0E B88000              <1> 	mov ax, 128
  2784 00003A11 F7E3                <1> 	mul bx
  2785 00003A13 01C6                <1> 	add si, ax
  2786                              <1> 
  2787 00003A15 8936[8D3A]          <1> 	mov word [.s1], si
  2788                              <1> 
  2789 00003A19 E80B0B              <1> 	call get_token
  2790 00003A1C 83F802              <1> 	cmp ax, STRING_VAR
  2791 00003A1F 7566                <1> 	jne .error
  2792                              <1> 
  2793 00003A21 BE007C              <1> 	mov si, string_vars
  2794 00003A24 B88000              <1> 	mov ax, 128
  2795 00003A27 F7E3                <1> 	mul bx
  2796 00003A29 01C6                <1> 	add si, ax
  2797                              <1> 
  2798 00003A2B 8936[8F3A]          <1> 	mov word [.s2], si
  2799                              <1> 
  2800 00003A2F E8F50A              <1> 	call get_token
  2801 00003A32 83F802              <1> 	cmp ax, STRING_VAR
  2802 00003A35 7550                <1> 	jne .error
  2803                              <1> 
  2804 00003A37 BE007C              <1> 	mov si, string_vars
  2805 00003A3A B88000              <1> 	mov ax, 128
  2806 00003A3D F7E3                <1> 	mul bx
  2807 00003A3F 01C6                <1> 	add si, ax
  2808                              <1> 
  2809 00003A41 8936[913A]          <1> 	mov word [.s3], si
  2810                              <1> 
  2811                              <1> 
  2812 00003A45 E8DF0A              <1> 	call get_token
  2813 00003A48 83F801              <1> 	cmp ax, VARIABLE
  2814 00003A4B 753A                <1> 	jne .error
  2815                              <1> 
  2816 00003A4D A0007B              <1> 	mov byte al, [token]
  2817 00003A50 A2[933A]            <1> 	mov byte [.var], al
  2818                              <1> 
  2819 00003A53 A1[8D3A]            <1> 	mov word ax, [.s1]
  2820 00003A56 8B1E[8F3A]          <1> 	mov word bx, [.s2]
  2821 00003A5A 8B0E[913A]          <1> 	mov word cx, [.s3]
  2822                              <1> 
  2823 00003A5E E814E2              <1> 	call os_list_dialog
  2824 00003A61 7217                <1> 	jc .esc_pressed
  2825                              <1> 
  2826 00003A63 60                  <1> 	pusha
  2827 00003A64 8A3E[B546]          <1> 	mov bh, [work_page]			; Move the cursor back
  2828 00003A68 B402                <1> 	mov ah, 02h
  2829 00003A6A CD10                <1> 	int 10h
  2830 00003A6C 61                  <1> 	popa
  2831                              <1> 
  2832 00003A6D 89C3                <1> 	mov bx, ax
  2833 00003A6F 0FB606[933A]        <1> 	movzx ax, byte [.var]
  2834 00003A74 E8A10A              <1> 	call set_var
  2835                              <1> 
  2836 00003A77 E93DF3              <1> 	jmp mainloop
  2837                              <1> 
  2838                              <1> 
  2839                              <1> .esc_pressed:
  2840 00003A7A 0FB606[933A]        <1> 	movzx ax, byte [.var]
  2841 00003A7F 31DB                <1> 	xor bx, bx
  2842 00003A81 E8940A              <1> 	call set_var
  2843 00003A84 E930F3              <1> 	jmp mainloop
  2844                              <1> 
  2845                              <1> 
  2846                              <1> .error:
  2847 00003A87 BE1400              <1> 	mov si, err_syntax
  2848 00003A8A E9B30B              <1> 	jmp error
  2849                              <1> 
  2850 00003A8D 0000                <1> 	.s1 dw 0
  2851 00003A8F 0000                <1> 	.s2 dw 0
  2852 00003A91 0000                <1> 	.s3 dw 0
  2853 00003A93 00                  <1> 	.var db 0
  2854                              <1> 
  2855                              <1> 
  2856                              <1> ; ------------------------------------------------------------------
  2857                              <1> ; LOAD
  2858                              <1> 
  2859                              <1> do_load:
  2860 00003A94 E8900A              <1> 	call get_token
  2861 00003A97 83F805              <1> 	cmp ax, QUOTE
  2862 00003A9A 7411                <1> 	je .is_quote
  2863                              <1> 
  2864 00003A9C 83F802              <1> 	cmp ax, STRING_VAR
  2865 00003A9F 755F                <1> 	jne .error
  2866                              <1> 
  2867 00003AA1 BE007C              <1> 	mov si, string_vars
  2868 00003AA4 B88000              <1> 	mov ax, 128
  2869 00003AA7 F7E3                <1> 	mul bx
  2870 00003AA9 01C6                <1> 	add si, ax
  2871 00003AAB EB03                <1> 	jmp .get_position
  2872                              <1> 
  2873                              <1> .is_quote:
  2874 00003AAD BE007B              <1> 	mov si, token
  2875                              <1> 
  2876                              <1> .get_position:
  2877 00003AB0 89F0                <1> 	mov ax, si
  2878 00003AB2 E8D9D4              <1> 	call os_file_exists
  2879 00003AB5 7239                <1> 	jc .file_not_exists
  2880                              <1> 
  2881 00003AB7 89C2                <1> 	mov dx, ax			; Store for now
  2882                              <1> 
  2883 00003AB9 E86B0A              <1> 	call get_token
  2884                              <1> 
  2885 00003ABC 83F801              <1> 	cmp ax, VARIABLE
  2886 00003ABF 7425                <1> 	je .second_is_var
  2887                              <1> 
  2888 00003AC1 83F803              <1> 	cmp ax, NUMBER
  2889 00003AC4 753A                <1> 	jne .error
  2890                              <1> 
  2891 00003AC6 BE007B              <1> 	mov si, token
  2892 00003AC9 E8EEF0              <1> 	call os_string_to_int
  2893                              <1> 
  2894                              <1> .load_part:
  2895 00003ACC 89C1                <1> 	mov cx, ax
  2896                              <1> 
  2897 00003ACE 89D0                <1> 	mov ax, dx
  2898                              <1> 
  2899 00003AD0 E877D1              <1> 	call os_load_file
  2900                              <1> 
  2901 00003AD3 31C0                <1> 	xor ax, ax
  2902 00003AD5 B053                <1> 	mov byte al, 'S'
  2903 00003AD7 E83E0A              <1> 	call set_var
  2904                              <1> 
  2905 00003ADA 31C0                <1> 	xor ax, ax
  2906 00003ADC B052                <1> 	mov byte al, 'R'
  2907 00003ADE 31DB                <1> 	xor bx, bx
  2908 00003AE0 E8350A              <1> 	call set_var
  2909                              <1> 
  2910 00003AE3 E9D1F2              <1> 	jmp mainloop
  2911                              <1> 
  2912                              <1> 
  2913                              <1> .second_is_var:
  2914 00003AE6 0FB606007B          <1> 	movzx ax, byte [token]
  2915 00003AEB E81D0A              <1> 	call get_var
  2916 00003AEE EBDC                <1> 	jmp .load_part
  2917                              <1> 
  2918                              <1> 
  2919                              <1> .file_not_exists:
  2920 00003AF0 31C0                <1> 	xor ax, ax
  2921 00003AF2 B052                <1> 	mov byte al, 'R'
  2922 00003AF4 BB0100              <1> 	mov bx, 1
  2923 00003AF7 E81E0A              <1> 	call set_var
  2924                              <1> 
  2925 00003AFA E82A0A              <1> 	call get_token				; Skip past the loading point -- unnecessary now
  2926                              <1> 
  2927 00003AFD E9B7F2              <1> 	jmp mainloop
  2928                              <1> 
  2929                              <1> 
  2930                              <1> .error:
  2931 00003B00 BE1400              <1> 	mov si, err_syntax
  2932 00003B03 E93A0B              <1> 	jmp error
  2933                              <1> 
  2934                              <1> 
  2935                              <1> ; ------------------------------------------------------------------
  2936                              <1> ; LOOP
  2937                              <1> 
  2938                              <1> do_loop:
  2939 00003B06 803E[B246]00        <1> 	cmp byte [loop_in], 0
  2940 00003B0B 0F84CA00            <1> 	je .no_do
  2941                              <1> 
  2942 00003B0F 802E[B246]02        <1> 	sub byte [loop_in], 2
  2943                              <1> 
  2944 00003B14 31D2                <1> 	xor dx, dx
  2945                              <1> 
  2946 00003B16 E80E0A              <1> 	call get_token
  2947 00003B19 BF007B              <1> 	mov di, token
  2948                              <1> 	
  2949 00003B1C BE[F13B]            <1> 	mov si, .endless_word
  2950 00003B1F E844F0              <1> 	call os_string_compare
  2951 00003B22 0F829C00            <1> 	jc .loop_back
  2952                              <1> 	
  2953 00003B26 BE[E53B]            <1> 	mov si, .while_word
  2954 00003B29 E83AF0              <1> 	call os_string_compare
  2955 00003B2C 0F82A300            <1> 	jc .while_set
  2956                              <1> 	
  2957 00003B30 BE[EB3B]            <1> 	mov si, .until_word
  2958 00003B33 E830F0              <1> 	call os_string_compare
  2959 00003B36 0F83A500            <1> 	jnc .error
  2960                              <1> 	
  2961                              <1> .get_first_var:
  2962 00003B3A E8EA09              <1> 	call get_token
  2963 00003B3D 83F801              <1> 	cmp ax, VARIABLE
  2964 00003B40 0F859B00            <1> 	jne .error
  2965                              <1> 	
  2966 00003B44 A0007B              <1> 	mov al, [token]
  2967 00003B47 E8C109              <1> 	call get_var
  2968 00003B4A 89C1                <1> 	mov cx, ax
  2969                              <1> 	
  2970                              <1> .check_equals:
  2971 00003B4C E8D809              <1> 	call get_token
  2972 00003B4F 83F807              <1> 	cmp ax, UNKNOWN
  2973 00003B52 0F858900            <1> 	jne .error
  2974                              <1> 
  2975 00003B56 A1007B              <1> 	mov ax, [token]
  2976 00003B59 3C3D                <1> 	cmp al, '='
  2977 00003B5B 740A                <1> 	je .sign_ok
  2978 00003B5D 3C3E                <1> 	cmp al, '>'
  2979 00003B5F 7406                <1> 	je .sign_ok
  2980 00003B61 3C3C                <1> 	cmp al, '<'
  2981 00003B63 7402                <1> 	je .sign_ok
  2982 00003B65 EB78                <1> 	jmp .error
  2983                              <1> 	.sign_ok:
  2984 00003B67 A2[F93B]            <1> 	mov byte [.sign], al
  2985                              <1> 	
  2986                              <1> .get_second_var:
  2987 00003B6A E8BA09              <1>  	call get_token
  2988                              <1> 
  2989 00003B6D 83F803              <1> 	cmp ax, NUMBER
  2990 00003B70 7419                <1> 	je .second_is_num
  2991                              <1> 
  2992 00003B72 83F801              <1> 	cmp ax, VARIABLE
  2993 00003B75 740C                <1> 	je .second_is_var
  2994                              <1> 
  2995 00003B77 83F806              <1> 	cmp ax, CHAR
  2996 00003B7A 7563                <1> 	jne .error
  2997                              <1> 
  2998                              <1> .second_is_char:
  2999 00003B7C B400                <1> 	mov ah, 0
  3000 00003B7E A0007B              <1> 	mov al, [token]
  3001 00003B81 EB0E                <1> 	jmp .check_true
  3002                              <1> 	
  3003                              <1> .second_is_var:
  3004 00003B83 A0007B              <1> 	mov al, [token]
  3005 00003B86 E88209              <1> 	call get_var
  3006 00003B89 EB06                <1> 	jmp .check_true
  3007                              <1> 	
  3008                              <1> .second_is_num:
  3009 00003B8B BE007B              <1> 	mov si, token
  3010 00003B8E E829F0              <1> 	call os_string_to_int
  3011                              <1> 	
  3012                              <1> .check_true:
  3013 00003B91 8A1E[F93B]          <1> 	mov byte bl, [.sign]
  3014 00003B95 80FB3D              <1> 	cmp bl, '='
  3015 00003B98 7407                <1> 	je .sign_equals
  3016                              <1> 	
  3017 00003B9A 80FB3E              <1> 	cmp bl, '>'
  3018 00003B9D 7408                <1> 	je .sign_greater
  3019                              <1> 	
  3020 00003B9F EB0C                <1> 	jmp .sign_lesser
  3021                              <1> 	
  3022                              <1> .sign_equals:
  3023 00003BA1 39C8                <1> 	cmp ax, cx
  3024 00003BA3 7516                <1> 	jne .false
  3025 00003BA5 EB0C                <1> 	jmp .true
  3026                              <1> 	
  3027                              <1> .sign_greater:
  3028 00003BA7 39C8                <1> 	cmp ax, cx
  3029 00003BA9 7D10                <1> 	jge .false
  3030 00003BAB EB06                <1> 	jmp .true
  3031                              <1> 	
  3032                              <1> .sign_lesser:
  3033 00003BAD 39C8                <1> 	cmp ax, cx
  3034 00003BAF 7E0A                <1> 	jle .false
  3035 00003BB1 EB00                <1> 	jmp .true
  3036                              <1> .true:
  3037 00003BB3 83FA01              <1> 	cmp dx, 1
  3038 00003BB6 740A                <1> 	je .loop_back
  3039 00003BB8 E9FCF1              <1> 	jmp mainloop
  3040                              <1> .false:
  3041 00003BBB 83FA01              <1> 	cmp dx, 1
  3042 00003BBE 0F84F5F1            <1> 	je mainloop
  3043                              <1> 	
  3044                              <1> .loop_back:	
  3045 00003BC2 BED079              <1> 	mov word si, do_loop_store
  3046 00003BC5 A0[B246]            <1> 	mov byte al, [loop_in]
  3047 00003BC8 B400                <1> 	mov ah, 0
  3048 00003BCA 01C6                <1> 	add si, ax
  3049 00003BCC AD                  <1> 	lodsw
  3050 00003BCD A3[AB46]            <1> 	mov word [prog], ax
  3051 00003BD0 E9E4F1              <1> 	jmp mainloop
  3052                              <1> 	
  3053                              <1> .while_set:
  3054 00003BD3 BA0100              <1> 	mov dx, 1
  3055 00003BD6 E961FF              <1> 	jmp .get_first_var
  3056                              <1> 	
  3057                              <1> .no_do:
  3058 00003BD9 BE0900              <1> 	mov si, err_loop
  3059 00003BDC E9610A              <1> 	jmp error
  3060                              <1> 
  3061                              <1> .error:
  3062 00003BDF BE1400              <1> 	mov si, err_syntax
  3063 00003BE2 E95B0A              <1> 	jmp error
  3064                              <1> 	
  3065                              <1> .data:
  3066 00003BE5 5748494C4500        <1> 	.while_word			db "WHILE", 0
  3067 00003BEB 554E54494C00        <1> 	.until_word			db "UNTIL", 0
  3068 00003BF1 454E444C45535300    <1> 	.endless_word			db "ENDLESS", 0
  3069 00003BF9 00                  <1> 	.sign				db 0
  3070                              <1> 	
  3071                              <1> 	
  3072                              <1> ; ------------------------------------------------------------------
  3073                              <1> ; MOVE
  3074                              <1> 
  3075                              <1> do_move:
  3076 00003BFA E82A09              <1> 	call get_token
  3077                              <1> 
  3078 00003BFD 83F801              <1> 	cmp ax, VARIABLE
  3079 00003C00 740A                <1> 	je .first_is_var
  3080                              <1> 
  3081 00003C02 BE007B              <1> 	mov si, token
  3082 00003C05 E8B2EF              <1> 	call os_string_to_int
  3083 00003C08 88C2                <1> 	mov dl, al
  3084 00003C0A EB0A                <1> 	jmp .onto_second
  3085                              <1> 
  3086                              <1> .first_is_var:
  3087 00003C0C 0FB606007B          <1> 	movzx ax, byte [token]
  3088 00003C11 E8F708              <1> 	call get_var
  3089 00003C14 88C2                <1> 	mov dl, al
  3090                              <1> 
  3091                              <1> .onto_second:
  3092 00003C16 E80E09              <1> 	call get_token
  3093                              <1> 
  3094 00003C19 83F801              <1> 	cmp ax, VARIABLE
  3095 00003C1C 740A                <1> 	je .second_is_var
  3096                              <1> 
  3097 00003C1E BE007B              <1> 	mov si, token
  3098 00003C21 E896EF              <1> 	call os_string_to_int
  3099 00003C24 88C6                <1> 	mov dh, al
  3100 00003C26 EB0A                <1> 	jmp .finish
  3101                              <1> 
  3102                              <1> .second_is_var:
  3103 00003C28 0FB606007B          <1> 	movzx ax, byte [token]
  3104 00003C2D E8DB08              <1> 	call get_var
  3105 00003C30 88C6                <1> 	mov dh, al
  3106                              <1> 
  3107                              <1> .finish:
  3108 00003C32 8A3E[B546]          <1> 	mov byte bh, [work_page]
  3109 00003C36 B402                <1> 	mov ah, 2
  3110 00003C38 CD10                <1> 	int 10h
  3111                              <1> 
  3112 00003C3A E97AF1              <1> 	jmp mainloop
  3113                              <1> 
  3114                              <1> 
  3115                              <1> ; ------------------------------------------------------------------
  3116                              <1> ; NEXT
  3117                              <1> 
  3118                              <1> do_next:
  3119 00003C3D E8E708              <1> 	call get_token
  3120                              <1> 
  3121 00003C40 83F801              <1> 	cmp ax, VARIABLE			; NEXT must be followed by a variable
  3122 00003C43 753F                <1> 	jne .error
  3123                              <1> 
  3124 00003C45 0FB606007B          <1> 	movzx ax, byte [token]
  3125 00003C4A E8BE08              <1> 	call get_var
  3126                              <1> 
  3127 00003C4D 40                  <1> 	inc ax					; NEXT increments the variable, of course!
  3128                              <1> 
  3129 00003C4E 89C3                <1> 	mov bx, ax
  3130                              <1> 
  3131 00003C50 0FB606007B          <1> 	movzx ax, byte [token]
  3132                              <1> 
  3133 00003C55 2C41                <1> 	sub al, 65
  3134 00003C57 BE187A              <1> 	mov si, for_variables
  3135 00003C5A 01C6                <1> 	add si, ax
  3136 00003C5C 01C6                <1> 	add si, ax
  3137 00003C5E AD                  <1> 	lodsw					; Get the target number from the table
  3138                              <1> 
  3139 00003C5F 40                  <1> 	inc ax					; (Make the loop inclusive of target number)
  3140 00003C60 39D8                <1> 	cmp ax, bx				; Do the variable and target match?
  3141 00003C62 741D                <1> 	je .loop_finished
  3142                              <1> 
  3143 00003C64 0FB606007B          <1> 	movzx ax, byte [token]
  3144 00003C69 E8AC08              <1> 	call set_var
  3145                              <1> 
  3146 00003C6C 0FB606007B          <1> 	movzx ax, byte [token]
  3147 00003C71 2C41                <1> 	sub al, 65
  3148 00003C73 BEE479              <1> 	mov si, for_code_points
  3149 00003C76 01C6                <1> 	add si, ax
  3150 00003C78 01C6                <1> 	add si, ax
  3151 00003C7A AD                  <1> 	lodsw
  3152                              <1> 
  3153 00003C7B A3[AB46]            <1> 	mov word [prog], ax
  3154 00003C7E E936F1              <1> 	jmp mainloop
  3155                              <1> 
  3156                              <1> 
  3157                              <1> .loop_finished:
  3158 00003C81 E933F1              <1> 	jmp mainloop
  3159                              <1> 
  3160                              <1> .error:
  3161 00003C84 BE1400              <1> 	mov si, err_syntax
  3162 00003C87 E9B609              <1> 	jmp error
  3163                              <1> 
  3164                              <1> 
  3165                              <1> 
  3166                              <1> ;-------------------------------------------------------------------
  3167                              <1> ; NUMBER
  3168                              <1> 
  3169                              <1> do_number:
  3170 00003C8A E89A08              <1> 	call get_token			; Check if it's string to number, or number to string
  3171                              <1> 
  3172 00003C8D 83F802              <1> 	cmp ax, STRING_VAR
  3173 00003C90 7407                <1> 	je .is_string
  3174                              <1> 
  3175 00003C92 83F801              <1> 	cmp ax, VARIABLE
  3176 00003C95 742C                <1> 	je .is_variable
  3177                              <1> 
  3178 00003C97 EB54                <1> 	jmp .error
  3179                              <1> 
  3180                              <1> .is_string:
  3181                              <1> 
  3182 00003C99 BE007C              <1> 	mov si, string_vars
  3183 00003C9C B88000              <1> 	mov ax, 128
  3184 00003C9F F7E3                <1> 	mul bx
  3185 00003CA1 01C6                <1> 	add si, ax
  3186 00003CA3 8936[F33C]          <1> 	mov [.tmp], si
  3187                              <1> 
  3188 00003CA7 E87D08              <1> 	call get_token
  3189                              <1> 
  3190 00003CAA 8B36[F33C]          <1> 	mov si, [.tmp]
  3191                              <1> 
  3192 00003CAE 83F801              <1> 	cmp ax, VARIABLE
  3193 00003CB1 753A                <1> 	jne .error
  3194                              <1> 
  3195 00003CB3 E804EF              <1> 	call os_string_to_int
  3196 00003CB6 89C3                <1> 	mov bx, ax
  3197                              <1> 
  3198 00003CB8 0FB606007B          <1> 	movzx ax, byte [token]
  3199 00003CBD E85808              <1> 	call set_var
  3200                              <1> 
  3201 00003CC0 E9F4F0              <1> 	jmp mainloop
  3202                              <1> 
  3203                              <1> .is_variable:
  3204 00003CC3 0FB606007B          <1> 	movzx ax, byte [token]
  3205 00003CC8 E84008              <1> 	call get_var
  3206                              <1> 
  3207 00003CCB E837EF              <1> 	call os_int_to_string		; Convert to a string
  3208 00003CCE A3[F33C]            <1> 	mov [.tmp], ax
  3209                              <1> 
  3210 00003CD1 E85308              <1> 	call get_token			; Get the second parameter
  3211                              <1> 
  3212 00003CD4 8B36[F33C]          <1> 	mov si, [.tmp]
  3213                              <1> 
  3214 00003CD8 83F802              <1> 	cmp ax, STRING_VAR		; Make sure it's a string variable
  3215 00003CDB 7510                <1> 	jne .error
  3216                              <1> 
  3217 00003CDD BF007C              <1> 	mov di, string_vars		; Locate string variable
  3218 00003CE0 B88000              <1> 	mov ax, 128
  3219 00003CE3 F7E3                <1> 	mul bx
  3220 00003CE5 01C7                <1> 	add di, ax
  3221                              <1> 
  3222 00003CE7 E81DEE              <1> 	call os_string_copy		; Save converted string
  3223                              <1> 
  3224 00003CEA E9CAF0              <1> 	jmp mainloop
  3225                              <1> 
  3226                              <1> .error:
  3227 00003CED BE1400              <1> 	mov si, err_syntax
  3228 00003CF0 E94D09              <1> 	jmp error
  3229                              <1> 
  3230                              <1> 
  3231 00003CF3 0000                <1> 	.tmp		dw 	0
  3232                              <1> 
  3233                              <1> 
  3234                              <1> ;-------------------------------------------------------------------
  3235                              <1> ; PAGE
  3236                              <1> 
  3237                              <1> do_page:
  3238 00003CF5 E82F08              <1> 	call get_token
  3239 00003CF8 83F803              <1> 	cmp ax, NUMBER
  3240 00003CFB 7521                <1> 	jne .error
  3241                              <1> 
  3242 00003CFD BE007B              <1> 	mov si, token
  3243 00003D00 E8B7EE              <1> 	call os_string_to_int
  3244 00003D03 A2[B546]            <1> 	mov byte [work_page], al	; Set work page variable
  3245                              <1> 
  3246 00003D06 E81E08              <1> 	call get_token
  3247 00003D09 83F803              <1> 	cmp ax, NUMBER
  3248 00003D0C 7510                <1> 	jne .error
  3249                              <1> 
  3250 00003D0E BE007B              <1> 	mov si, token
  3251 00003D11 E8A6EE              <1> 	call os_string_to_int
  3252 00003D14 A2[B646]            <1> 	mov byte [disp_page], al	; Set display page variable
  3253                              <1> 
  3254                              <1> 	; Change display page -- AL should already be present from the os_string_to_int
  3255 00003D17 B405                <1> 	mov ah, 5
  3256 00003D19 CD10                <1> 	int 10h
  3257                              <1> 
  3258 00003D1B E999F0              <1> 	jmp mainloop
  3259                              <1> 
  3260                              <1> .error:
  3261 00003D1E BE1400              <1> 	mov si, err_syntax
  3262 00003D21 E91C09              <1> 	jmp error
  3263                              <1> 
  3264                              <1> 
  3265                              <1> ; ------------------------------------------------------------------
  3266                              <1> ; PAUSE
  3267                              <1> 
  3268                              <1> do_pause:
  3269 00003D24 E80008              <1> 	call get_token
  3270                              <1> 
  3271 00003D27 83F801              <1> 	cmp ax, VARIABLE
  3272 00003D2A 7408                <1> 	je .is_var
  3273                              <1> 
  3274 00003D2C BE007B              <1> 	mov si, token
  3275 00003D2F E888EE              <1> 	call os_string_to_int
  3276 00003D32 EB08                <1> 	jmp .finish
  3277                              <1> 
  3278                              <1> .is_var:
  3279 00003D34 0FB606007B          <1> 	movzx ax, byte [token]
  3280 00003D39 E8CF07              <1> 	call get_var
  3281                              <1> 
  3282                              <1> .finish:
  3283 00003D3C E84AD8              <1> 	call os_pause
  3284 00003D3F E975F0              <1> 	jmp mainloop
  3285                              <1> 
  3286                              <1> 
  3287                              <1> ; ------------------------------------------------------------------
  3288                              <1> ; PEEK
  3289                              <1> 
  3290                              <1> do_peek:
  3291 00003D42 E8E207              <1> 	call get_token
  3292                              <1> 
  3293 00003D45 83F801              <1> 	cmp ax, VARIABLE
  3294 00003D48 7533                <1> 	jne .error
  3295                              <1> 
  3296 00003D4A 0FB606007B          <1> 	movzx ax, byte [token]
  3297 00003D4F A2[833D]            <1> 	mov byte [.tmp_var], al
  3298                              <1> 
  3299 00003D52 E8D207              <1> 	call get_token
  3300                              <1> 
  3301 00003D55 83F801              <1> 	cmp ax, VARIABLE
  3302 00003D58 741B                <1> 	je .dereference
  3303                              <1> 
  3304 00003D5A 83F803              <1> 	cmp ax, NUMBER
  3305 00003D5D 751E                <1> 	jne .error
  3306                              <1> 
  3307 00003D5F BE007B              <1> 	mov si, token
  3308 00003D62 E855EE              <1> 	call os_string_to_int
  3309                              <1> 
  3310                              <1> .store:
  3311 00003D65 89C6                <1> 	mov si, ax
  3312 00003D67 0FB61C              <1> 	movzx bx, byte [si]
  3313 00003D6A 0FB606[833D]        <1> 	movzx ax, byte [.tmp_var]
  3314 00003D6F E8A607              <1> 	call set_var
  3315                              <1> 
  3316 00003D72 E942F0              <1> 	jmp mainloop
  3317                              <1> 
  3318                              <1> .dereference:
  3319 00003D75 A0007B              <1> 	mov byte al, [token]
  3320 00003D78 E89007              <1> 	call get_var
  3321 00003D7B EBE8                <1> 	jmp .store
  3322                              <1> 
  3323                              <1> .error:
  3324 00003D7D BE1400              <1> 	mov si, err_syntax
  3325 00003D80 E9BD08              <1> 	jmp error
  3326                              <1> 
  3327                              <1> 
  3328 00003D83 00                  <1> 	.tmp_var	db 0
  3329                              <1> 	
  3330                              <1> 	
  3331                              <1> 	
  3332                              <1> ; ------------------------------------------------------------------
  3333                              <1> ; PEEKINT
  3334                              <1> 
  3335                              <1> do_peekint:
  3336 00003D84 E8A007              <1> 	call get_token
  3337                              <1> 	
  3338 00003D87 83F801              <1> 	cmp ax, VARIABLE
  3339 00003D8A 752C                <1> 	jne .error
  3340                              <1> 
  3341                              <1> .get_second:
  3342 00003D8C A0007B              <1> 	mov al, [token]
  3343 00003D8F 89C1                <1> 	mov cx, ax
  3344                              <1> 	
  3345 00003D91 E89307              <1> 	call get_token
  3346                              <1> 	
  3347 00003D94 83F801              <1> 	cmp ax, VARIABLE
  3348 00003D97 740D                <1> 	je .address_is_var
  3349                              <1> 	
  3350 00003D99 83F803              <1> 	cmp ax, NUMBER
  3351 00003D9C 751A                <1> 	jne .error
  3352                              <1> 	
  3353                              <1> .address_is_number:
  3354 00003D9E BE007B              <1> 	mov si, token
  3355 00003DA1 E816EE              <1> 	call os_string_to_int
  3356 00003DA4 EB06                <1> 	jmp .load_data
  3357                              <1> 	
  3358                              <1> .address_is_var:
  3359 00003DA6 A0007B              <1> 	mov al, [token]
  3360 00003DA9 E85F07              <1> 	call get_var
  3361                              <1> 	
  3362                              <1> .load_data:
  3363 00003DAC 89C6                <1> 	mov si, ax
  3364 00003DAE 8B1C                <1> 	mov bx, [si]
  3365 00003DB0 89C8                <1> 	mov ax, cx
  3366 00003DB2 E86307              <1> 	call set_var
  3367                              <1> 	
  3368 00003DB5 E9FFEF              <1> 	jmp mainloop
  3369                              <1> 	
  3370                              <1> .error:
  3371 00003DB8 BE1400              <1> 	mov si, err_syntax
  3372 00003DBB E98208              <1> 	jmp error
  3373                              <1> 
  3374                              <1> 
  3375                              <1> 
  3376                              <1> ; ------------------------------------------------------------------
  3377                              <1> ; POKE
  3378                              <1> 
  3379                              <1> do_poke:
  3380 00003DBE E86607              <1> 	call get_token
  3381                              <1> 
  3382 00003DC1 83F801              <1> 	cmp ax, VARIABLE
  3383 00003DC4 7415                <1> 	je .first_is_var
  3384                              <1> 
  3385 00003DC6 83F803              <1> 	cmp ax, NUMBER
  3386 00003DC9 7544                <1> 	jne .error
  3387                              <1> 
  3388 00003DCB BE007B              <1> 	mov si, token
  3389 00003DCE E8E9ED              <1> 	call os_string_to_int
  3390                              <1> 
  3391 00003DD1 3DFF00              <1> 	cmp ax, 255
  3392 00003DD4 7F39                <1> 	jg .error
  3393                              <1> 
  3394 00003DD6 A2[153E]            <1> 	mov byte [.first_value], al
  3395 00003DD9 EB0B                <1> 	jmp .onto_second
  3396                              <1> 
  3397                              <1> 
  3398                              <1> .first_is_var:
  3399 00003DDB 0FB606007B          <1> 	movzx ax, byte [token]
  3400 00003DE0 E82807              <1> 	call get_var
  3401                              <1> 
  3402 00003DE3 A2[153E]            <1> 	mov byte [.first_value], al
  3403                              <1> 
  3404                              <1> .onto_second:
  3405 00003DE6 E83E07              <1> 	call get_token
  3406                              <1> 
  3407 00003DE9 83F801              <1> 	cmp ax, VARIABLE
  3408 00003DEC 7417                <1> 	je .second_is_var
  3409                              <1> 
  3410 00003DEE 83F803              <1> 	cmp ax, NUMBER
  3411 00003DF1 751C                <1> 	jne .error
  3412                              <1> 
  3413 00003DF3 BE007B              <1> 	mov si, token
  3414 00003DF6 E8C1ED              <1> 	call os_string_to_int
  3415                              <1> 
  3416                              <1> .got_value:
  3417 00003DF9 89C7                <1> 	mov di, ax
  3418 00003DFB 0FB606[153E]        <1> 	movzx ax, byte [.first_value]
  3419 00003E00 8805                <1> 	mov byte [di], al
  3420                              <1> 
  3421 00003E02 E9B2EF              <1> 	jmp mainloop
  3422                              <1> 
  3423                              <1> .second_is_var:
  3424 00003E05 0FB606007B          <1> 	movzx ax, byte [token]
  3425 00003E0A E8FE06              <1> 	call get_var
  3426 00003E0D EBEA                <1> 	jmp .got_value
  3427                              <1> 
  3428                              <1> .error:
  3429 00003E0F BE1400              <1> 	mov si, err_syntax
  3430 00003E12 E92B08              <1> 	jmp error
  3431                              <1> 
  3432                              <1> 
  3433 00003E15 00                  <1> 	.first_value	db 0
  3434                              <1> 
  3435                              <1> 
  3436                              <1> 
  3437                              <1> 
  3438                              <1> ; ------------------------------------------------------------------
  3439                              <1> ; POKEINT
  3440                              <1> 
  3441                              <1> do_pokeint:
  3442 00003E16 E80E07              <1> 	call get_token
  3443                              <1> 	
  3444 00003E19 83F801              <1> 	cmp ax, VARIABLE
  3445 00003E1C 740D                <1> 	je .data_is_var
  3446                              <1> 	
  3447 00003E1E 83F803              <1> 	cmp ax, NUMBER
  3448 00003E21 7532                <1> 	jne .error
  3449                              <1> 
  3450                              <1> .data_is_num:
  3451 00003E23 BE007B              <1> 	mov si, token
  3452 00003E26 E891ED              <1> 	call os_string_to_int
  3453 00003E29 EB06                <1> 	jmp .get_second
  3454                              <1> 	
  3455                              <1> .data_is_var:
  3456 00003E2B A0007B              <1> 	mov al, [token]
  3457 00003E2E E8DA06              <1> 	call get_var
  3458                              <1> 	
  3459                              <1> .get_second:
  3460 00003E31 89C1                <1> 	mov cx, ax
  3461                              <1> 	
  3462 00003E33 E8F106              <1> 	call get_token
  3463                              <1> 	
  3464 00003E36 83F801              <1> 	cmp ax, VARIABLE
  3465 00003E39 740D                <1> 	je .address_is_var
  3466                              <1> 	
  3467 00003E3B 83F803              <1> 	cmp ax, NUMBER
  3468 00003E3E 7515                <1> 	jne .error
  3469                              <1> 	
  3470                              <1> .address_is_num:
  3471 00003E40 BE007B              <1> 	mov si, token
  3472 00003E43 E874ED              <1> 	call os_string_to_int
  3473 00003E46 EB06                <1> 	jmp .save_data
  3474                              <1> 	
  3475                              <1> .address_is_var:
  3476 00003E48 A0007B              <1> 	mov al, [token]
  3477 00003E4B E8BD06              <1> 	call get_var
  3478                              <1> 	
  3479                              <1> .save_data:
  3480 00003E4E 89C6                <1> 	mov si, ax
  3481 00003E50 890C                <1> 	mov [si], cx
  3482                              <1> 	
  3483 00003E52 E962EF              <1> 	jmp mainloop
  3484                              <1> 	
  3485                              <1> .error:
  3486 00003E55 BE1400              <1> 	mov si, err_syntax
  3487 00003E58 E9E507              <1> 	jmp error
  3488                              <1> 
  3489                              <1> 
  3490                              <1> 
  3491                              <1> 
  3492                              <1> ; ------------------------------------------------------------------
  3493                              <1> ; PORT
  3494                              <1> 
  3495                              <1> do_port:
  3496 00003E5B E8C906              <1> 	call get_token
  3497 00003E5E BE007B              <1> 	mov si, token
  3498                              <1> 
  3499 00003E61 BF[D63E]            <1> 	mov di, .out_cmd
  3500 00003E64 E8FFEC              <1> 	call os_string_compare
  3501 00003E67 720A                <1> 	jc .do_out_cmd
  3502                              <1> 
  3503 00003E69 BF[DA3E]            <1> 	mov di, .in_cmd
  3504 00003E6C E8F7EC              <1> 	call os_string_compare
  3505 00003E6F 7237                <1> 	jc .do_in_cmd
  3506                              <1> 
  3507 00003E71 EB5D                <1> 	jmp .error
  3508                              <1> 
  3509                              <1> 
  3510                              <1> .do_out_cmd:
  3511 00003E73 E8B106              <1> 	call get_token
  3512 00003E76 83F803              <1> 	cmp ax, NUMBER
  3513 00003E79 7555                <1> 	jne .error
  3514                              <1> 
  3515 00003E7B BE007B              <1> 	mov si, token
  3516 00003E7E E839ED              <1> 	call os_string_to_int		; Now AX = port number
  3517 00003E81 89C2                <1> 	mov dx, ax
  3518                              <1> 
  3519 00003E83 E8A106              <1> 	call get_token
  3520 00003E86 83F803              <1> 	cmp ax, NUMBER
  3521 00003E89 7407                <1> 	je .out_is_num
  3522                              <1> 
  3523 00003E8B 83F801              <1> 	cmp ax, VARIABLE
  3524 00003E8E 740C                <1> 	je .out_is_var
  3525                              <1> 
  3526 00003E90 EB3E                <1> 	jmp .error
  3527                              <1> 
  3528                              <1> .out_is_num:
  3529 00003E92 BE007B              <1> 	mov si, token
  3530 00003E95 E822ED              <1> 	call os_string_to_int
  3531 00003E98 EE                  <1> 	out dx, al
  3532 00003E99 E91BEF              <1> 	jmp mainloop
  3533                              <1> 
  3534                              <1> .out_is_var:
  3535 00003E9C 0FB606007B          <1> 	movzx ax, byte [token]
  3536 00003EA1 E86706              <1> 	call get_var
  3537                              <1> 
  3538 00003EA4 EE                  <1> 	out dx, al
  3539 00003EA5 E90FEF              <1> 	jmp mainloop
  3540                              <1> 
  3541                              <1> 
  3542                              <1> .do_in_cmd:
  3543 00003EA8 E87C06              <1> 	call get_token
  3544 00003EAB 83F803              <1> 	cmp ax, NUMBER
  3545 00003EAE 7520                <1> 	jne .error
  3546                              <1> 
  3547 00003EB0 BE007B              <1> 	mov si, token
  3548 00003EB3 E804ED              <1> 	call os_string_to_int
  3549 00003EB6 89C2                <1> 	mov dx, ax
  3550                              <1> 
  3551 00003EB8 E86C06              <1> 	call get_token
  3552 00003EBB 83F801              <1> 	cmp ax, VARIABLE
  3553 00003EBE 7510                <1> 	jne .error
  3554                              <1> 
  3555 00003EC0 8A0E007B            <1> 	mov byte cl, [token]
  3556                              <1> 
  3557 00003EC4 EC                  <1> 	in al, dx
  3558 00003EC5 0FB6D8              <1> 	movzx bx, al
  3559                              <1> 
  3560 00003EC8 88C8                <1> 	mov al, cl
  3561 00003ECA E84B06              <1> 	call set_var
  3562                              <1> 
  3563 00003ECD E9E7EE              <1> 	jmp mainloop
  3564                              <1> 
  3565                              <1> 
  3566                              <1> .error:
  3567 00003ED0 BE1400              <1> 	mov si, err_syntax
  3568 00003ED3 E96A07              <1> 	jmp error
  3569                              <1> 
  3570                              <1> 
  3571 00003ED6 4F555400            <1> 	.out_cmd	db "OUT", 0
  3572 00003EDA 494E00              <1> 	.in_cmd		db "IN", 0
  3573                              <1> 
  3574                              <1> 
  3575                              <1> ; ------------------------------------------------------------------
  3576                              <1> ; PRINT
  3577                              <1> 
  3578                              <1> do_print:
  3579 00003EDD E84706              <1> 	call get_token				; Get part after PRINT
  3580                              <1> 
  3581 00003EE0 83F805              <1> 	cmp ax, QUOTE				; What type is it?
  3582 00003EE3 7428                <1> 	je .print_quote
  3583                              <1> 
  3584 00003EE5 83F801              <1> 	cmp ax, VARIABLE			; Numerical variable (eg X)
  3585 00003EE8 7410                <1> 	je .print_var
  3586                              <1> 
  3587 00003EEA 83F802              <1> 	cmp ax, STRING_VAR			; String variable (eg $1)
  3588 00003EED 7457                <1> 	je .print_string_var
  3589                              <1> 
  3590 00003EEF 83F804              <1> 	cmp ax, STRING				; Special keyword (eg CHR or HEX)
  3591 00003EF2 745E                <1> 	je .print_keyword
  3592                              <1> 
  3593 00003EF4 BE1000              <1> 	mov si, err_print_type			; We only print quoted strings and vars!
  3594 00003EF7 E94607              <1> 	jmp error
  3595                              <1> 
  3596                              <1> 
  3597                              <1> .print_var:
  3598 00003EFA 0FB606007B          <1> 	movzx ax, byte [token]
  3599 00003EFF E80906              <1> 	call get_var				; Get its value
  3600                              <1> 
  3601 00003F02 E800ED              <1> 	call os_int_to_string			; Convert to string
  3602 00003F05 89C6                <1> 	mov si, ax
  3603 00003F07 E8ACD9              <1> 	call os_print_string
  3604                              <1> 
  3605 00003F0A E9C500              <1> 	jmp .newline_or_not
  3606                              <1> 
  3607                              <1> 
  3608                              <1> .print_quote:					; If it's quoted text, print it
  3609 00003F0D BE007B              <1> 	mov si, token
  3610                              <1> .print_quote_loop:
  3611 00003F10 AC                  <1> 	lodsb
  3612 00003F11 3C00                <1> 	cmp al, 0
  3613 00003F13 0F84BB00            <1> 	je .newline_or_not
  3614                              <1> 
  3615 00003F17 B409                <1> 	mov ah, 09h
  3616 00003F19 8A1E[B446]          <1> 	mov byte bl, [ink_colour]
  3617 00003F1D 8A3E[B546]          <1> 	mov byte bh, [work_page]
  3618 00003F21 B90100              <1> 	mov cx, 1
  3619 00003F24 CD10                <1> 	int 10h
  3620                              <1> 
  3621 00003F26 B403                <1> 	mov ah, 3
  3622 00003F28 CD10                <1> 	int 10h
  3623                              <1> 
  3624 00003F2A 80FA4F              <1> 	cmp dl, 79
  3625 00003F2D 7D0C                <1> 	jge .quote_newline
  3626 00003F2F FEC2                <1> 	inc dl
  3627                              <1> 
  3628                              <1> .move_cur_quote:
  3629 00003F31 8A3E[B546]          <1> 	mov byte bh, [work_page]
  3630 00003F35 B402                <1> 	mov ah, 02h
  3631 00003F37 CD10                <1> 	int 10h
  3632 00003F39 EBD5                <1> 	jmp .print_quote_loop
  3633                              <1> 
  3634                              <1> 
  3635                              <1> .quote_newline:
  3636 00003F3B 80FE18              <1> 	cmp dh, 24
  3637 00003F3E 74F1                <1> 	je .move_cur_quote
  3638 00003F40 B200                <1> 	mov dl, 0
  3639 00003F42 FEC6                <1> 	inc dh
  3640 00003F44 EBEB                <1> 	jmp .move_cur_quote
  3641                              <1> 
  3642                              <1> .print_string_var:
  3643 00003F46 BE007C              <1> 	mov si, string_vars
  3644 00003F49 B88000              <1> 	mov ax, 128
  3645 00003F4C F7E3                <1> 	mul bx
  3646 00003F4E 01C6                <1> 	add si, ax
  3647                              <1> 
  3648 00003F50 EBBE                <1> 	jmp .print_quote_loop
  3649                              <1> 
  3650                              <1> 
  3651                              <1> .print_keyword:
  3652 00003F52 BE007B              <1> 	mov si, token
  3653 00003F55 BF[DF47]            <1> 	mov di, chr_keyword
  3654 00003F58 E80BEC              <1> 	call os_string_compare
  3655 00003F5B 720E                <1> 	jc .is_chr
  3656                              <1> 
  3657 00003F5D BF[E347]            <1> 	mov di, hex_keyword
  3658 00003F60 E803EC              <1> 	call os_string_compare
  3659 00003F63 7243                <1> 	jc .is_hex
  3660                              <1> 
  3661 00003F65 BE1400              <1> 	mov si, err_syntax
  3662 00003F68 E9D506              <1> 	jmp error
  3663                              <1> 
  3664                              <1> .is_chr:
  3665 00003F6B E8B905              <1> 	call get_token
  3666                              <1> 
  3667 00003F6E 83F801              <1> 	cmp ax, VARIABLE
  3668 00003F71 7405                <1> 	je .is_chr_variable
  3669                              <1> 	
  3670 00003F73 83F803              <1> 	cmp ax, NUMBER
  3671 00003F76 740A                <1> 	je .is_chr_number
  3672                              <1> 
  3673                              <1> .is_chr_variable:
  3674 00003F78 0FB606007B          <1> 	movzx ax, byte [token]
  3675 00003F7D E88B05              <1> 	call get_var
  3676 00003F80 EB06                <1> 	jmp .print_chr
  3677                              <1> 	
  3678                              <1> .is_chr_number:
  3679 00003F82 BE007B              <1> 	mov si, token
  3680 00003F85 E832EC              <1> 	call os_string_to_int
  3681                              <1> 
  3682                              <1> .print_chr:
  3683 00003F88 B409                <1> 	mov ah, 09h
  3684 00003F8A 8A1E[B446]          <1> 	mov byte bl, [ink_colour]
  3685 00003F8E 8A3E[B546]          <1> 	mov byte bh, [work_page]
  3686 00003F92 B90100              <1> 	mov cx, 1
  3687 00003F95 CD10                <1> 	int 10h
  3688                              <1> 
  3689 00003F97 B403                <1> 	mov ah, 3		; Move the cursor forward
  3690 00003F99 CD10                <1> 	int 10h
  3691 00003F9B FEC2                <1> 	inc dl
  3692 00003F9D 80FA4F              <1> 	cmp dl, 79
  3693 00003FA0 7F1B                <1> 	jg .end_line		; If it's over the end of the line
  3694                              <1> .move_cur:
  3695 00003FA2 B402                <1> 	mov ah, 2
  3696 00003FA4 CD10                <1> 	int 10h
  3697                              <1> 
  3698 00003FA6 EB2A                <1> 	jmp .newline_or_not
  3699                              <1> 
  3700                              <1> 
  3701                              <1> .is_hex:
  3702 00003FA8 E87C05              <1> 	call get_token
  3703                              <1> 
  3704 00003FAB 83F801              <1> 	cmp ax, VARIABLE
  3705 00003FAE 751C                <1> 	jne .error
  3706                              <1> 
  3707 00003FB0 0FB606007B          <1> 	movzx ax, byte [token]
  3708 00003FB5 E85305              <1> 	call get_var
  3709                              <1> 
  3710 00003FB8 E898E2              <1> 	call os_print_2hex
  3711                              <1> 
  3712 00003FBB EB15                <1> 	jmp .newline_or_not
  3713                              <1> 
  3714                              <1> .end_line:
  3715 00003FBD B200                <1> 	mov dl, 0
  3716 00003FBF FEC6                <1> 	inc dh
  3717 00003FC1 80FE19              <1> 	cmp dh, 25
  3718 00003FC4 7CDC                <1> 	jl .move_cur
  3719 00003FC6 B618                <1> 	mov dh, 24
  3720 00003FC8 B24F                <1> 	mov dl, 79
  3721 00003FCA EBD6                <1> 	jmp .move_cur
  3722                              <1> 
  3723                              <1> .error:
  3724 00003FCC BE1400              <1> 	mov si, err_syntax
  3725 00003FCF E96E06              <1> 	jmp error
  3726                              <1> 	
  3727                              <1> 
  3728                              <1> 
  3729                              <1> .newline_or_not:
  3730                              <1> 	; We want to see if the command ends with ';' -- which means that
  3731                              <1> 	; we shouldn't print a newline after it finishes. So we store the
  3732                              <1> 	; current program location to pop ahead and see if there's the ';'
  3733                              <1> 	; character -- otherwise we put the program location back and resume
  3734                              <1> 	; the main loop
  3735                              <1> 
  3736 00003FD2 A1[AB46]            <1> 	mov word ax, [prog]
  3737 00003FD5 A3[0840]            <1> 	mov word [.tmp_loc], ax
  3738                              <1> 
  3739 00003FD8 E84C05              <1> 	call get_token
  3740 00003FDB 83F807              <1> 	cmp ax, UNKNOWN
  3741 00003FDE 750C                <1> 	jne .ignore
  3742                              <1> 
  3743 00003FE0 0FB606007B          <1> 	movzx ax, byte [token]
  3744 00003FE5 3C3B                <1> 	cmp al, ';'
  3745 00003FE7 7503                <1> 	jne .ignore
  3746                              <1> 
  3747 00003FE9 E9CBED              <1> 	jmp mainloop				; And go back to interpreting the code!
  3748                              <1> 
  3749                              <1> .ignore:
  3750 00003FEC B405                <1> 	mov ah, 5
  3751 00003FEE A0[B546]            <1> 	mov al, [work_page]
  3752 00003FF1 CD10                <1> 	int 10h
  3753                              <1> 
  3754 00003FF3 8A3E[B546]          <1> 	mov bh, [work_page]
  3755 00003FF7 E805E0              <1> 	call os_print_newline
  3756                              <1> 
  3757 00003FFA B405                <1> 	mov ah, 5
  3758 00003FFC A0[B646]            <1> 	mov al, [disp_page]
  3759                              <1> 
  3760 00003FFF A1[0840]            <1> 	mov word ax, [.tmp_loc]
  3761 00004002 A3[AB46]            <1> 	mov word [prog], ax
  3762                              <1> 
  3763 00004005 E9AFED              <1> 	jmp mainloop
  3764                              <1> 
  3765                              <1> 
  3766 00004008 0000                <1> 	.tmp_loc	dw 0
  3767                              <1> 
  3768                              <1> 
  3769                              <1> ; ------------------------------------------------------------------
  3770                              <1> ; RAND
  3771                              <1> 
  3772                              <1> do_rand:
  3773 0000400A E81A05              <1> 	call get_token
  3774 0000400D 83F801              <1> 	cmp ax, VARIABLE
  3775 00004010 7544                <1> 	jne .error
  3776                              <1> 
  3777 00004012 A0007B              <1> 	mov byte al, [token]
  3778 00004015 A2[5140]            <1> 	mov byte [.tmp], al
  3779                              <1> 
  3780 00004018 E80C05              <1> 	call get_token
  3781 0000401B 83F803              <1> 	cmp ax, NUMBER
  3782 0000401E 7536                <1> 	jne .error
  3783                              <1> 
  3784 00004020 BE007B              <1> 	mov si, token
  3785 00004023 E894EB              <1> 	call os_string_to_int
  3786 00004026 A3[5240]            <1> 	mov word [.num1], ax
  3787                              <1> 
  3788 00004029 E8FB04              <1> 	call get_token
  3789 0000402C 83F803              <1> 	cmp ax, NUMBER
  3790 0000402F 7525                <1> 	jne .error
  3791                              <1> 
  3792 00004031 BE007B              <1> 	mov si, token
  3793 00004034 E883EB              <1> 	call os_string_to_int
  3794 00004037 A3[5440]            <1> 	mov word [.num2], ax
  3795                              <1> 
  3796 0000403A A1[5240]            <1> 	mov word ax, [.num1]
  3797 0000403D 8B1E[5440]          <1> 	mov word bx, [.num2]
  3798 00004041 E857D4              <1> 	call os_get_random
  3799                              <1> 
  3800 00004044 89CB                <1> 	mov bx, cx
  3801 00004046 0FB606[5140]        <1> 	movzx ax, byte [.tmp]
  3802 0000404B E8CA04              <1> 	call set_var
  3803                              <1> 
  3804 0000404E E966ED              <1> 	jmp mainloop
  3805                              <1> 
  3806                              <1> 
  3807 00004051 00                  <1> 	.tmp	db 0
  3808 00004052 0000                <1> 	.num1	dw 0
  3809 00004054 0000                <1> 	.num2	dw 0
  3810                              <1> 
  3811                              <1> 
  3812                              <1> .error:
  3813 00004056 BE1400              <1> 	mov si, err_syntax
  3814 00004059 E9E405              <1> 	jmp error
  3815                              <1> 
  3816                              <1> 
  3817                              <1> ; ------------------------------------------------------------------
  3818                              <1> ; READ
  3819                              <1> 
  3820                              <1> do_read:
  3821 0000405C E8C804              <1> 	call get_token				; Get the next token
  3822                              <1> 
  3823 0000405F 83F804              <1> 	cmp ax, STRING				; Check for a label
  3824 00004062 7406                <1> 	je .is_ok
  3825                              <1> 
  3826 00004064 BE0500              <1> 	mov si, err_goto_notlabel
  3827 00004067 E9D605              <1> 	jmp error
  3828                              <1> 
  3829                              <1> .is_ok:
  3830 0000406A BE007B              <1> 	mov si, token				; Back up this label
  3831 0000406D BFE27A              <1> 	mov di, .tmp_token
  3832 00004070 E894EA              <1> 	call os_string_copy
  3833                              <1> 
  3834 00004073 B8E27A              <1> 	mov ax, .tmp_token
  3835 00004076 E8FBE9              <1> 	call os_string_length
  3836                              <1> 
  3837 00004079 BFE27A              <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  3838 0000407C 01C7                <1> 	add di, ax
  3839 0000407E B03A                <1> 	mov al, ':'
  3840 00004080 AA                  <1> 	stosb
  3841 00004081 B000                <1> 	mov al, 0
  3842 00004083 AA                  <1> 	stosb
  3843                              <1> 
  3844 00004084 E8A004              <1> 	call get_token				; Now get the offset variable
  3845 00004087 83F801              <1> 	cmp ax, VARIABLE
  3846 0000408A 7406                <1> 	je .second_part_is_var
  3847                              <1> 
  3848 0000408C BE1400              <1> 	mov si, err_syntax
  3849 0000408F E9AE05              <1> 	jmp error
  3850                              <1> 
  3851                              <1> 
  3852                              <1> .second_part_is_var:
  3853 00004092 0FB606007B          <1> 	movzx ax, byte [token]
  3854 00004097 E87104              <1> 	call get_var
  3855                              <1> 
  3856 0000409A 83F800              <1> 	cmp ax, 0				; Want to be searching for at least the first byte!
  3857 0000409D 7F06                <1> 	jg .var_bigger_than_zero
  3858                              <1> 
  3859 0000409F BE1400              <1> 	mov si, err_syntax
  3860 000040A2 E99B05              <1> 	jmp error
  3861                              <1> 
  3862                              <1> 
  3863                              <1> .var_bigger_than_zero:
  3864 000040A5 A3[2F41]            <1> 	mov word [.to_skip], ax
  3865                              <1> 
  3866                              <1> 
  3867 000040A8 E87C04              <1> 	call get_token				; And now the var to store result into
  3868 000040AB 83F801              <1> 	cmp ax, VARIABLE
  3869 000040AE 7406                <1> 	je .third_part_is_var
  3870                              <1> 
  3871 000040B0 BE1400              <1> 	mov si, err_syntax
  3872 000040B3 E98A05              <1> 	jmp error
  3873                              <1> 
  3874                              <1> 
  3875                              <1> .third_part_is_var:				; Keep it for later
  3876 000040B6 0FB606007B          <1> 	movzx ax, byte [token]
  3877 000040BB A2[3141]            <1> 	mov byte [.var_to_use], al
  3878                              <1> 
  3879                              <1> 
  3880                              <1> 
  3881                              <1> 	; OK, so now we have all the stuff we need. Let's search for the label
  3882                              <1> 
  3883 000040BE A1[AB46]            <1> 	mov word ax, [prog]			; Store current location
  3884 000040C1 A3[2D41]            <1> 	mov word [.curr_location], ax
  3885                              <1> 
  3886 000040C4 A1[AF46]            <1> 	mov word ax, [load_point]
  3887 000040C7 A3[AB46]            <1> 	mov word [prog], ax			; Return to start of program to find label
  3888                              <1> 
  3889                              <1> .loop:
  3890 000040CA E85A04              <1> 	call get_token
  3891                              <1> 
  3892 000040CD 83F808              <1> 	cmp ax, LABEL
  3893 000040D0 750B                <1> 	jne .line_loop
  3894                              <1> 
  3895 000040D2 BE007B              <1> 	mov si, token
  3896 000040D5 BFE27A              <1> 	mov di, .tmp_token
  3897 000040D8 E88BEA              <1> 	call os_string_compare
  3898 000040DB 7221                <1> 	jc .found_label
  3899                              <1> 
  3900                              <1> .line_loop:					; Go to end of line
  3901 000040DD 8B36[AB46]          <1> 	mov word si, [prog]
  3902 000040E1 8A04                <1> 	mov byte al, [si]
  3903 000040E3 FF06[AB46]          <1> 	inc word [prog]
  3904                              <1> 
  3905 000040E7 3C0A                <1> 	cmp al, 10
  3906 000040E9 75F2                <1> 	jne .line_loop
  3907                              <1> 
  3908 000040EB A1[AB46]            <1> 	mov word ax, [prog]
  3909 000040EE 8B1E[AD46]          <1> 	mov word bx, [prog_end]
  3910 000040F2 39D8                <1> 	cmp ax, bx
  3911 000040F4 7F02                <1> 	jg .past_end
  3912                              <1> 
  3913 000040F6 EBD2                <1> 	jmp .loop
  3914                              <1> 
  3915                              <1> .past_end:
  3916 000040F8 BE0600              <1> 	mov si, err_label_notfound
  3917 000040FB E94205              <1> 	jmp error
  3918                              <1> 
  3919                              <1> 
  3920                              <1> .found_label:
  3921 000040FE 8B0E[2F41]          <1> 	mov word cx, [.to_skip]			; Skip requested number of data entries
  3922                              <1> 
  3923                              <1> .data_skip_loop:
  3924 00004102 51                  <1> 	push cx
  3925 00004103 E82104              <1> 	call get_token
  3926 00004106 59                  <1> 	pop cx
  3927 00004107 E2F9                <1> 	loop .data_skip_loop
  3928                              <1> 
  3929 00004109 83F803              <1> 	cmp ax, NUMBER
  3930 0000410C 7406                <1> 	je .data_is_num
  3931                              <1> 
  3932 0000410E BE1400              <1> 	mov si, err_syntax
  3933 00004111 E92C05              <1> 	jmp error
  3934                              <1> 
  3935                              <1> .data_is_num:
  3936 00004114 BE007B              <1> 	mov si, token
  3937 00004117 E8A0EA              <1> 	call os_string_to_int
  3938                              <1> 
  3939 0000411A 89C3                <1> 	mov bx, ax
  3940 0000411C 0FB606[3141]        <1> 	movzx ax, byte [.var_to_use]
  3941 00004121 E8F403              <1> 	call set_var
  3942                              <1> 
  3943 00004124 A1[2D41]            <1> 	mov word ax, [.curr_location]
  3944 00004127 A3[AB46]            <1> 	mov word [prog], ax
  3945                              <1> 
  3946 0000412A E98AEC              <1> 	jmp mainloop
  3947                              <1> 
  3948                              <1> 
  3949 0000412D 0000                <1> 	.curr_location	dw 0
  3950                              <1> 
  3951 0000412F 0000                <1> 	.to_skip	dw 0
  3952 00004131 00                  <1> 	.var_to_use	db 0
  3953                              <1> ;	.tmp_token 	times 30 db 0
  3954                              <1> 	.tmp_token 	equ 32768-1024-256-30
  3955                              <1> 
  3956                              <1> 
  3957                              <1> ; ------------------------------------------------------------------
  3958                              <1> ; REM
  3959                              <1> 
  3960                              <1> do_rem:
  3961 00004132 8B36[AB46]          <1> 	mov word si, [prog]
  3962 00004136 8A04                <1> 	mov byte al, [si]
  3963 00004138 FF06[AB46]          <1> 	inc word [prog]
  3964 0000413C 3C0A                <1> 	cmp al, 10			; Find end of line after REM
  3965 0000413E 75F2                <1> 	jne do_rem
  3966                              <1> 
  3967 00004140 E974EC              <1> 	jmp mainloop
  3968                              <1> 
  3969                              <1> 
  3970                              <1> ; ------------------------------------------------------------------
  3971                              <1> ; RENAME
  3972                              <1> 
  3973                              <1> do_rename:
  3974 00004143 E8E103              <1> 	call get_token
  3975                              <1> 
  3976 00004146 83F802              <1> 	cmp ax, STRING_VAR		; Is it a string or a quote?
  3977 00004149 7407                <1> 	je .first_is_string
  3978                              <1> 
  3979 0000414B 83F805              <1> 	cmp ax, QUOTE
  3980 0000414E 740E                <1> 	je .first_is_quote
  3981                              <1> 
  3982 00004150 EB61                <1> 	jmp .error
  3983                              <1> 
  3984                              <1> .first_is_string:
  3985 00004152 BE007C              <1> 	mov si, string_vars		; Locate string
  3986 00004155 B88000              <1> 	mov ax, 128
  3987 00004158 F7E3                <1> 	mul bx
  3988 0000415A 01C6                <1> 	add si, ax
  3989                              <1> 
  3990 0000415C EB03                <1> 	jmp .save_file1
  3991                              <1> 
  3992                              <1> .first_is_quote:
  3993 0000415E BE007B              <1> 	mov si, token			; The location of quotes is provided
  3994                              <1> 
  3995                              <1> .save_file1:
  3996 00004161 BF[E041]            <1> 	mov word di, .file1		; The filename is saved to temporary strings because
  3997 00004164 E8A0E9              <1> 	call os_string_copy		; getting a second quote will overwrite the previous
  3998                              <1> 	
  3999                              <1> .get_second:
  4000 00004167 E8BD03              <1> 	call get_token
  4001                              <1> 
  4002 0000416A 83F802              <1> 	cmp ax, STRING_VAR
  4003 0000416D 7407                <1> 	je .second_is_string
  4004                              <1> 
  4005 0000416F 83F805              <1> 	cmp ax, QUOTE
  4006 00004172 740E                <1> 	je .second_is_quote
  4007                              <1> 
  4008 00004174 EB3D                <1> 	jmp .error
  4009                              <1> 
  4010                              <1> .second_is_string:
  4011 00004176 BE007C              <1> 	mov si, string_vars		; Locate second string
  4012 00004179 B88000              <1> 	mov ax, 128
  4013 0000417C F7E3                <1> 	mul bx
  4014 0000417E 01C6                <1> 	add si, ax
  4015                              <1> 
  4016 00004180 EB03                <1> 	jmp .save_file2
  4017                              <1> 
  4018                              <1> .second_is_quote:
  4019 00004182 BE007B              <1> 	mov si, token
  4020                              <1> 
  4021                              <1> .save_file2:
  4022 00004185 BF[EC41]            <1> 	mov word di, .file2
  4023 00004188 E87CE9              <1> 	call os_string_copy
  4024                              <1> 	
  4025                              <1> .check_exists:
  4026 0000418B B8[E041]            <1> 	mov word ax, .file1		; Check if the source file exists
  4027 0000418E E8FDCD              <1> 	call os_file_exists
  4028 00004191 7226                <1> 	jc .file_not_found		; If it doesn't exists set "R = 1"
  4029                              <1> 
  4030 00004193 F8                  <1> 	clc
  4031 00004194 B8[EC41]            <1> 	mov ax, .file2			; The second file is the destination and should not exist
  4032 00004197 E8F4CD              <1> 	call os_file_exists
  4033 0000419A 7337                <1> 	jnc .file_exists		; If it exists set "R = 3"
  4034                              <1> 	
  4035                              <1> .rename:
  4036 0000419C B8[E041]            <1> 	mov word ax, .file1		; Seem to be okay, lets rename
  4037 0000419F BB[EC41]            <1> 	mov word bx, .file2
  4038 000041A2 E86ACF              <1> 	call os_rename_file
  4039                              <1> 
  4040 000041A5 721F                <1> 	jc .rename_failed		; If it failed set "R = 2", usually caused by a read-only disk
  4041                              <1> 
  4042 000041A7 31C0                <1> 	xor ax, ax			; It worked sucessfully, so set "R = 0" to indicate no error
  4043 000041A9 B052                <1> 	mov byte al, 'R'
  4044 000041AB 31DB                <1> 	xor bx, bx
  4045 000041AD E86803              <1> 	call set_var
  4046                              <1> 
  4047 000041B0 E904EC              <1> 	jmp mainloop
  4048                              <1> 
  4049                              <1> .error:
  4050 000041B3 BE1400              <1> 	mov si, err_syntax
  4051 000041B6 E98704              <1> 	jmp error
  4052                              <1> 
  4053                              <1> .file_not_found:
  4054 000041B9 31C0                <1> 	xor ax, ax			; Set R variable to 1
  4055 000041BB B052                <1> 	mov byte al, 'R'
  4056 000041BD BB0100              <1> 	mov bx, 1
  4057 000041C0 E85503              <1> 	call set_var
  4058                              <1> 
  4059 000041C3 E9F1EB              <1> 	jmp mainloop
  4060                              <1> 
  4061                              <1> .rename_failed:
  4062 000041C6 31C0                <1> 	xor ax, ax			; Set R variable to 2
  4063 000041C8 B052                <1> 	mov byte al, 'R'
  4064 000041CA BB0200              <1> 	mov bx, 2
  4065 000041CD E84803              <1> 	call set_var
  4066                              <1> 
  4067 000041D0 E9E4EB              <1> 	jmp mainloop
  4068                              <1> 
  4069                              <1> .file_exists:
  4070 000041D3 31C0                <1> 	xor ax, ax
  4071 000041D5 B052                <1> 	mov byte al, 'R'		; Set R variable to 3
  4072 000041D7 BB0300              <1> 	mov bx, 3
  4073 000041DA E83B03              <1> 	call set_var
  4074                              <1> 
  4075 000041DD E9D7EB              <1> 	jmp mainloop
  4076                              <1> 
  4077                              <1> .data:
  4078 000041E0 00<rep Ch>          <1> 	.file1				times 12 db 0
  4079 000041EC 00<rep Ch>          <1> 	.file2				times 12 db 0
  4080                              <1> 
  4081                              <1> 
  4082                              <1> ; ------------------------------------------------------------------
  4083                              <1> ; RETURN
  4084                              <1> 
  4085                              <1> do_return:
  4086 000041F8 0FB606[2248]        <1> 	movzx ax, byte [gosub_depth]
  4087 000041FD 3C00                <1> 	cmp al, 0
  4088 000041FF 7506                <1> 	jne .is_ok
  4089                              <1> 
  4090 00004201 BE1200              <1> 	mov si, err_return
  4091 00004204 E93904              <1> 	jmp error
  4092                              <1> 
  4093                              <1> .is_ok:
  4094 00004207 BEBC79              <1> 	mov si, gosub_points
  4095 0000420A 01C6                <1> 	add si, ax				; Table is words (not bytes)
  4096 0000420C 01C6                <1> 	add si, ax
  4097 0000420E AD                  <1> 	lodsw
  4098 0000420F A3[AB46]            <1> 	mov word [prog], ax
  4099 00004212 FE0E[2248]          <1> 	dec byte [gosub_depth]
  4100                              <1> 
  4101 00004216 E99EEB              <1> 	jmp mainloop	
  4102                              <1> 
  4103                              <1> 
  4104                              <1> ; ------------------------------------------------------------------
  4105                              <1> ; SAVE
  4106                              <1> 
  4107                              <1> do_save:
  4108 00004219 E80B03              <1> 	call get_token
  4109 0000421C 83F805              <1> 	cmp ax, QUOTE
  4110 0000421F 7413                <1> 	je .is_quote
  4111                              <1> 
  4112 00004221 83F802              <1> 	cmp ax, STRING_VAR
  4113 00004224 0F859500            <1> 	jne near .error
  4114                              <1> 
  4115 00004228 BE007C              <1> 	mov si, string_vars
  4116 0000422B B88000              <1> 	mov ax, 128
  4117 0000422E F7E3                <1> 	mul bx
  4118 00004230 01C6                <1> 	add si, ax
  4119 00004232 EB03                <1> 	jmp .get_position
  4120                              <1> 
  4121                              <1> .is_quote:
  4122 00004234 BE007B              <1> 	mov si, token
  4123                              <1> 
  4124                              <1> .get_position:
  4125 00004237 BF[C942]            <1> 	mov di, .tmp_filename
  4126 0000423A E8CAE8              <1> 	call os_string_copy
  4127                              <1> 
  4128 0000423D E8E702              <1> 	call get_token
  4129                              <1> 
  4130 00004240 83F801              <1> 	cmp ax, VARIABLE
  4131 00004243 744A                <1> 	je .second_is_var
  4132                              <1> 
  4133 00004245 83F803              <1> 	cmp ax, NUMBER
  4134 00004248 7573                <1> 	jne .error
  4135                              <1> 
  4136 0000424A BE007B              <1> 	mov si, token
  4137 0000424D E86AE9              <1> 	call os_string_to_int
  4138                              <1> 
  4139                              <1> .set_data_loc:
  4140 00004250 A3[C542]            <1> 	mov word [.data_loc], ax
  4141                              <1> 
  4142 00004253 E8D102              <1> 	call get_token
  4143                              <1> 
  4144 00004256 83F801              <1> 	cmp ax, VARIABLE
  4145 00004259 743E                <1> 	je .third_is_var
  4146                              <1> 
  4147 0000425B 83F803              <1> 	cmp ax, NUMBER
  4148 0000425E 755D                <1> 	jne .error
  4149                              <1> 
  4150 00004260 BE007B              <1> 	mov si, token
  4151 00004263 E854E9              <1> 	call os_string_to_int
  4152                              <1> 
  4153                              <1> .check_exists:
  4154 00004266 A3[C742]            <1> 	mov word [.data_size], ax
  4155 00004269 B8[C942]            <1> 	mov word ax, .tmp_filename
  4156 0000426C E81FCD              <1> 	call os_file_exists
  4157 0000426F 7202                <1> 	jc .write_file
  4158 00004271 EB30                <1> 	jmp .file_exists_fail
  4159                              <1> 	
  4160                              <1> .write_file:
  4161                              <1> 
  4162 00004273 B8[C942]            <1> 	mov word ax, .tmp_filename
  4163 00004276 8B1E[C542]          <1> 	mov word bx, [.data_loc]
  4164 0000427A 8B0E[C742]          <1> 	mov word cx, [.data_size]
  4165                              <1> 	
  4166 0000427E E82BCB              <1> 	call os_write_file
  4167 00004281 722D                <1> 	jc .save_failure
  4168                              <1> 
  4169 00004283 31C0                <1> 	xor ax, ax
  4170 00004285 B052                <1> 	mov byte al, 'R'
  4171 00004287 31DB                <1> 	xor bx, bx
  4172 00004289 E88C02              <1> 	call set_var
  4173                              <1> 
  4174 0000428C E928EB              <1> 	jmp mainloop
  4175                              <1> 
  4176                              <1> 
  4177                              <1> .second_is_var:
  4178 0000428F 0FB606007B          <1> 	movzx ax, byte [token]
  4179 00004294 E87402              <1> 	call get_var
  4180 00004297 EBB7                <1> 	jmp .set_data_loc
  4181                              <1> 
  4182                              <1> 
  4183                              <1> .third_is_var:
  4184 00004299 0FB606007B          <1> 	movzx ax, byte [token]
  4185 0000429E E86A02              <1> 	call get_var
  4186 000042A1 EBC3                <1> 	jmp .check_exists
  4187                              <1> 
  4188                              <1> .file_exists_fail:
  4189 000042A3 31C0                <1> 	xor ax, ax
  4190 000042A5 B052                <1> 	mov byte al, 'R'
  4191 000042A7 BB0200              <1> 	mov bx, 2
  4192 000042AA E86B02              <1> 	call set_var
  4193 000042AD E907EB              <1> 	jmp mainloop
  4194                              <1> 	
  4195                              <1> .save_failure:
  4196 000042B0 31C0                <1> 	xor ax, ax
  4197 000042B2 B052                <1> 	mov byte al, 'R'
  4198 000042B4 BB0100              <1> 	mov bx, 1
  4199 000042B7 E85E02              <1> 	call set_var
  4200                              <1> 
  4201 000042BA E9FAEA              <1> 	jmp mainloop
  4202                              <1> 
  4203                              <1> .error:
  4204 000042BD BE1400              <1> 	mov si, err_syntax
  4205 000042C0 E97D03              <1> 	jmp error
  4206                              <1> 
  4207                              <1> 
  4208 000042C3 0000                <1> 	.filename_loc	dw 0
  4209 000042C5 0000                <1> 	.data_loc	dw 0
  4210 000042C7 0000                <1> 	.data_size	dw 0
  4211                              <1> 
  4212 000042C9 00<rep Fh>          <1> 	.tmp_filename	times 15 db 0
  4213                              <1> 
  4214                              <1> 
  4215                              <1> ; ------------------------------------------------------------------
  4216                              <1> ; SERIAL
  4217                              <1> 
  4218                              <1> do_serial:
  4219 000042D8 E84C02              <1> 	call get_token
  4220 000042DB BE007B              <1> 	mov si, token
  4221                              <1> 
  4222 000042DE BF[7043]            <1> 	mov di, .on_cmd
  4223 000042E1 E882E8              <1> 	call os_string_compare
  4224 000042E4 7212                <1> 	jc .do_on_cmd
  4225                              <1> 
  4226 000042E6 BF[7343]            <1> 	mov di, .send_cmd
  4227 000042E9 E87AE8              <1> 	call os_string_compare
  4228 000042EC 7237                <1> 	jc .do_send_cmd
  4229                              <1> 
  4230 000042EE BF[7843]            <1> 	mov di, .rec_cmd
  4231 000042F1 E872E8              <1> 	call os_string_compare
  4232 000042F4 7258                <1> 	jc .do_rec_cmd
  4233                              <1> 
  4234 000042F6 EB72                <1> 	jmp .error
  4235                              <1> 
  4236                              <1> .do_on_cmd:
  4237 000042F8 E82C02              <1> 	call get_token
  4238 000042FB 83F803              <1> 	cmp ax, NUMBER
  4239 000042FE 7402                <1> 	je .do_on_cmd_ok
  4240 00004300 EB68                <1> 	jmp .error
  4241                              <1> 
  4242                              <1> .do_on_cmd_ok:
  4243 00004302 BE007B              <1> 	mov si, token
  4244 00004305 E8B2E8              <1> 	call os_string_to_int
  4245 00004308 3DB004              <1> 	cmp ax, 1200
  4246 0000430B 740F                <1> 	je .on_cmd_slow_mode
  4247 0000430D 3D8025              <1> 	cmp ax, 9600
  4248 00004310 7402                <1> 	je .on_cmd_fast_mode
  4249                              <1> 
  4250 00004312 EB56                <1> 	jmp .error
  4251                              <1> 
  4252                              <1> .on_cmd_fast_mode:
  4253 00004314 31C0                <1> 	xor ax, ax
  4254 00004316 E852D5              <1> 	call os_serial_port_enable
  4255 00004319 E99BEA              <1> 	jmp mainloop
  4256                              <1> 
  4257                              <1> .on_cmd_slow_mode:
  4258 0000431C B80100              <1> 	mov ax, 1
  4259 0000431F E849D5              <1> 	call os_serial_port_enable
  4260 00004322 E992EA              <1> 	jmp mainloop
  4261                              <1> 
  4262                              <1> 
  4263                              <1> .do_send_cmd:
  4264 00004325 E8FF01              <1> 	call get_token
  4265 00004328 83F803              <1> 	cmp ax, NUMBER
  4266 0000432B 7407                <1> 	je .send_number
  4267                              <1> 
  4268 0000432D 83F801              <1> 	cmp ax, VARIABLE
  4269 00004330 740E                <1> 	je .send_variable
  4270                              <1> 
  4271 00004332 EB36                <1> 	jmp .error
  4272                              <1> 
  4273                              <1> .send_number:
  4274 00004334 BE007B              <1> 	mov si, token
  4275 00004337 E880E8              <1> 	call os_string_to_int
  4276 0000433A E842D5              <1> 	call os_send_via_serial
  4277 0000433D E977EA              <1> 	jmp mainloop
  4278                              <1> 
  4279                              <1> .send_variable:
  4280 00004340 0FB606007B          <1> 	movzx ax, byte [token]
  4281 00004345 E8C301              <1> 	call get_var
  4282 00004348 E834D5              <1> 	call os_send_via_serial
  4283 0000434B E969EA              <1> 	jmp mainloop
  4284                              <1> 
  4285                              <1> 
  4286                              <1> .do_rec_cmd:
  4287 0000434E E8D601              <1> 	call get_token
  4288 00004351 83F801              <1> 	cmp ax, VARIABLE
  4289 00004354 7514                <1> 	jne .error
  4290                              <1> 
  4291 00004356 A0007B              <1> 	mov byte al, [token]
  4292                              <1> 
  4293 00004359 0FB6C8              <1> 	movzx cx, al
  4294 0000435C E832D5              <1> 	call os_get_via_serial
  4295                              <1> 
  4296 0000435F 0FB6D8              <1> 	movzx bx, al
  4297 00004362 88C8                <1> 	mov al, cl
  4298 00004364 E8B101              <1> 	call set_var
  4299                              <1> 
  4300 00004367 E94DEA              <1> 	jmp mainloop
  4301                              <1> 
  4302                              <1> 
  4303                              <1> .error:
  4304 0000436A BE1400              <1> 	mov si, err_syntax
  4305 0000436D E9D002              <1> 	jmp error
  4306                              <1> 
  4307                              <1> 
  4308 00004370 4F4E00              <1> 	.on_cmd		db "ON", 0
  4309 00004373 53454E4400          <1> 	.send_cmd	db "SEND", 0
  4310 00004378 52454300            <1> 	.rec_cmd	db "REC", 0
  4311                              <1> 
  4312                              <1> 
  4313                              <1> ; ------------------------------------------------------------------
  4314                              <1> ; SIZE
  4315                              <1> 
  4316                              <1> do_size:
  4317 0000437C E8A801              <1> 	call get_token
  4318                              <1> 
  4319 0000437F 83F802              <1> 	cmp ax, STRING_VAR
  4320 00004382 7407                <1> 	je .is_string
  4321                              <1> 
  4322 00004384 83F805              <1> 	cmp ax, QUOTE
  4323 00004387 7410                <1> 	je .is_quote
  4324                              <1> 
  4325 00004389 EB29                <1> 	jmp .error
  4326                              <1> 
  4327                              <1> .is_string:
  4328 0000438B BE007C              <1> 	mov si, string_vars
  4329 0000438E B88000              <1> 	mov ax, 128
  4330 00004391 F7E3                <1> 	mul bx
  4331 00004393 01C6                <1> 	add si, ax
  4332                              <1> 
  4333 00004395 89F0                <1> 	mov ax, si
  4334 00004397 EB03                <1> 	jmp .get_size
  4335                              <1> 
  4336                              <1> .is_quote:
  4337 00004399 B8007B              <1> 	mov ax, token
  4338                              <1> 
  4339                              <1> .get_size:
  4340 0000439C E8A5CD              <1> 	call os_get_file_size
  4341 0000439F 7219                <1> 	jc .file_not_found
  4342                              <1> 
  4343 000043A1 31C0                <1> 	xor ax, ax
  4344 000043A3 B053                <1> 	mov al, 'S'
  4345 000043A5 E87001              <1> 	call set_var
  4346                              <1> 
  4347 000043A8 31C0                <1> 	xor ax, ax
  4348 000043AA B052                <1> 	mov al, 'R'
  4349 000043AC 31DB                <1> 	xor bx, bx
  4350 000043AE E86701              <1> 	call set_var
  4351                              <1> 
  4352 000043B1 E903EA              <1> 	jmp mainloop
  4353                              <1> 
  4354                              <1> .error:
  4355 000043B4 BE1400              <1> 	mov si, err_syntax
  4356 000043B7 E98602              <1> 	jmp error
  4357                              <1> 
  4358                              <1> .file_not_found:
  4359 000043BA 0FB606007B          <1> 	movzx ax, byte [token]
  4360 000043BF 89DB                <1> 	mov bx, bx
  4361 000043C1 E85401              <1> 	call set_var
  4362                              <1> 
  4363 000043C4 31C0                <1> 	xor ax, ax
  4364 000043C6 B052                <1> 	mov al, 'R'
  4365 000043C8 BB0100              <1> 	mov bx, 1
  4366 000043CB E84A01              <1>  	call set_var
  4367                              <1>  	
  4368 000043CE E9E6E9              <1> 	jmp mainloop
  4369                              <1> 
  4370                              <1> 
  4371                              <1> 
  4372                              <1> ; ------------------------------------------------------------------
  4373                              <1> ; SOUND
  4374                              <1> 
  4375                              <1> do_sound:
  4376 000043D1 E85301              <1> 	call get_token
  4377                              <1> 
  4378 000043D4 83F801              <1> 	cmp ax, VARIABLE
  4379 000043D7 7408                <1> 	je .first_is_var
  4380                              <1> 
  4381 000043D9 BE007B              <1> 	mov si, token
  4382 000043DC E8DBE7              <1> 	call os_string_to_int
  4383 000043DF EB08                <1> 	jmp .done_first
  4384                              <1> 
  4385                              <1> .first_is_var:
  4386 000043E1 0FB606007B          <1> 	movzx ax, byte [token]
  4387 000043E6 E82201              <1> 	call get_var
  4388                              <1> 
  4389                              <1> .done_first:
  4390 000043E9 E8FFE2              <1> 	call os_speaker_tone
  4391                              <1> 
  4392 000043EC E83801              <1> 	call get_token
  4393                              <1> 
  4394 000043EF 83F801              <1> 	cmp ax, VARIABLE
  4395 000043F2 7408                <1> 	je .second_is_var
  4396                              <1> 
  4397 000043F4 BE007B              <1> 	mov si, token
  4398 000043F7 E8C0E7              <1> 	call os_string_to_int
  4399 000043FA EB08                <1> 	jmp .finish
  4400                              <1> 
  4401                              <1> .second_is_var:
  4402 000043FC 0FB606007B          <1> 	movzx ax, byte [token]
  4403 00004401 E80701              <1> 	call get_var
  4404                              <1> 
  4405                              <1> .finish:
  4406 00004404 E882D1              <1> 	call os_pause
  4407 00004407 E821E3              <1> 	call os_speaker_off
  4408                              <1> 
  4409 0000440A E9AAE9              <1> 	jmp mainloop
  4410                              <1> 
  4411                              <1> 
  4412                              <1> ;-------------------------------------------------------------------
  4413                              <1> ; STRING
  4414                              <1> do_string:
  4415 0000440D E81701              <1> 	call get_token			; The first parameter is the word 'GET' or 'SET'
  4416 00004410 BE007B              <1> 	mov si, token
  4417                              <1> 	
  4418 00004413 BF[B744]            <1> 	mov di, .get_cmd
  4419 00004416 E84DE7              <1> 	call os_string_compare
  4420 00004419 720B                <1> 	jc .set_str
  4421                              <1> 		
  4422 0000441B BF[BB44]            <1> 	mov di, .set_cmd
  4423 0000441E E845E7              <1> 	call os_string_compare
  4424 00004421 7208                <1> 	jc .get_str
  4425                              <1> 	
  4426 00004423 E98500              <1> 	jmp .error
  4427                              <1> 	
  4428                              <1> 	.set_str:
  4429 00004426 B90100              <1> 	mov cx, 1
  4430 00004429 EB03                <1> 	jmp .check_second
  4431                              <1> 	.get_str:
  4432 0000442B B90200              <1> 	mov cx, 2
  4433                              <1> 
  4434                              <1> .check_second:
  4435 0000442E E8F600              <1> 	call get_token			; The next should be a string variable, locate it
  4436                              <1> 	
  4437 00004431 83F802              <1> 	cmp ax, STRING_VAR
  4438 00004434 7575                <1> 	jne .error
  4439                              <1> 	
  4440 00004436 BE007C              <1> 	mov si, string_vars
  4441 00004439 B88000              <1> 	mov ax, 128
  4442 0000443C F7E3                <1> 	mul bx
  4443 0000443E 01C6                <1> 	add si, ax
  4444 00004440 8936[BF44]          <1> 	mov word [.string_loc], si
  4445                              <1> 	
  4446                              <1> .check_third:
  4447 00004444 E8E000              <1> 	call get_token			; Now there should be a number
  4448                              <1> 	
  4449 00004447 83F803              <1> 	cmp ax, NUMBER
  4450 0000444A 7407                <1> 	je .third_is_number
  4451                              <1> 	
  4452 0000444C 83F801              <1> 	cmp ax, VARIABLE
  4453 0000444F 740A                <1> 	je .third_is_variable
  4454                              <1> 	
  4455 00004451 EB58                <1> 	jmp .error
  4456                              <1> 	
  4457                              <1> .third_is_number:	
  4458 00004453 BE007B              <1> 	mov si, token
  4459 00004456 E861E7              <1> 	call os_string_to_int
  4460 00004459 EB0A                <1> 	jmp .got_number	
  4461                              <1> 
  4462                              <1> .third_is_variable:
  4463 0000445B B400                <1> 	mov ah, 0
  4464 0000445D A0007B              <1> 	mov al, [token]
  4465 00004460 E8A800              <1> 	call get_var
  4466 00004463 EB00                <1> 	jmp .got_number
  4467                              <1> 
  4468                              <1> .got_number:
  4469 00004465 3D8000              <1> 	cmp ax, 128
  4470 00004468 7F47                <1> 	jg .outrange
  4471 0000446A 83F800              <1> 	cmp ax, 0
  4472 0000446D 7442                <1> 	je .outrange
  4473 0000446F 83E801              <1> 	sub ax, 1
  4474 00004472 89C2                <1> 	mov dx, ax
  4475                              <1> 	
  4476                              <1> .check_forth:
  4477 00004474 E8B000              <1> 	call get_token			; Next a numerical variable
  4478                              <1> 	
  4479 00004477 83F801              <1> 	cmp ax, VARIABLE
  4480 0000447A 752F                <1> 	jne .error
  4481                              <1> 	
  4482 0000447C A0007B              <1> 	mov byte al, [token]
  4483 0000447F A2[C144]            <1> 	mov byte [.tmp], al
  4484                              <1> 	
  4485 00004482 83F902              <1> 	cmp cx, 2
  4486 00004485 7414                <1> 	je .set_var
  4487                              <1> 	
  4488                              <1> .get_var:
  4489 00004487 8B36[BF44]          <1> 	mov word si, [.string_loc]	; Move to string location
  4490 0000448B 01D6                <1> 	add si, dx			; Add offset
  4491 0000448D AC                  <1> 	lodsb				; Load data
  4492 0000448E B400                <1> 	mov ah, 0
  4493 00004490 89C3                <1> 	mov bx, ax			; Set data in numerical variable
  4494 00004492 A0[C144]            <1> 	mov byte al, [.tmp]
  4495 00004495 E88000              <1> 	call set_var
  4496 00004498 E91CE9              <1> 	jmp mainloop
  4497                              <1> 	
  4498                              <1> .set_var:
  4499 0000449B A0[C144]            <1> 	mov byte al, [.tmp]		; Retrieve the variable
  4500 0000449E E86A00              <1> 	call get_var			; Get it's value
  4501 000044A1 8B3E[BF44]          <1> 	mov di, [.string_loc]		; Locate the string
  4502 000044A5 01D7                <1> 	add di, dx			; Add the offset
  4503 000044A7 AA                  <1> 	stosb				; Store data
  4504 000044A8 E90CE9              <1> 	jmp mainloop
  4505                              <1> 	
  4506                              <1> .error:
  4507 000044AB BE1400              <1> 	mov si, err_syntax
  4508 000044AE E98F01              <1> 	jmp error
  4509                              <1> 	
  4510                              <1> .outrange:
  4511 000044B1 BE1300              <1> 	mov si, err_string_range
  4512 000044B4 E98901              <1> 	jmp error
  4513                              <1> 
  4514                              <1> .data:
  4515 000044B7 47455400            <1> 	.get_cmd		db "GET", 0
  4516 000044BB 53455400            <1> 	.set_cmd		db "SET", 0
  4517 000044BF 0000                <1> 	.string_loc		dw 0
  4518 000044C1 00                  <1> 	.tmp			db 0
  4519                              <1> 
  4520                              <1> 
  4521                              <1> 
  4522                              <1> ; ------------------------------------------------------------------
  4523                              <1> ; WAITKEY
  4524                              <1> 
  4525                              <1> do_waitkey:
  4526 000044C2 E86200              <1> 	call get_token
  4527 000044C5 83F801              <1> 	cmp ax, VARIABLE
  4528 000044C8 7406                <1> 	je .is_variable
  4529                              <1> 
  4530 000044CA BE1400              <1> 	mov si, err_syntax
  4531 000044CD E97001              <1> 	jmp error
  4532                              <1> 
  4533                              <1> .is_variable:
  4534 000044D0 0FB606007B          <1> 	movzx ax, byte [token]
  4535                              <1> 
  4536 000044D5 50                  <1> 	push ax
  4537                              <1> 
  4538 000044D6 E85ECE              <1> 	call os_wait_for_key
  4539                              <1> 
  4540 000044D9 80FC48              <1> 	cmp ah, 48h
  4541 000044DC 7419                <1> 	je .up_pressed
  4542                              <1> 	
  4543 000044DE 80FC50              <1> 	cmp ah, 50h
  4544 000044E1 7419                <1> 	je .down_pressed
  4545                              <1> 
  4546 000044E3 80FC4B              <1> 	cmp ah, 4Bh
  4547 000044E6 7419                <1> 	je .left_pressed
  4548                              <1> 
  4549 000044E8 80FC4D              <1> 	cmp ah, 4Dh
  4550 000044EB 7419                <1> 	je .right_pressed
  4551                              <1> 
  4552                              <1> .store:
  4553 000044ED 0FB6D8              <1> 	movzx bx, al
  4554                              <1> 
  4555 000044F0 58                  <1> 	pop ax
  4556                              <1> 
  4557 000044F1 E82400              <1> 	call set_var
  4558                              <1> 
  4559 000044F4 E9C0E8              <1> 	jmp mainloop
  4560                              <1> 
  4561                              <1> 
  4562                              <1> .up_pressed:
  4563 000044F7 B80100              <1> 	mov ax, 1
  4564 000044FA EBF1                <1> 	jmp .store
  4565                              <1> 
  4566                              <1> .down_pressed:
  4567 000044FC B80200              <1> 	mov ax, 2
  4568 000044FF EBEC                <1> 	jmp .store
  4569                              <1> 
  4570                              <1> .left_pressed:
  4571 00004501 B80300              <1> 	mov ax, 3
  4572 00004504 EBE7                <1> 	jmp .store
  4573                              <1> 
  4574                              <1> .right_pressed:
  4575 00004506 B80400              <1> 	mov ax, 4
  4576 00004509 EBE2                <1> 	jmp .store
  4577                              <1> 
  4578                              <1> 
  4579                              <1> ; ==================================================================
  4580                              <1> ; INTERNAL ROUTINES FOR INTERPRETER
  4581                              <1> 
  4582                              <1> ; ------------------------------------------------------------------
  4583                              <1> ; Get value of variable character specified in AL (eg 'A')
  4584                              <1> 
  4585                              <1> get_var:
  4586 0000450B B400                <1> 	mov ah, 0
  4587 0000450D 2C41                <1> 	sub al, 65
  4588 0000450F BE4C7A              <1> 	mov si, variables
  4589 00004512 01C6                <1> 	add si, ax
  4590 00004514 01C6                <1> 	add si, ax
  4591 00004516 AD                  <1> 	lodsw
  4592 00004517 C3                  <1> 	ret
  4593                              <1> 
  4594                              <1> 
  4595                              <1> ; ------------------------------------------------------------------
  4596                              <1> ; Set value of variable character specified in AL (eg 'A')
  4597                              <1> ; with number specified in BX
  4598                              <1> 
  4599                              <1> set_var:
  4600 00004518 B400                <1> 	mov ah, 0
  4601 0000451A 2C41                <1> 	sub al, 65				; Remove ASCII codes before 'A'
  4602                              <1> 
  4603 0000451C BF4C7A              <1> 	mov di, variables			; Find position in table (of words)
  4604 0000451F 01C7                <1> 	add di, ax
  4605 00004521 01C7                <1> 	add di, ax
  4606 00004523 89D8                <1> 	mov ax, bx
  4607 00004525 AB                  <1> 	stosw
  4608 00004526 C3                  <1> 	ret
  4609                              <1> 
  4610                              <1> 
  4611                              <1> ; ------------------------------------------------------------------
  4612                              <1> ; Get token from current position in prog
  4613                              <1> 
  4614                              <1> get_token:
  4615 00004527 8B36[AB46]          <1> 	mov word si, [prog]
  4616 0000452B AC                  <1> 	lodsb
  4617                              <1> 
  4618 0000452C 3C0A                <1> 	cmp al, 10
  4619 0000452E 741A                <1> 	je .newline
  4620                              <1> 
  4621 00004530 3C20                <1> 	cmp al, ' '
  4622 00004532 7416                <1> 	je .newline
  4623                              <1> 
  4624 00004534 E8F100              <1> 	call is_number
  4625 00004537 7217                <1> 	jc get_number_token
  4626                              <1> 
  4627 00004539 3C22                <1> 	cmp al, '"'
  4628 0000453B 745F                <1> 	je get_quote_token
  4629                              <1> 
  4630 0000453D 3C27                <1> 	cmp al, 39			; Quote mark (')
  4631 0000453F 7438                <1> 	je get_char_token
  4632                              <1> 
  4633 00004541 3C24                <1> 	cmp al, '$'
  4634 00004543 0F848000            <1> 	je near get_string_var_token
  4635                              <1> 
  4636 00004547 E99000              <1> 	jmp get_string_token
  4637                              <1> 
  4638                              <1> 
  4639                              <1> .newline:
  4640 0000454A FF06[AB46]          <1> 	inc word [prog]
  4641 0000454E EBD7                <1> 	jmp get_token
  4642                              <1> 
  4643                              <1> 
  4644                              <1> 
  4645                              <1> get_number_token:
  4646 00004550 8B36[AB46]          <1> 	mov word si, [prog]
  4647 00004554 BF007B              <1> 	mov di, token
  4648                              <1> 
  4649                              <1> .loop:
  4650 00004557 AC                  <1> 	lodsb
  4651 00004558 3C0A                <1> 	cmp al, 10
  4652 0000455A 7416                <1> 	je .done
  4653 0000455C 3C20                <1> 	cmp al, ' '
  4654 0000455E 7412                <1> 	je .done
  4655 00004560 E8C500              <1> 	call is_number
  4656 00004563 7206                <1> 	jc .fine
  4657                              <1> 
  4658 00004565 BE0000              <1> 	mov si, err_char_in_num
  4659 00004568 E9D500              <1> 	jmp error
  4660                              <1> 
  4661                              <1> .fine:
  4662 0000456B AA                  <1> 	stosb
  4663 0000456C FF06[AB46]          <1> 	inc word [prog]
  4664 00004570 EBE5                <1> 	jmp .loop
  4665                              <1> 
  4666                              <1> .done:
  4667 00004572 B000                <1> 	mov al, 0			; Zero-terminate the token
  4668 00004574 AA                  <1> 	stosb
  4669                              <1> 
  4670 00004575 B80300              <1> 	mov ax, NUMBER			; Pass back the token type
  4671 00004578 C3                  <1> 	ret
  4672                              <1> 
  4673                              <1> 
  4674                              <1> get_char_token:
  4675 00004579 FF06[AB46]          <1> 	inc word [prog]			; Move past first quote (')
  4676                              <1> 
  4677 0000457D 8B36[AB46]          <1> 	mov word si, [prog]
  4678 00004581 AC                  <1> 	lodsb
  4679                              <1> 
  4680 00004582 A2007B              <1> 	mov byte [token], al
  4681                              <1> 
  4682 00004585 AC                  <1> 	lodsb
  4683 00004586 3C27                <1> 	cmp al, 39			; Needs to finish with another quote
  4684 00004588 7406                <1> 	je .is_ok
  4685                              <1> 
  4686 0000458A BE1100              <1> 	mov si, err_quote_term
  4687 0000458D E9B000              <1> 	jmp error
  4688                              <1> 
  4689                              <1> .is_ok:
  4690 00004590 FF06[AB46]          <1> 	inc word [prog]
  4691 00004594 FF06[AB46]          <1> 	inc word [prog]
  4692                              <1> 
  4693 00004598 B80600              <1> 	mov ax, CHAR
  4694 0000459B C3                  <1> 	ret
  4695                              <1> 
  4696                              <1> 
  4697                              <1> get_quote_token:
  4698 0000459C FF06[AB46]          <1> 	inc word [prog]			; Move past first quote (") char
  4699 000045A0 8B36[AB46]          <1> 	mov word si, [prog]
  4700 000045A4 BF007B              <1> 	mov di, token
  4701                              <1> .loop:
  4702 000045A7 AC                  <1> 	lodsb
  4703 000045A8 3C22                <1> 	cmp al, '"'
  4704 000045AA 740B                <1> 	je .done
  4705 000045AC 3C0A                <1> 	cmp al, 10
  4706 000045AE 7412                <1> 	je .error
  4707 000045B0 AA                  <1> 	stosb
  4708 000045B1 FF06[AB46]          <1> 	inc word [prog]
  4709 000045B5 EBF0                <1> 	jmp .loop
  4710                              <1> 
  4711                              <1> .done:
  4712 000045B7 B000                <1> 	mov al, 0			; Zero-terminate the token
  4713 000045B9 AA                  <1> 	stosb
  4714 000045BA FF06[AB46]          <1> 	inc word [prog]			; Move past final quote
  4715                              <1> 
  4716 000045BE B80500              <1> 	mov ax, QUOTE			; Pass back token type
  4717 000045C1 C3                  <1> 	ret
  4718                              <1> 
  4719                              <1> .error:
  4720 000045C2 BE1100              <1> 	mov si, err_quote_term
  4721 000045C5 EB79                <1> 	jmp error
  4722                              <1> 
  4723                              <1> 
  4724                              <1> get_string_var_token:
  4725 000045C7 AC                  <1> 	lodsb
  4726 000045C8 0FB6D8              <1> 	movzx bx, al
  4727 000045CB 80EB31              <1> 	sub bl, 49
  4728                              <1> 
  4729 000045CE FF06[AB46]          <1> 	inc word [prog]
  4730 000045D2 FF06[AB46]          <1> 	inc word [prog]
  4731                              <1> 
  4732 000045D6 B80200              <1> 	mov ax, STRING_VAR
  4733 000045D9 C3                  <1> 	ret
  4734                              <1> 	
  4735                              <1> 
  4736                              <1> get_string_token:
  4737 000045DA 8B36[AB46]          <1> 	mov word si, [prog]
  4738 000045DE BF007B              <1> 	mov di, token
  4739                              <1> .loop:
  4740 000045E1 AC                  <1> 	lodsb
  4741 000045E2 3C0A                <1> 	cmp al, 10
  4742 000045E4 740B                <1> 	je .done
  4743 000045E6 3C20                <1> 	cmp al, ' '
  4744 000045E8 7407                <1> 	je .done
  4745 000045EA AA                  <1> 	stosb
  4746 000045EB FF06[AB46]          <1> 	inc word [prog]
  4747 000045EF EBF0                <1> 	jmp .loop
  4748                              <1> .done:
  4749 000045F1 B000                <1> 	mov al, 0			; Zero-terminate the token
  4750 000045F3 AA                  <1> 	stosb
  4751                              <1> 
  4752 000045F4 B8007B              <1> 	mov ax, token
  4753 000045F7 E8D3E4              <1> 	call os_string_uppercase
  4754                              <1> 
  4755 000045FA B8007B              <1> 	mov ax, token
  4756 000045FD E874E4              <1> 	call os_string_length		; How long was the token?
  4757 00004600 83F801              <1> 	cmp ax, 1			; If 1 char, it's a variable or delimiter
  4758 00004603 7413                <1> 	je .is_not_string
  4759                              <1> 
  4760 00004605 BE007B              <1> 	mov si, token			; If the token ends with ':', it's a label
  4761 00004608 01C6                <1> 	add si, ax
  4762 0000460A 4E                  <1> 	dec si
  4763 0000460B AC                  <1> 	lodsb
  4764 0000460C 3C3A                <1> 	cmp al, ':'
  4765 0000460E 7404                <1> 	je .is_label
  4766                              <1> 
  4767 00004610 B80400              <1> 	mov ax, STRING			; Otherwise it's a general string of characters
  4768 00004613 C3                  <1> 	ret
  4769                              <1> 
  4770                              <1> .is_label:
  4771 00004614 B80800              <1> 	mov ax, LABEL
  4772 00004617 C3                  <1> 	ret
  4773                              <1> 
  4774                              <1> 
  4775                              <1> .is_not_string:
  4776 00004618 A0007B              <1> 	mov byte al, [token]
  4777 0000461B E81600              <1> 	call is_letter
  4778 0000461E 7204                <1> 	jc .is_var
  4779                              <1> 
  4780 00004620 B80700              <1> 	mov ax, UNKNOWN
  4781 00004623 C3                  <1> 	ret
  4782                              <1> 
  4783                              <1> .is_var:
  4784 00004624 B80100              <1> 	mov ax, VARIABLE		; Otherwise probably a variable
  4785 00004627 C3                  <1> 	ret
  4786                              <1> 
  4787                              <1> 
  4788                              <1> ; ------------------------------------------------------------------
  4789                              <1> ; Set carry flag if AL contains ASCII number
  4790                              <1> 
  4791                              <1> is_number:
  4792 00004628 3C30                <1> 	cmp al, 48
  4793 0000462A 7C06                <1> 	jl .not_number
  4794 0000462C 3C39                <1> 	cmp al, 57
  4795 0000462E 7F02                <1> 	jg .not_number
  4796 00004630 F9                  <1> 	stc
  4797 00004631 C3                  <1> 	ret
  4798                              <1> .not_number:
  4799 00004632 F8                  <1> 	clc
  4800 00004633 C3                  <1> 	ret
  4801                              <1> 
  4802                              <1> 
  4803                              <1> ; ------------------------------------------------------------------
  4804                              <1> ; Set carry flag if AL contains ASCII letter
  4805                              <1> 
  4806                              <1> is_letter:
  4807 00004634 3C41                <1> 	cmp al, 65
  4808 00004636 7C06                <1> 	jl .not_letter
  4809 00004638 3C5A                <1> 	cmp al, 90
  4810 0000463A 7F02                <1> 	jg .not_letter
  4811 0000463C F9                  <1> 	stc
  4812 0000463D C3                  <1> 	ret
  4813                              <1> 
  4814                              <1> .not_letter:
  4815 0000463E F8                  <1> 	clc
  4816 0000463F C3                  <1> 	ret
  4817                              <1> 
  4818                              <1> 
  4819                              <1> ; ------------------------------------------------------------------
  4820                              <1> ; Print error message and quit out
  4821                              <1> 
  4822                              <1> error:
  4823 00004640 B80005              <1> 	mov ax, 5 * 256			; Revert display page
  4824 00004643 CD10                <1> 	int 10h
  4825                              <1> 
  4826 00004645 E8B7D9              <1> 	call os_print_newline
  4827 00004648 BE[8C46]            <1> 	mov si, err_msg
  4828 0000464B E868D2              <1> 	call os_print_string
  4829                              <1> 	
  4830 0000464E 88D8                <1> 	mov al, bl
  4831 00004650 E800DC              <1> 	call os_print_2hex
  4832                              <1> 	
  4833 00004653 C606[B546]00        <1> 	mov byte [work_page], 0
  4834 00004658 C606[B646]00        <1> 	mov byte [disp_page], 0
  4835                              <1> 
  4836 0000465D BE[A046]            <1> 	mov si, line_num_starter
  4837 00004660 E853D2              <1> 	call os_print_string
  4838                              <1> 
  4839                              <1> 
  4840                              <1> 	; And now print the line number where the error occurred. We do this
  4841                              <1> 	; by working from the start of the program to the current point,
  4842                              <1> 	; counting the number of newline characters along the way
  4843                              <1> 
  4844 00004663 8B36[AF46]          <1> 	mov word si, [load_point]
  4845 00004667 8B1E[AB46]          <1> 	mov word bx, [prog]
  4846 0000466B B90100              <1> 	mov cx, 1
  4847                              <1> 
  4848                              <1> .loop:
  4849 0000466E AC                  <1> 	lodsb
  4850 0000466F 3C0A                <1> 	cmp al, 10
  4851 00004671 7501                <1> 	jne .not_newline
  4852 00004673 41                  <1> 	inc cx
  4853                              <1> .not_newline:
  4854 00004674 39DE                <1> 	cmp si, bx
  4855 00004676 7402                <1> 	je .finish
  4856 00004678 EBF4                <1> 	jmp .loop
  4857                              <1> .finish:
  4858                              <1> 
  4859 0000467A 89C8                <1> 	mov ax, cx
  4860 0000467C E886E5              <1> 	call os_int_to_string
  4861 0000467F 89C6                <1> 	mov si, ax
  4862 00004681 E832D2              <1> 	call os_print_string
  4863                              <1> 
  4864                              <1> 
  4865 00004684 E878D9              <1> 	call os_print_newline
  4866                              <1> 
  4867 00004687 8B26[A946]          <1> 	mov word sp, [orig_stack]	; Restore the stack to as it was when BASIC started
  4868                              <1> 
  4869 0000468B C3                  <1> 	ret				; And finish
  4870                              <1> 
  4871                              <1> 
  4872                              <1> 	; Error messages text...
  4873                              <1> 
  4874                              <1> 	err_char_in_num		equ 00h
  4875                              <1> 	err_cmd_unknown		equ 01h
  4876                              <1> 	err_divide_by_zero	equ 02h
  4877                              <1> 	err_doloop_maximum	equ 03h
  4878                              <1> 	err_file_notfound	equ 04h
  4879                              <1> 	err_goto_notlabel	equ 05h
  4880                              <1> 	err_label_notfound	equ 06h
  4881                              <1> 	err_nest_limit		equ 07h
  4882                              <1> 	err_next			equ 08h
  4883                              <1> 	err_loop			equ 09h
  4884                              <1> 	err_print_type		equ 10h
  4885                              <1> 	err_quote_term		equ 11h
  4886                              <1> 	err_return			equ 12h
  4887                              <1> 	err_string_range	equ 13h
  4888                              <1> 	err_syntax			equ 14h
  4889                              <1> 
  4890 0000468C 4572726F722000      <1> 	err_msg				db "Error ", 0
  4891                              <1> 
  4892 00004693 425245414B2043414C- <1> 	err_break			db "BREAK CALLED", 0
  4892 0000469C 4C454400            <1>
  4893                              <1> 
  4894 000046A0 202D206C696E652000  <1> 	line_num_starter	db " - line ", 0
  4895                              <1> 
  4896                              <1> 
  4897                              <1> ; ==================================================================
  4898                              <1> ; DATA SECTION
  4899                              <1> 
  4900 000046A9 0000                <1> 	orig_stack		dw 0		; Original stack location when BASIC started
  4901                              <1> 
  4902 000046AB 0000                <1> 	prog			dw 0		; Pointer to current location in BASIC code
  4903 000046AD 0000                <1> 	prog_end		dw 0		; Pointer to final byte of BASIC code
  4904                              <1> 
  4905 000046AF 0000                <1> 	load_point		dw 0
  4906                              <1> 
  4907 000046B1 00                  <1> 	token_type		db 0		; Type of last token read (eg NUMBER, VARIABLE)
  4908                              <1> 	token			equ 32768-1024-256
  4909                              <1> 
  4910                              <1> vars_loc:
  4911                              <1> ;	variables		times 26 dw 0	; Storage space for variables A to Z
  4912                              <1> 	variables		equ 32768-1024-384-52	; Storage space for variables A to Z
  4913                              <1> 
  4914                              <1> ;	for_variables		times 26 dw 0	; Storage for FOR loops
  4915                              <1> 	for_variables		equ 32768-1024-384-104	; Storage for FOR loops
  4916                              <1> ;	for_code_points		times 26 dw 0	; Storage for code positions where FOR loops start
  4917                              <1> 	for_code_points		equ 32768-1024-384-156	; Storage for code positions where FOR loops start
  4918                              <1> 	
  4919                              <1> ;	do_loop_store		times 10 dw 0	; Storage for DO loops
  4920                              <1> 	do_loop_store		equ 32768-1024-384-176	; Storage for DO loops
  4921 000046B2 00                  <1> 	loop_in			db 0		; Loop level
  4922                              <1> 
  4923 000046B3 01                  <1> 	last_if_true		db 1		; Checking for 'ELSE'
  4924                              <1> 
  4925 000046B4 00                  <1> 	ink_colour		db 0		; Text printing colour
  4926 000046B5 00                  <1> 	work_page		db 0		; Page to print to
  4927 000046B6 00                  <1> 	disp_page		db 0		; Page to display
  4928                              <1> 	
  4929 000046B7 414C45525400        <1> 	alert_cmd			db "ALERT", 0
  4930 000046BD 41534B46494C4500    <1> 	askfile_cmd			db "ASKFILE", 0
  4931 000046C5 425245414B00        <1> 	break_cmd			db "BREAK", 0
  4932 000046CB 43414C4C00          <1> 	call_cmd			db "CALL", 0
  4933 000046D0 4341534500          <1> 	case_cmd			db "CASE", 0
  4934 000046D5 434C5300            <1> 	cls_cmd				db "CLS", 0
  4935 000046D9 435552534F5200      <1> 	cursor_cmd			db "CURSOR", 0
  4936 000046E0 435552534348415200  <1> 	curschar_cmd		db "CURSCHAR", 0
  4937 000046E9 43555253434F4C00    <1> 	curscol_cmd			db "CURSCOL", 0
  4938 000046F1 43555253504F5300    <1> 	curspos_cmd			db "CURSPOS", 0
  4939 000046F9 44454C45544500      <1> 	delete_cmd			db "DELETE", 0
  4940 00004700 444F00              <1> 	do_cmd				db "DO", 0
  4941 00004703 454C534500          <1> 	else_cmd			db "ELSE", 0
  4942 00004708 454E4400            <1> 	end_cmd				db "END", 0
  4943 0000470C 46494C455300        <1> 	files_cmd			db "FILES", 0
  4944 00004712 464F5200            <1> 	for_cmd 			db "FOR", 0
  4945 00004716 474F53554200        <1> 	gosub_cmd			db "GOSUB", 0
  4946 0000471C 474F544F00          <1> 	goto_cmd			db "GOTO", 0
  4947 00004721 4745544B455900      <1> 	getkey_cmd			db "GETKEY", 0
  4948 00004728 494600              <1> 	if_cmd 				db "IF", 0
  4949 0000472B 494E434C55444500    <1> 	include_cmd			db "INCLUDE", 0
  4950 00004733 494E4B00            <1> 	ink_cmd				db "INK", 0
  4951 00004737 494E50555400        <1> 	input_cmd 			db "INPUT", 0
  4952 0000473D 4C454E00            <1> 	len_cmd				db "LEN", 0
  4953 00004741 4C495354424F5800    <1> 	listbox_cmd			db "LISTBOX", 0
  4954 00004749 4C4F414400          <1> 	load_cmd			db "LOAD", 0
  4955 0000474E 4C4F4F5000          <1> 	loop_cmd			db "LOOP", 0
  4956 00004753 4D4F564500          <1> 	move_cmd 			db "MOVE", 0
  4957 00004758 4E45585400          <1> 	next_cmd 			db "NEXT", 0
  4958 0000475D 4E554D42455200      <1> 	number_cmd			db "NUMBER", 0
  4959 00004764 5041474500          <1> 	page_cmd			db "PAGE", 0
  4960 00004769 504155534500        <1> 	pause_cmd 			db "PAUSE", 0
  4961 0000476F 5045454B00          <1> 	peek_cmd			db "PEEK", 0
  4962 00004774 5045454B494E5400    <1> 	peekint_cmd			db "PEEKINT", 0
  4963 0000477C 504F4B4500          <1> 	poke_cmd			db "POKE", 0
  4964 00004781 504F4B45494E5400    <1> 	pokeint_cmd			db "POKEINT", 0
  4965 00004789 504F525400          <1> 	port_cmd			db "PORT", 0
  4966 0000478E 5052494E5400        <1> 	print_cmd 			db "PRINT", 0
  4967 00004794 52414E4400          <1> 	rand_cmd			db "RAND", 0
  4968 00004799 5245414400          <1> 	read_cmd			db "READ", 0
  4969 0000479E 52454D00            <1> 	rem_cmd				db "REM", 0
  4970 000047A2 52454E414D4500      <1> 	rename_cmd			db "RENAME", 0
  4971 000047A9 52455455524E00      <1> 	return_cmd			db "RETURN", 0
  4972 000047B0 5341564500          <1> 	save_cmd			db "SAVE", 0
  4973 000047B5 53455249414C00      <1> 	serial_cmd			db "SERIAL", 0
  4974 000047BC 53495A4500          <1> 	size_cmd			db "SIZE", 0
  4975 000047C1 534F554E4400        <1> 	sound_cmd 			db "SOUND", 0
  4976 000047C7 535452494E4700      <1> 	string_cmd			db "STRING", 0
  4977 000047CE 574149544B455900    <1> 	waitkey_cmd			db "WAITKEY", 0
  4978                              <1> 
  4979 000047D6 414E4400            <1> 	and_keyword			db "AND", 0
  4980 000047DA 5448454E00          <1> 	then_keyword		db "THEN", 0
  4981 000047DF 43485200            <1> 	chr_keyword			db "CHR", 0
  4982 000047E3 48455800            <1> 	hex_keyword			db "HEX", 0
  4983                              <1> 	
  4984 000047E7 4C4F57455200        <1> 	lower_keyword		db "LOWER", 0
  4985 000047ED 555050455200        <1> 	upper_keyword		db "UPPER", 0
  4986                              <1> 
  4987 000047F3 494E4B00            <1> 	ink_keyword			db "INK", 0
  4988 000047F7 50524F475354415254- <1> 	progstart_keyword	db "PROGSTART", 0
  4988 00004800 00                  <1>
  4989 00004801 52414D535441525400  <1> 	ramstart_keyword	db "RAMSTART", 0
  4990 0000480A 54494D455200        <1> 	timer_keyword		db "TIMER", 0
  4991 00004810 5641524941424C4553- <1> 	variables_keyword	db "VARIABLES", 0
  4991 00004819 00                  <1>
  4992 0000481A 56455253494F4E00    <1> 	version_keyword		db "VERSION", 0
  4993                              <1> 
  4994 00004822 00                  <1> 	gosub_depth		db 0
  4995                              <1> 	gosub_points		equ 32768-1024-384-196	; Points in code to RETURN to
  4996                              <1> 
  4997                              <1> 	string_vars		equ 32768-1024
  4998                              <1> 
  4999                              <1> ; ------------------------------------------------------------------
  5000                              <1> 
   823                                  	%INCLUDE "features/int.asm"
   824                              <1> ; -----------------------------------------------------------------
   825                              <1> ; os_modify_int_handler -- Change location of interrupt handler
   826                              <1> ; IN: CL = int number, DI:SI = handler location
   827                              <1> 
   828                              <1> os_modify_int_handler:
   829 00004823 60                  <1> 	pusha
   830                              <1> 
   831 00004824 FA                  <1> 	cli
   832                              <1> 
   833 00004825 06                  <1> 	push es
   834                              <1> 	
   835 00004826 8E06[9405]          <1> 	mov es, [driversgmt]
   836                              <1> 	
   837 0000482A 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   838                              <1> 
   839 0000482D C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   840                              <1> 	
   841 00004830 268937              <1> 	mov [es:bx], si		; First store offset
   842                              <1> 
   843 00004833 83C302              <1> 	add bx, 2
   844                              <1> 	
   845 00004836 26893F              <1> 	mov [es:bx], di		; Then segment of our handler
   846                              <1> 
   847 00004839 07                  <1> 	pop es
   848                              <1> 	
   849 0000483A FB                  <1> 	sti
   850                              <1> 
   851 0000483B 61                  <1> 	popa
   852 0000483C C3                  <1> 	ret
   853                              <1> 
   854                              <1> ; -----------------------------------------------------------------
   855                              <1> ; os_get_int_handler -- Change location of interrupt handler
   856                              <1> ; IN: CL = int number; OUT: DI:SI = handler location
   857                              <1> 
   858                              <1> os_get_int_handler:
   859 0000483D 60                  <1> 	pusha
   860                              <1> 
   861 0000483E 1E                  <1> 	push ds
   862                              <1> 	
   863 0000483F 8E1E[9405]          <1> 	mov ds, [driversgmt]
   864                              <1> 	
   865 00004843 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   866                              <1> 
   867 00004846 C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   868                              <1> 	
   869 00004849 3E8B37              <1> 	mov si, [ds:bx]		; First store offset
   870 0000484C 83C302              <1> 	add bx, 2
   871                              <1> 
   872 0000484F 3E8B3F              <1> 	mov di, [ds:bx]		; Then segment of our handler
   873                              <1> 
   874 00004852 1F                  <1> 	pop ds
   875                              <1> 
   876 00004853 8936[6548]          <1> 	mov [.tmp_word], si
   877 00004857 893E[6748]          <1> 	mov [.tmp_sgmt], di
   878 0000485B 61                  <1> 	popa
   879 0000485C 8B36[6548]          <1> 	mov si, [.tmp_word]
   880 00004860 8B3E[6748]          <1> 	mov di, [.tmp_sgmt]
   881 00004864 C3                  <1> 	ret
   882                              <1> 
   883 00004865 0000                <1> 	.tmp_word	dw 0
   884 00004867 0000                <1> 	.tmp_sgmt	dw 0
   885                              <1> 	
   886                              <1> ; -----------------------------------------------------------------
   887                              <1> ; os_attach_timer_interrupt -- Attach a timer interrupt to an application and sets the timer speed
   888                              <1> ; Formula: speed = (105000000 / 88) / frequency
   889                              <1> ; IN: SI = handler location, CX = speed
   890                              <1> 
   891                              <1> os_attach_app_timer:
   892 00004869 60                  <1> 	pusha
   893 0000486A 8936[7249]          <1> 	mov [timer_application_offset], si
   894 0000486E C606[7149]01        <1> 	mov byte [timer_application_attached], 1
   895                              <1> 	
   896 00004873 E81A00              <1> 	call os_set_timer_speed
   897 00004876 61                  <1> 	popa
   898 00004877 C3                  <1> 	ret
   899                              <1> 	
   900                              <1> ; -----------------------------------------------------------------
   901                              <1> ; os_return_timer_interrupt -- Returns the timer interrupt back to the system and resets the timer speed
   902                              <1> ; IN: nothing
   903                              <1> 
   904                              <1> os_return_app_timer:
   905 00004878 60                  <1> 	pusha
   906 00004879 C606[7149]00        <1> 	mov byte [timer_application_attached], 0
   907                              <1> 	
   908 0000487E B90000              <1> 	mov cx, 0
   909 00004881 E80C00              <1> 	call os_set_timer_speed
   910                              <1> 	
   911 00004884 B11C                <1> 	mov cl, 1Ch					; RTC handler
   912 00004886 BE[3949]            <1> 	mov si, os_compat_int1C
   913 00004889 8CCF                <1> 	mov di, cs
   914 0000488B E895FF              <1> 	call os_modify_int_handler
   915 0000488E 61                  <1> 	popa
   916 0000488F C3                  <1> 	ret
   917                              <1> 	
   918                              <1> ; -----------------------------------------------------------------
   919                              <1> ; os_set_timer_speed -- Sets the timer's trigger speed.
   920                              <1> ; Formula: speed = (105000000 / 88) / frequency
   921                              <1> ; IN: CX = speed
   922                              <1> 
   923                              <1> os_set_timer_speed:
   924 00004890 60                  <1> 	pusha
   925                              <1> 	
   926 00004891 890E[7449]          <1> 	mov [current_timer_speed], cx
   927                              <1> 	
   928 00004895 B036                <1> 	mov al, 00110110b	; Timer 0, square wave
   929 00004897 E643                <1> 	out 43h, al
   930 00004899 88C8                <1> 	mov al, cl
   931 0000489B E640                <1> 	out 40h, al
   932 0000489D 88E8                <1> 	mov al, ch
   933 0000489F E640                <1> 	out 40h, al
   934                              <1> 	
   935 000048A1 61                  <1> 	popa
   936 000048A2 C3                  <1> 	ret
   937                              <1> 	
   938                              <1> ; -----------------------------------------------------------------
   939                              <1> ; Interrupt call parsers
   940                              <1> 
   941                              <1> ; Division by 0 error handler
   942                              <1> os_compat_int00:
   943 000048A3 B8[A948]            <1> 	mov ax, .msg
   944 000048A6 E9B4CD              <1> 	jmp os_fatal_error
   945                              <1> 
   946 000048A9 4350553A2044697669- <1> 	.msg db 'CPU: Division by zero error', 0
   946 000048B2 73696F6E206279207A- <1>
   946 000048BB 65726F206572726F72- <1>
   946 000048C4 00                  <1>
   947                              <1> 
   948                              <1> os_compat_int05:
   949 000048C5 B8[CB48]            <1> 	mov ax, .msg
   950 000048C8 E992CD              <1> 	jmp os_fatal_error
   951                              <1> 
   952 000048CB 557365722074726967- <1> 	.msg db 'User triggered crash', 0
   952 000048D4 676572656420637261- <1>
   952 000048DD 736800              <1>
   953                              <1> 
   954                              <1> os_compat_int0C:
   955 000048E0 FA                  <1> 	cli
   956 000048E1 BCFEFF              <1> 	mov sp, 0FFFEh
   957 000048E4 FB                  <1> 	sti
   958                              <1> 	
   959 000048E5 B8[EB48]            <1> 	mov ax, .msg
   960 000048E8 E972CD              <1> 	jmp os_fatal_error
   961                              <1> 	
   962 000048EB 537461636B206F7665- <1> 	.msg db 'Stack overflow', 0
   962 000048F4 72666C6F7700        <1>
   963                              <1> 	
   964                              <1> ; Invalid opcode handler
   965                              <1> os_compat_int06:
   966 000048FA B8[0049]            <1> 	mov ax, .msg
   967 000048FD E95DCD              <1> 	jmp os_fatal_error
   968                              <1> 
   969 00004900 4350553A20496E7661- <1> 	.msg db 'CPU: Invalid opcode', 0
   969 00004909 6C6964206F70636F64- <1>
   969 00004912 6500                <1>
   970                              <1> 
   971                              <1> ; Processor extension error handler
   972                              <1> os_compat_int07:
   973 00004914 B8[1A49]            <1> 	mov ax, .msg
   974 00004917 E943CD              <1> 	jmp os_fatal_error
   975                              <1> 
   976 0000491A 4350553A2050726F63- <1> 	.msg db 'CPU: Processor extension error', 0
   976 00004923 6573736F7220657874- <1>
   976 0000492C 656E73696F6E206572- <1>
   976 00004935 726F7200            <1>
   977                              <1> 
   978                              <1> ; System timer handler (8253/8254)
   979                              <1> os_compat_int1C:
   980 00004939 FA                  <1> 	cli
   981 0000493A 6660                <1> 	pushad
   982 0000493C 1E                  <1> 	push ds
   983 0000493D 06                  <1> 	push es
   984                              <1> 	
   985 0000493E 8CC8                <1> 	mov ax, cs
   986 00004940 8ED8                <1> 	mov ds, ax
   987 00004942 8EC0                <1> 	mov es, ax
   988                              <1> 	
   989 00004944 803E820001          <1> 	cmp byte [0082h], 1
   990 00004949 740E                <1> 	je .no_update
   991                              <1> 	
   992 0000494B 833E[7649]00        <1> 	cmp word [screensaver_timer], 0
   993 00004950 7404                <1> 	je .no_update_screensaver
   994                              <1> 	
   995 00004952 FF0E[7649]          <1> 	dec word [screensaver_timer]
   996                              <1> 	
   997                              <1> .no_update_screensaver:	
   998 00004956 E8AECC              <1> 	call os_update_clock
   999                              <1> 
  1000                              <1> .no_update:
  1001 00004959 2E803E[7149]01      <1> 	cmp byte [cs:timer_application_attached], 1
  1002 0000495F 7406                <1> 	je .app_routine
  1003                              <1> 
  1004 00004961 07                  <1> 	pop es
  1005 00004962 1F                  <1> 	pop ds
  1006 00004963 6661                <1> 	popad
  1007 00004965 FB                  <1> 	sti
  1008 00004966 CF                  <1> 	iret
  1009                              <1> 
  1010                              <1> .app_routine:
  1011 00004967 2EFF16[7249]        <1> 	call [cs:timer_application_offset]
  1012                              <1> 	
  1013 0000496C 07                  <1> 	pop es
  1014 0000496D 1F                  <1> 	pop ds	
  1015 0000496E 6661                <1> 	popad
  1016 00004970 CF                  <1> 	iret
  1017                              <1> 
  1018 00004971 00                  <1> 	timer_application_attached	db 0
  1019 00004972 0000                <1> 	timer_application_offset	dw 0
  1020                              <1> 	
  1021 00004974 0000                <1> 	current_timer_speed			dw 0
  1022                              <1> 	
  1023 00004976 0000                <1> 	screensaver_timer			dw 0
   824                                  	%INCLUDE "features/graphics.asm"
   825                              <1> ; ==================================================================
   826                              <1> ; MichalOS Graphics functions
   827                              <1> ; ==================================================================
   828                              <1> 
   829                              <1> ; Puts a pixel on the screen.
   830                              <1> ; IN: AL = Color; BH = Page; CX = X position; DX = Y position
   831                              <1> ; OUT: nothing
   832                              <1> os_put_pixel:
   833 00004978 60                  <1> 	pusha
   834 00004979 B40C                <1> 	mov ah, 0Ch
   835 0000497B CD10                <1> 	int 10h
   836 0000497D 61                  <1> 	popa
   837 0000497E C3                  <1> 	ret
   838                              <1> 	
   839                              <1> ; Gets a pixel from the screen.
   840                              <1> ; IN: BH = Page; CX = X position; DX = Y position
   841                              <1> ; OUT: AL = Color
   842                              <1> os_get_pixel:
   843 0000497F 60                  <1> 	pusha
   844 00004980 B40D                <1> 	mov ah, 0Dh
   845 00004982 CD10                <1> 	int 10h
   846 00004984 A2[8C49]            <1> 	mov [.tmp_byte], al
   847 00004987 61                  <1> 	popa
   848 00004988 A0[8C49]            <1> 	mov al, [.tmp_byte]
   849 0000498B C3                  <1> 	ret
   850                              <1> 	
   851 0000498C 00                  <1> 	.tmp_byte	db 0
   852                              <1> 	
   853                              <1> ; ==================================================================
   854                              <1> ; TachyonOS -- The TachyonOS Operating System kernel
   855                              <1> ; Copyright (C) 2013 TachyonOS Developers -- see doc/LICENCE.TXT
   856                              <1> ;
   857                              <1> ; GRAPHICS ROUTINES
   858                              <1> ; ==================================================================
   859                              <1> 	
   860                              <1> os_set_pixel:
   861 0000498D 60                  <1> 	pusha
   862 0000498E 89CA                <1> 	mov dx, cx
   863 00004990 89C1                <1> 	mov cx, ax
   864 00004992 88D8                <1> 	mov al, bl
   865 00004994 B700                <1> 	mov bh, 0
   866 00004996 E8DFFF              <1> 	call os_put_pixel
   867 00004999 61                  <1> 	popa
   868 0000499A C3                  <1> 	ret
   869                              <1> 	
   870                              <1> ; Implementation of Bresenham's line algorithm. Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   871                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   872                              <1> ; OUT: None, registers preserved
   873                              <1> os_draw_line:
   874 0000499B 60                  <1> 	pusha				; Save parameters
   875                              <1> 	
   876 0000499C 31C0                <1> 	xor ax, ax			; Clear variables
   877 0000499E BF[014B]            <1> 	mov di, .x1
   878 000049A1 B90B00              <1> 	mov cx, 11
   879 000049A4 F3AB                <1> 	rep stosw
   880                              <1> 	
   881 000049A6 61                  <1> 	popa				; Restore and save parameters
   882 000049A7 60                  <1> 	pusha
   883                              <1> 	
   884 000049A8 890E[014B]          <1> 	mov [.x1], cx			; Save points
   885 000049AC 890E[094B]          <1> 	mov [.x], cx
   886 000049B0 8916[034B]          <1> 	mov [.y1], dx
   887 000049B4 8916[0B4B]          <1> 	mov [.y], dx
   888 000049B8 8936[054B]          <1> 	mov [.x2], si
   889 000049BC 893E[074B]          <1> 	mov [.y2], di
   890                              <1> 	
   891 000049C0 881E[174B]          <1> 	mov [.colour], bl		; Save the colour
   892                              <1> 	
   893 000049C4 8B1E[054B]          <1> 	mov bx, [.x2]
   894 000049C8 A1[014B]            <1> 	mov ax, [.x1]
   895 000049CB 39C3                <1> 	cmp bx, ax
   896 000049CD 7C0E                <1> 	jl .x1gtx2
   897                              <1> 	
   898 000049CF 29C3                <1> 	sub bx, ax
   899 000049D1 891E[0D4B]          <1> 	mov [.dx], bx
   900 000049D5 B80100              <1> 	mov ax, 1
   901 000049D8 A3[114B]            <1> 	mov [.incx], ax
   902 000049DB EB0B                <1> 	jmp .test2
   903                              <1> 	
   904                              <1> .x1gtx2:
   905 000049DD 29D8                <1> 	sub ax, bx
   906 000049DF A3[0D4B]            <1> 	mov [.dx], ax
   907 000049E2 B8FFFF              <1> 	mov ax, -1
   908 000049E5 A3[114B]            <1> 	mov [.incx], ax
   909                              <1> 	
   910                              <1> .test2:
   911 000049E8 8B1E[074B]          <1> 	mov bx, [.y2]
   912 000049EC A1[034B]            <1> 	mov ax, [.y1]
   913 000049EF 39C3                <1> 	cmp bx, ax
   914 000049F1 7C0E                <1> 	jl .y1gty2
   915                              <1> 	
   916 000049F3 29C3                <1> 	sub bx, ax
   917 000049F5 891E[0F4B]          <1> 	mov [.dy], bx
   918 000049F9 B80100              <1> 	mov ax, 1
   919 000049FC A3[134B]            <1> 	mov [.incy], ax
   920 000049FF EB0B                <1> 	jmp .test3
   921                              <1> 	
   922                              <1> .y1gty2:
   923 00004A01 29D8                <1> 	sub ax, bx
   924 00004A03 A3[0F4B]            <1> 	mov [.dy], ax
   925 00004A06 B8FFFF              <1> 	mov ax, -1
   926 00004A09 A3[134B]            <1> 	mov [.incy], ax
   927                              <1> 	
   928                              <1> .test3:
   929 00004A0C 8B1E[0D4B]          <1> 	mov bx, [.dx]
   930 00004A10 A1[0F4B]            <1> 	mov ax, [.dy]
   931 00004A13 39C3                <1> 	cmp bx, ax
   932 00004A15 7C6E                <1> 	jl .dygtdx
   933                              <1> 	
   934 00004A17 A1[0F4B]            <1> 	mov ax, [.dy]
   935 00004A1A D1E0                <1> 	shl ax, 1
   936 00004A1C A3[0F4B]            <1> 	mov [.dy], ax
   937                              <1> 	
   938 00004A1F 8B1E[0D4B]          <1> 	mov bx, [.dx]
   939 00004A23 29D8                <1> 	sub ax, bx
   940 00004A25 A3[154B]            <1> 	mov [.balance], ax
   941                              <1> 	
   942 00004A28 D1E3                <1> 	shl bx, 1
   943 00004A2A 891E[0D4B]          <1> 	mov [.dx], bx
   944                              <1> 	
   945                              <1> .xloop:
   946 00004A2E A1[094B]            <1> 	mov ax, [.x]
   947 00004A31 8B1E[054B]          <1> 	mov bx, [.x2]
   948 00004A35 39D8                <1> 	cmp ax, bx
   949 00004A37 0F84B600            <1> 	je .done
   950                              <1> 	
   951 00004A3B A1[094B]            <1> 	mov ax, [.x]
   952 00004A3E 8B0E[0B4B]          <1> 	mov cx, [.y]
   953 00004A42 8A1E[174B]          <1> 	mov bl, [.colour]
   954 00004A46 E844FF              <1> 	call os_set_pixel
   955                              <1> 	
   956 00004A49 31F6                <1> 	xor si, si
   957 00004A4B 8B3E[154B]          <1> 	mov di, [.balance]
   958 00004A4F 39F7                <1> 	cmp di, si
   959 00004A51 7C18                <1> 	jl .xloop1
   960                              <1> 	
   961 00004A53 A1[0B4B]            <1> 	mov ax, [.y]
   962 00004A56 8B1E[134B]          <1> 	mov bx, [.incy]
   963 00004A5A 01D8                <1> 	add ax, bx
   964 00004A5C A3[0B4B]            <1> 	mov [.y], ax
   965                              <1> 	
   966 00004A5F A1[154B]            <1> 	mov ax, [.balance]
   967 00004A62 8B1E[0D4B]          <1> 	mov bx, [.dx]
   968 00004A66 29D8                <1> 	sub ax, bx
   969 00004A68 A3[154B]            <1> 	mov [.balance], ax
   970                              <1> 	
   971                              <1> .xloop1:
   972 00004A6B A1[154B]            <1> 	mov ax, [.balance]
   973 00004A6E 8B1E[0F4B]          <1> 	mov bx, [.dy]
   974 00004A72 01D8                <1> 	add ax, bx
   975 00004A74 A3[154B]            <1> 	mov [.balance], ax
   976                              <1> 	
   977 00004A77 A1[094B]            <1> 	mov ax, [.x]
   978 00004A7A 8B1E[114B]          <1> 	mov bx, [.incx]
   979 00004A7E 01D8                <1> 	add ax, bx
   980 00004A80 A3[094B]            <1> 	mov [.x], ax
   981                              <1> 	
   982 00004A83 EBA9                <1> 	jmp .xloop
   983                              <1> 	
   984                              <1> .dygtdx:
   985 00004A85 A1[0D4B]            <1> 	mov ax, [.dx]
   986 00004A88 D1E0                <1> 	shl ax, 1
   987 00004A8A A3[0D4B]            <1> 	mov [.dx], ax
   988                              <1> 	
   989 00004A8D 8B1E[0F4B]          <1> 	mov bx, [.dy]
   990 00004A91 29D8                <1> 	sub ax, bx
   991 00004A93 A3[154B]            <1> 	mov [.balance], ax
   992                              <1> 	
   993 00004A96 D1E3                <1> 	shl bx, 1
   994 00004A98 891E[0F4B]          <1> 	mov [.dy], bx
   995                              <1> 	
   996                              <1> .yloop:
   997 00004A9C A1[0B4B]            <1> 	mov ax, [.y]
   998 00004A9F 8B1E[074B]          <1> 	mov bx, [.y2]
   999 00004AA3 39D8                <1> 	cmp ax, bx
  1000 00004AA5 744A                <1> 	je .done
  1001                              <1> 	
  1002 00004AA7 A1[094B]            <1> 	mov ax, [.x]
  1003 00004AAA 8B0E[0B4B]          <1> 	mov cx, [.y]
  1004 00004AAE 8A1E[174B]          <1> 	mov bl, [.colour]
  1005 00004AB2 E8D8FE              <1> 	call os_set_pixel
  1006                              <1> 	
  1007 00004AB5 31F6                <1> 	xor si, si
  1008 00004AB7 8B3E[154B]          <1> 	mov di, [.balance]
  1009 00004ABB 39F7                <1> 	cmp di, si
  1010 00004ABD 7C18                <1> 	jl .yloop1
  1011                              <1> 	
  1012 00004ABF A1[094B]            <1> 	mov ax, [.x]
  1013 00004AC2 8B1E[114B]          <1> 	mov bx, [.incx]
  1014 00004AC6 01D8                <1> 	add ax, bx
  1015 00004AC8 A3[094B]            <1> 	mov [.x], ax
  1016                              <1> 	
  1017 00004ACB A1[154B]            <1> 	mov ax, [.balance]
  1018 00004ACE 8B1E[0F4B]          <1> 	mov bx, [.dy]
  1019 00004AD2 29D8                <1> 	sub ax, bx
  1020 00004AD4 A3[154B]            <1> 	mov [.balance], ax
  1021                              <1> 	
  1022                              <1> .yloop1:
  1023 00004AD7 A1[154B]            <1> 	mov ax, [.balance]
  1024 00004ADA 8B1E[0D4B]          <1> 	mov bx, [.dx]
  1025 00004ADE 01D8                <1> 	add ax, bx
  1026 00004AE0 A3[154B]            <1> 	mov [.balance], ax
  1027                              <1> 	
  1028 00004AE3 A1[0B4B]            <1> 	mov ax, [.y]
  1029 00004AE6 8B1E[134B]          <1> 	mov bx, [.incy]
  1030 00004AEA 01D8                <1> 	add ax, bx
  1031 00004AEC A3[0B4B]            <1> 	mov [.y], ax
  1032                              <1> 	
  1033 00004AEF EBAB                <1> 	jmp .yloop
  1034                              <1> 	
  1035                              <1> .done:
  1036 00004AF1 A1[094B]            <1> 	mov ax, [.x]
  1037 00004AF4 8B0E[0B4B]          <1> 	mov cx, [.y]
  1038 00004AF8 8A1E[174B]          <1> 	mov bl, [.colour]
  1039 00004AFC E88EFE              <1> 	call os_set_pixel
  1040                              <1> 	
  1041 00004AFF 61                  <1> 	popa
  1042 00004B00 C3                  <1> 	ret
  1043                              <1> 	
  1044                              <1> 	
  1045 00004B01 0000                <1> 	.x1 dw 0
  1046 00004B03 0000                <1> 	.y1 dw 0
  1047 00004B05 0000                <1> 	.x2 dw 0
  1048 00004B07 0000                <1> 	.y2 dw 0
  1049                              <1> 	
  1050 00004B09 0000                <1> 	.x dw 0
  1051 00004B0B 0000                <1> 	.y dw 0
  1052 00004B0D 0000                <1> 	.dx dw 0
  1053 00004B0F 0000                <1> 	.dy dw 0
  1054 00004B11 0000                <1> 	.incx dw 0
  1055 00004B13 0000                <1> 	.incy dw 0
  1056 00004B15 0000                <1> 	.balance dw 0
  1057 00004B17 00                  <1> 	.colour db 0
  1058 00004B18 00                  <1> 	.pad db 0
  1059                              <1> 	
  1060                              <1> ; Draw (straight) rectangle
  1061                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
  1062                              <1> ; OUT: None, registers preserved
  1063                              <1> os_draw_rectangle:
  1064 00004B19 60                  <1> 	pusha
  1065 00004B1A 9C                  <1> 	pushf
  1066                              <1> 	
  1067 00004B1B 890E[A54B]          <1> 	mov word [.x1], cx
  1068 00004B1F 8916[A94B]          <1> 	mov word [.y1], dx
  1069 00004B23 8936[A74B]          <1> 	mov word [.x2], si
  1070 00004B27 893E[AB4B]          <1> 	mov word [.y2], di
  1071                              <1> 	
  1072 00004B2B 9D                  <1> 	popf
  1073 00004B2C 7302                <1> 	jnc .draw_line
  1074                              <1> 
  1075 00004B2E EB4E                <1> 	jmp .fill_shape
  1076                              <1> 	
  1077                              <1> .draw_line:
  1078                              <1> 	; top line
  1079 00004B30 8B0E[A54B]          <1> 	mov cx, [.x1]
  1080 00004B34 8B16[A94B]          <1> 	mov dx, [.y1]
  1081 00004B38 8B36[A74B]          <1> 	mov si, [.x2]
  1082 00004B3C 8B3E[A94B]          <1> 	mov di, [.y1]
  1083 00004B40 E858FE              <1> 	call os_draw_line
  1084                              <1> 	
  1085                              <1> 	; left line
  1086 00004B43 8B0E[A54B]          <1> 	mov cx, [.x1]
  1087 00004B47 8B16[A94B]          <1> 	mov dx, [.y1]
  1088 00004B4B 8B36[A54B]          <1> 	mov si, [.x1]
  1089 00004B4F 8B3E[AB4B]          <1> 	mov di, [.y2]
  1090 00004B53 E845FE              <1> 	call os_draw_line
  1091                              <1> 	
  1092                              <1> 	; right line
  1093 00004B56 8B0E[A74B]          <1> 	mov cx, [.x2]
  1094 00004B5A 8B16[A94B]          <1> 	mov dx, [.y1]
  1095 00004B5E 8B36[A74B]          <1> 	mov si, [.x2]
  1096 00004B62 8B3E[AB4B]          <1> 	mov di, [.y2]
  1097 00004B66 E832FE              <1> 	call os_draw_line
  1098                              <1> 
  1099                              <1> 	; bottom line
  1100 00004B69 8B0E[A54B]          <1> 	mov cx, [.x1]
  1101 00004B6D 8B16[AB4B]          <1> 	mov dx, [.y2]
  1102 00004B71 8B36[A74B]          <1> 	mov si, [.x2]
  1103 00004B75 8B3E[AB4B]          <1> 	mov di, [.y2]
  1104 00004B79 E81FFE              <1> 	call os_draw_line
  1105                              <1> 		
  1106 00004B7C EB25                <1> 	jmp .finished_fill
  1107                              <1> 		
  1108                              <1> .fill_shape:
  1109 00004B7E 88D8                <1> 	mov al, bl
  1110                              <1> 
  1111 00004B80 39F1                <1> 	cmp cx, si		; Is X1 smaller than X2?
  1112 00004B82 7C02                <1> 	jl .x_good
  1113 00004B84 87CE                <1> 	xchg cx, si		; If not, exchange them
  1114                              <1> .x_good:
  1115 00004B86 39FA                <1> 	cmp dx, di		; Is Y1 smaller than Y2?
  1116 00004B88 7C02                <1> 	jl .y_good
  1117 00004B8A 87D7                <1> 	xchg dx, di		; If not, exchange them
  1118                              <1> .y_good:
  1119 00004B8C 890E[A54B]          <1> 	mov [.x1], cx
  1120 00004B90 B700                <1> 	mov bh, 0
  1121                              <1> .x_loop:
  1122 00004B92 E8E3FD              <1> 	call os_put_pixel
  1123 00004B95 41                  <1> 	inc cx
  1124                              <1> 	
  1125 00004B96 39F1                <1> 	cmp cx, si
  1126 00004B98 7CF8                <1> 	jl .x_loop
  1127                              <1> 	
  1128 00004B9A 42                  <1> 	inc dx
  1129 00004B9B 8B0E[A54B]          <1> 	mov cx, [.x1]
  1130                              <1> 	
  1131 00004B9F 39FA                <1> 	cmp dx, di
  1132 00004BA1 7CEF                <1> 	jl .x_loop
  1133                              <1> 		
  1134                              <1> .finished_fill:
  1135 00004BA3 61                  <1> 	popa
  1136 00004BA4 C3                  <1> 	ret
  1137                              <1> 	
  1138 00004BA5 0000                <1> 	.x1				dw 0
  1139 00004BA7 0000                <1> 	.x2				dw 0
  1140 00004BA9 0000                <1> 	.y1				dw 0
  1141 00004BAB 0000                <1> 	.y2				dw 0
  1142                              <1> 
  1143                              <1> ; Draw freeform shape
  1144                              <1> ; IN: BH = number of points, BL = colour, SI = location of shape points data
  1145                              <1> ; OUT: None, registers preserved
  1146                              <1> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
  1147                              <1> os_draw_polygon:
  1148 00004BAD 60                  <1> 	pusha
  1149                              <1> 	
  1150 00004BAE FECF                <1> 	dec bh
  1151 00004BB0 883E[1B4C]          <1> 	mov byte [.points], bh
  1152                              <1> 	
  1153 00004BB4 648B04              <1> 	mov word ax, [fs:si]
  1154 00004BB7 83C602              <1> 	add si, 2
  1155 00004BBA A3[134C]            <1> 	mov word [.xi], ax
  1156 00004BBD A3[174C]            <1> 	mov word [.xl], ax
  1157                              <1> 	
  1158 00004BC0 648B04              <1> 	mov word ax, [fs:si]
  1159 00004BC3 83C602              <1> 	add si, 2
  1160 00004BC6 A3[154C]            <1> 	mov word [.yi], ax
  1161 00004BC9 A3[194C]            <1> 	mov word [.yl], ax
  1162                              <1> 	
  1163                              <1> 	.draw_points:
  1164 00004BCC 8B0E[174C]          <1> 		mov cx, [.xl]
  1165 00004BD0 8B16[194C]          <1> 		mov dx, [.yl]
  1166                              <1> 		
  1167 00004BD4 648B04              <1> 		mov word ax, [fs:si]
  1168 00004BD7 83C602              <1> 		add si, 2
  1169 00004BDA A3[174C]            <1> 		mov word [.xl], ax
  1170                              <1> 		
  1171 00004BDD 648B04              <1> 		mov word ax, [fs:si]
  1172 00004BE0 83C602              <1> 		add si, 2
  1173 00004BE3 A3[194C]            <1> 		mov word [.yl], ax
  1174                              <1> 		
  1175 00004BE6 56                  <1> 		push si
  1176                              <1> 		
  1177 00004BE7 8B36[174C]          <1> 		mov si, [.xl]
  1178 00004BEB 8B3E[194C]          <1> 		mov di, [.yl]
  1179                              <1> 		
  1180 00004BEF E8A9FD              <1> 		call os_draw_line
  1181                              <1> 		
  1182 00004BF2 5E                  <1> 		pop si
  1183                              <1> 		
  1184 00004BF3 FE0E[1B4C]          <1> 		dec byte [.points]
  1185 00004BF7 803E[1B4C]00        <1> 		cmp byte [.points], 0
  1186 00004BFC 75CE                <1> 		jne .draw_points
  1187                              <1> 		
  1188 00004BFE 8B0E[174C]          <1> 	mov cx, [.xl]
  1189 00004C02 8B16[194C]          <1> 	mov dx, [.yl]
  1190 00004C06 8B36[134C]          <1> 	mov si, [.xi]
  1191 00004C0A 8B3E[154C]          <1> 	mov di, [.yi]
  1192 00004C0E E88AFD              <1> 	call os_draw_line
  1193                              <1> 	
  1194 00004C11 61                  <1> 	popa
  1195 00004C12 C3                  <1> 	ret
  1196                              <1> 	
  1197 00004C13 0000                <1> 	.xi				dw 0
  1198 00004C15 0000                <1> 	.yi				dw 0
  1199 00004C17 0000                <1> 	.xl				dw 0
  1200 00004C19 0000                <1> 	.yl				dw 0
  1201 00004C1B 00                  <1> 	.points				db 0
  1202                              <1> 	
  1203                              <1> 
  1204                              <1> ; Clear the screen by setting all pixels to a single colour
  1205                              <1> ; BL = colour to set
  1206                              <1> os_clear_graphics:
  1207 00004C1C 60                  <1> 	pusha
  1208 00004C1D 06                  <1> 	push es
  1209                              <1> 	
  1210 00004C1E B800A0              <1> 	mov ax, 0xA000
  1211 00004C21 8EC0                <1> 	mov es, ax
  1212                              <1> 
  1213 00004C23 88D8                <1> 	mov al, bl
  1214 00004C25 BF0000              <1> 	mov di, 0
  1215 00004C28 B900FA              <1> 	mov cx, 64000
  1216 00004C2B F3AA                <1> 	rep stosb
  1217                              <1> 
  1218 00004C2D 07                  <1> 	pop es
  1219 00004C2E 61                  <1> 	popa
  1220 00004C2F C3                  <1> 	ret
  1221                              <1> 	
  1222                              <1> 	
  1223                              <1> ; ----------------------------------------
  1224                              <1> ; os_draw_circle -- draw a circular shape
  1225                              <1> ; IN: AL = colour, BX = radius, CX = middle X, DX = middle y
  1226                              <1> 
  1227                              <1> os_draw_circle:
  1228 00004C30 60                  <1> 	pusha
  1229 00004C31 A2[F24C]            <1> 	mov [.colour], al
  1230 00004C34 891E[F74C]          <1> 	mov [.radius], bx
  1231 00004C38 890E[F34C]          <1> 	mov [.x0], cx
  1232 00004C3C 8916[F54C]          <1> 	mov [.y0], dx
  1233                              <1> 
  1234 00004C40 891E[F94C]          <1> 	mov [.x], bx
  1235 00004C44 C706[FB4C]0000      <1> 	mov word [.y], 0
  1236 00004C4A B80100              <1> 	mov ax, 1
  1237 00004C4D D1E3                <1> 	shl bx, 1
  1238 00004C4F 29D8                <1> 	sub ax, bx
  1239 00004C51 A3[FD4C]            <1> 	mov [.xChange], ax
  1240 00004C54 C706[FF4C]0000      <1> 	mov word [.yChange], 0
  1241 00004C5A C706[014D]0000      <1> 	mov word [.radiusError], 0
  1242                              <1> 
  1243                              <1> .next_point:
  1244 00004C60 8B0E[F94C]          <1> 	mov cx, [.x]
  1245 00004C64 8B16[FB4C]          <1> 	mov dx, [.y]
  1246 00004C68 39D1                <1> 	cmp cx, dx
  1247 00004C6A 0F8C8200            <1> 	jl .finish
  1248                              <1> 
  1249                              <1> 	;ax bx - function points
  1250                              <1> 	;cx = x 
  1251                              <1> 	;dx = y
  1252                              <1> 	;si = -x
  1253                              <1> 	;di = -y
  1254                              <1> 
  1255 00004C6E 89CE                <1> 	mov si, cx
  1256 00004C70 83F6FF              <1> 	xor si, 0xFFFF
  1257 00004C73 46                  <1> 	inc si
  1258 00004C74 89D7                <1> 	mov di, dx
  1259 00004C76 83F7FF              <1> 	xor di, 0xFFFF
  1260 00004C79 47                  <1> 	inc di
  1261                              <1> 
  1262                              <1> 	; (x + x0, y + y0)
  1263 00004C7A 89C8                <1> 	mov ax, cx
  1264 00004C7C 89D3                <1> 	mov bx, dx
  1265 00004C7E E85B00              <1> 	call .draw_point
  1266                              <1> 
  1267                              <1> 	; (y + x0, x + y0)
  1268 00004C81 93                  <1> 	xchg ax, bx
  1269 00004C82 E85700              <1> 	call .draw_point
  1270                              <1> 
  1271                              <1> 	; (-x + x0, y + y0)
  1272 00004C85 89F0                <1> 	mov ax, si
  1273 00004C87 89D3                <1> 	mov bx, dx
  1274 00004C89 E85000              <1> 	call .draw_point
  1275                              <1> 
  1276                              <1> 	; (-y + x0, x + y0)
  1277 00004C8C 89F8                <1> 	mov ax, di
  1278 00004C8E 89CB                <1> 	mov bx, cx
  1279 00004C90 E84900              <1> 	call .draw_point
  1280                              <1> 
  1281                              <1> 	; (-x + x0, -y + y0)
  1282 00004C93 89F0                <1> 	mov ax, si
  1283 00004C95 89FB                <1> 	mov bx, di
  1284 00004C97 E84200              <1> 	call .draw_point
  1285                              <1> 
  1286                              <1> 	; (-y + x0, -x + y0)
  1287 00004C9A 93                  <1> 	xchg ax, bx
  1288 00004C9B E83E00              <1> 	call .draw_point
  1289                              <1> 
  1290                              <1> 	; (x + x0, -y + y0)
  1291 00004C9E 89C8                <1> 	mov ax, cx
  1292 00004CA0 89FB                <1> 	mov bx, di
  1293 00004CA2 E83700              <1> 	call .draw_point
  1294                              <1> 
  1295                              <1> 	; (y + x0, -x + y0)
  1296 00004CA5 89D0                <1> 	mov ax, dx
  1297 00004CA7 89F3                <1> 	mov bx, si
  1298 00004CA9 E83000              <1> 	call .draw_point
  1299                              <1> 	
  1300 00004CAC FF06[FB4C]          <1> 	inc word [.y]
  1301 00004CB0 A1[FF4C]            <1> 	mov ax, [.yChange]
  1302 00004CB3 0106[014D]          <1> 	add [.radiusError], ax
  1303 00004CB7 8306[FF4C]02        <1> 	add word [.yChange], 2
  1304                              <1> 	
  1305 00004CBC A1[014D]            <1> 	mov ax, [.radiusError]
  1306 00004CBF D1E0                <1> 	shl ax, 1
  1307 00004CC1 0306[FD4C]          <1> 	add ax, [.xChange]
  1308                              <1> 	
  1309 00004CC5 83F800              <1> 	cmp ax, 0
  1310 00004CC8 7E96                <1> 	jle .next_point
  1311                              <1> 	
  1312 00004CCA FF0E[F94C]          <1> 	dec word [.x]
  1313 00004CCE A1[FD4C]            <1> 	mov ax, [.xChange]
  1314 00004CD1 0106[014D]          <1> 	add [.radiusError], ax
  1315 00004CD5 8306[FD4C]02        <1> 	add word [.xChange], 2
  1316                              <1> 
  1317 00004CDA EB84                <1> 	jmp .next_point
  1318                              <1> 
  1319                              <1> .draw_point:
  1320                              <1> 	; AX = X, BX = Y
  1321 00004CDC 60                  <1> 	pusha
  1322 00004CDD 0306[F34C]          <1> 	add ax, [.x0]
  1323 00004CE1 031E[F54C]          <1> 	add bx, [.y0]
  1324 00004CE5 89D9                <1> 	mov cx, bx
  1325 00004CE7 8A1E[F24C]          <1> 	mov bl, [.colour]
  1326 00004CEB E89FFC              <1> 	call os_set_pixel
  1327 00004CEE 61                  <1> 	popa
  1328 00004CEF C3                  <1> 	ret
  1329                              <1> 	
  1330                              <1> .finish:
  1331 00004CF0 61                  <1> 	popa
  1332 00004CF1 C3                  <1> 	ret
  1333                              <1> 	
  1334                              <1> 
  1335                              <1> 
  1336 00004CF2 00                  <1> .colour				db 0
  1337 00004CF3 0000                <1> .x0					dw 0
  1338 00004CF5 0000                <1> .y0					dw 0
  1339 00004CF7 0000                <1> .radius				dw 0
  1340 00004CF9 0000                <1> .x					dw 0
  1341 00004CFB 0000                <1> .y					dw 0
  1342 00004CFD 0000                <1> .xChange			dw 0
  1343 00004CFF 0000                <1> .yChange			dw 0
  1344 00004D01 0000                <1> .radiusError		dw 0
   825                                  	%INCLUDE "features/name.asm"
   826                              <1> ; ==================================================================
   827                              <1> ; MichalOS Name
   828                              <1> ; ==================================================================
   829                              <1> 
   830 00004D03 4D696368616C4F5320- <1> 	osname	db 'MichalOS 3.0', 0
   830 00004D0C 332E3000            <1>
   826                                  	%INCLUDE "features/shutdown.asm"
   827                              <1> ; ------------------------------------------------------------------
   828                              <1> ; MichalOS Shutdown handler
   829                              <1> ; ------------------------------------------------------------------
   830                              <1> 
   831                              <1> os_shutdown:
   832 00004D10 C606820001          <1> 	mov byte [0082h], 1
   833 00004D15 E84FCC              <1> 	call os_hide_cursor
   834 00004D18 E8E000              <1> 	call .drawbackground
   835 00004D1B E87E00              <1> 	call .drawwindow
   836 00004D1E E81200              <1> 	call .selector
   837                              <1> 	
   838 00004D21 3C01                <1> 	cmp al, 1
   839 00004D23 0F841101            <1> 	je near .shutdown
   840                              <1> 	
   841 00004D27 3C02                <1> 	cmp al, 2
   842 00004D29 0F840601            <1> 	je near .reset
   843                              <1> 	
   844 00004D2D 3C03                <1> 	cmp al, 3
   845 00004D2F 0F8488B5            <1> 	je near checkformenu
   846                              <1> 	
   847                              <1> .selector:
   848 00004D33 BA1C0B              <1> 	mov dx, 11 * 256 + 28
   849 00004D36 E8EECB              <1> 	call os_move_cursor
   850                              <1> 
   851                              <1> .selectorloop:
   852 00004D39 E87000              <1> 	call .drawcontents
   853 00004D3C E83A00              <1> 	call .invert
   854                              <1> 	
   855 00004D3F E8F5C5              <1> 	call os_wait_for_key
   856                              <1> 	
   857 00004D42 80FC50              <1> 	cmp ah, 80
   858 00004D45 7417                <1> 	je .selectdown
   859                              <1> 	
   860 00004D47 80FC48              <1> 	cmp ah, 72
   861 00004D4A 741D                <1> 	je .selectup
   862                              <1> 	
   863 00004D4C 3C0D                <1> 	cmp al, 13
   864 00004D4E 7424                <1> 	je .select
   865                              <1> 	
   866 00004D50 3C1B                <1> 	cmp al, 27
   867 00004D52 7402                <1> 	je .return
   868                              <1> 	
   869 00004D54 EBE3                <1> 	jmp .selectorloop
   870                              <1> 
   871                              <1> .return:
   872 00004D56 B003                <1> 	mov al, 3
   873 00004D58 C606820001          <1> 	mov byte [0082h], 1
   874 00004D5D C3                  <1> 	ret
   875                              <1> 
   876                              <1> .selectdown:
   877 00004D5E 80FE0D              <1> 	cmp dh, 13
   878 00004D61 0F84D4FF            <1> 	je near .selectorloop
   879 00004D65 FEC6                <1> 	inc dh
   880 00004D67 EBD0                <1> 	jmp .selectorloop
   881                              <1> 
   882                              <1> .selectup:
   883 00004D69 80FE0B              <1> 	cmp dh, 11
   884 00004D6C 0F84C9FF            <1> 	je near .selectorloop
   885 00004D70 FECE                <1> 	dec dh
   886 00004D72 EBC5                <1> 	jmp .selectorloop
   887                              <1> 
   888                              <1> .select:
   889 00004D74 88F0                <1> 	mov al, dh
   890 00004D76 2C0A                <1> 	sub al, 10
   891 00004D78 C3                  <1> 	ret
   892                              <1> 	
   893                              <1> .invert:
   894 00004D79 B21C                <1> 	mov dl, 28
   895                              <1> 
   896                              <1> .invertloop:
   897 00004D7B E8A9CB              <1> 	call os_move_cursor
   898 00004D7E B408                <1> 	mov ah, 08h
   899 00004D80 B700                <1> 	mov bh, 0
   900 00004D82 CD10                <1> 	int 10h
   901                              <1> 
   902 00004D84 BBF000              <1> 	mov bx, 240			; Black on white
   903 00004D87 B409                <1> 	mov ah, 09h
   904 00004D89 B90100              <1> 	mov cx, 1
   905 00004D8C CD10                <1> 	int 10h
   906                              <1> 
   907 00004D8E FEC2                <1> 	inc dl
   908 00004D90 80FA3C              <1> 	cmp dl, 60
   909 00004D93 0F840200            <1> 	je near .invertend
   910 00004D97 EBE2                <1> 	jmp .invertloop
   911                              <1> 	
   912                              <1> .invertend:
   913 00004D99 B21C                <1> 	mov dl, 28
   914 00004D9B C3                  <1> 	ret
   915                              <1> 	
   916                              <1> .drawwindow:
   917 00004D9C BA1309              <1> 	mov dx, 9 * 256 + 19			; First, draw white background box
   918 00004D9F 8A1EA9DE            <1> 	mov bl, [57001]
   919 00004DA3 BE2A00              <1> 	mov si, 42
   920 00004DA6 BF0F00              <1> 	mov di, 15
   921 00004DA9 E8C5CB              <1> 	call os_draw_block
   922                              <1> 
   923                              <1> .drawcontents:
   924 00004DAC 60                  <1> 	pusha
   925 00004DAD 8A1EA9DE            <1> 	mov bl, [57001]
   926 00004DB1 BA140A              <1> 	mov dx, 10 * 256 + 20
   927 00004DB4 E870CB              <1> 	call os_move_cursor
   928                              <1> 
   929 00004DB7 BE[D44E]            <1> 	mov si, .dialogmsg1
   930 00004DBA E823CB              <1> 	call os_format_string
   931 00004DBD BECCDE              <1> 	mov si, 57036
   932 00004DC0 E81DCB              <1> 	call os_format_string
   933 00004DC3 BE[DE4E]            <1> 	mov si, .dialogmsg2
   934 00004DC6 E817CB              <1> 	call os_format_string
   935                              <1> 
   936 00004DC9 BA140B              <1> 	mov dx, 11 * 256 + 20
   937 00004DCC E858CB              <1> 	call os_move_cursor
   938 00004DCF BE[7150]            <1> 	mov si, .logo0
   939 00004DD2 E80BCB              <1> 	call os_format_string
   940                              <1> 
   941 00004DD5 BA140C              <1> 	mov dx, 12 * 256 + 20
   942 00004DD8 E84CCB              <1> 	call os_move_cursor
   943 00004DDB BE[9A50]            <1> 	mov si, .logo1
   944 00004DDE E8FFCA              <1> 	call os_format_string
   945                              <1> 
   946 00004DE1 BA140D              <1> 	mov dx, 13 * 256 + 20
   947 00004DE4 E840CB              <1> 	call os_move_cursor
   948 00004DE7 BE[C350]            <1> 	mov si, .logo2
   949 00004DEA E8F3CA              <1> 	call os_format_string
   950                              <1> 
   951 00004DED BA140E              <1> 	mov dx, 14 * 256 + 20
   952 00004DF0 E834CB              <1> 	call os_move_cursor
   953 00004DF3 BE[EC50]            <1> 	mov si, .logo3
   954 00004DF6 E8E7CA              <1> 	call os_format_string
   955 00004DF9 61                  <1> 	popa
   956 00004DFA C3                  <1> 	ret
   957                              <1> 
   958                              <1> .drawbackground:
   959 00004DFB E813CB              <1> 	call os_clear_screen
   960 00004DFE BA0000              <1> 	mov dx, 0
   961 00004E01 E823CB              <1> 	call os_move_cursor
   962                              <1> 	
   963 00004E04 B82009              <1> 	mov ax, 0920h
   964 00004E07 BB7000              <1> 	mov bx, 112			; Black on gray
   965 00004E0A B95000              <1> 	mov cx, 80
   966 00004E0D CD10                <1> 	int 10h
   967                              <1> 	
   968 00004E0F BA0001              <1> 	mov dx, 1 * 256
   969 00004E12 E812CB              <1> 	call os_move_cursor
   970                              <1> 	
   971 00004E15 8A1EA8DE            <1> 	mov bl, [57000]		; Color from RAM
   972 00004E19 80E3F0              <1> 	and bl, 11110000b
   973 00004E1C B93007              <1> 	mov cx, 1840
   974 00004E1F B0B1                <1> 	mov al, 177
   975 00004E21 CD10                <1> 	int 10h
   976                              <1> 	
   977 00004E23 BA0018              <1> 	mov dx, 24 * 256
   978 00004E26 E8FECA              <1> 	call os_move_cursor
   979 00004E29 B370                <1> 	mov bl, 112			; Black on gray
   980 00004E2B B95000              <1> 	mov cx, 80
   981 00004E2E B020                <1> 	mov al, 32
   982 00004E30 CD10                <1> 	int 10h
   983 00004E32 C3                  <1> 	ret
   984                              <1> 	
   985                              <1> .reset:
   986 00004E33 EA0000FFFF          <1> 	jmp 0FFFFh:0
   987                              <1> 
   988                              <1> .shutdown:
   989 00004E38 E8D6CA              <1> 	call os_clear_screen
   990 00004E3B E81ECB              <1> 	call os_show_cursor
   991                              <1> 
   992 00004E3E BE[A34F]            <1> 	mov si, .apmmsg
   993 00004E41 E872CA              <1> 	call os_print_string
   994                              <1> 	
   995 00004E44 BE[C84F]            <1> 	mov si, .dbgmsg1
   996 00004E47 E86CCA              <1> 	call os_print_string
   997                              <1> 	
   998 00004E4A B80053              <1> 	mov ax, 5300h
   999 00004E4D 31DB                <1> 	xor bx, bx
  1000 00004E4F CD15                <1> 	int 15h				; check if APM is present
  1001 00004E51 724F                <1> 	jc .APM_missing
  1002                              <1> 
  1003 00004E53 BE[DA4F]            <1> 	mov si, .dbgmsg2
  1004 00004E56 E85DCA              <1> 	call os_print_string
  1005                              <1> 
  1006 00004E59 B80453              <1> 	mov ax, 5304h
  1007 00004E5C 31DB                <1> 	xor bx, bx
  1008 00004E5E CD15                <1> 	int 15h				; disconnect any previous APM interface	
  1009                              <1> 	
  1010 00004E60 BE[0850]            <1> 	mov si, .dbgmsg2_1
  1011 00004E63 E850CA              <1> 	call os_print_string
  1012                              <1> 	
  1013 00004E66 B80E53              <1> 	mov ax, 530Eh		; Set APM to version 1.2
  1014 00004E69 31DB                <1> 	xor bx, bx
  1015 00004E6B B90201              <1> 	mov cx, 0102h
  1016 00004E6E CD15                <1> 	int 15h
  1017                              <1> 
  1018 00004E70 BE[2850]            <1> 	mov si, .dbgmsg3
  1019 00004E73 E840CA              <1> 	call os_print_string
  1020                              <1> 
  1021 00004E76 B80153              <1> 	mov ax, 5301h
  1022 00004E79 31DB                <1> 	xor bx, bx
  1023 00004E7B 31C9                <1> 	xor cx, cx
  1024 00004E7D CD15                <1> 	int 15h				; open an interface with APM
  1025 00004E7F 7231                <1> 	jc .APM_interface
  1026                              <1> 
  1027 00004E81 BE[3F50]            <1> 	mov si, .dbgmsg4
  1028 00004E84 E82FCA              <1> 	call os_print_string
  1029                              <1> 
  1030 00004E87 B80753              <1> 	mov ax, 5307h
  1031 00004E8A BB0100              <1> 	mov bx, 1
  1032 00004E8D B90300              <1> 	mov cx, 3
  1033 00004E90 CD15                <1> 	int 15h				; do a power off
  1034                              <1> 	
  1035                              <1> .APM_error:
  1036 00004E92 B8[E04E]            <1> 	mov ax, .errormsg1
  1037 00004E95 BB[444F]            <1> 	mov bx, .errormsg4
  1038 00004E98 B9[6B4F]            <1> 	mov cx, .errormsg45
  1039 00004E9B 31D2                <1> 	xor dx, dx
  1040 00004E9D E859D2              <1> 	call os_dialog_box
  1041                              <1> 	
  1042 00004EA0 EB91                <1> 	jmp .reset
  1043                              <1> 	
  1044                              <1> .APM_missing:
  1045 00004EA2 B8[024F]            <1> 	mov ax, .errormsg2
  1046 00004EA5 BB[444F]            <1> 	mov bx, .errormsg4
  1047 00004EA8 B9[6B4F]            <1> 	mov cx, .errormsg45
  1048 00004EAB 31D2                <1> 	xor dx, dx
  1049 00004EAD E849D2              <1> 	call os_dialog_box
  1050                              <1> 	
  1051 00004EB0 EB81                <1> 	jmp .reset
  1052                              <1> 	
  1053                              <1> .APM_interface:
  1054 00004EB2 B8[264F]            <1> 	mov ax, .errormsg3
  1055 00004EB5 BB[444F]            <1> 	mov bx, .errormsg4
  1056 00004EB8 B9[6B4F]            <1> 	mov cx, .errormsg45
  1057 00004EBB 31D2                <1> 	xor dx, dx
  1058 00004EBD E839D2              <1> 	call os_dialog_box
  1059                              <1> 	
  1060 00004EC0 E970FF              <1> 	jmp .reset
  1061                              <1> 	
  1062                              <1> .APM_pwrmgmt:
  1063 00004EC3 B8[824F]            <1> 	mov ax, .errormsg5
  1064 00004EC6 BB[444F]            <1> 	mov bx, .errormsg4
  1065 00004EC9 B9[6B4F]            <1> 	mov cx, .errormsg45
  1066 00004ECC 31D2                <1> 	xor dx, dx
  1067 00004ECE E828D2              <1> 	call os_dialog_box
  1068                              <1> 	
  1069 00004ED1 E95FFF              <1> 	jmp .reset
  1070                              <1> 
  1071                              <1> 	
  1072 00004ED4 476F6F646279652C20- <1> 	.dialogmsg1	db 'Goodbye, ', 0
  1072 00004EDD 00                  <1>
  1073 00004EDE 2E00                <1> 	.dialogmsg2	db '.', 0
  1074 00004EE0 4572726F7220736875- <1> 	.errormsg1	db 'Error shutting down the computer.', 0
  1074 00004EE9 7474696E6720646F77- <1>
  1074 00004EF2 6E2074686520636F6D- <1>
  1074 00004EFB 70757465722E00      <1>
  1075 00004F02 5468697320636F6D70- <1> 	.errormsg2	db 'This computer does not support APM.', 0
  1075 00004F0B 7574657220646F6573- <1>
  1075 00004F14 206E6F742073757070- <1>
  1075 00004F1D 6F72742041504D2E00  <1>
  1076 00004F26 4572726F7220636F6D- <1> 	.errormsg3	db 'Error communicating with APM.', 0
  1076 00004F2F 6D756E69636174696E- <1>
  1076 00004F38 672077697468204150- <1>
  1076 00004F41 4D2E00              <1>
  1077 00004F44 506C65617365207475- <1> 	.errormsg4	db 'Please turn off the computer manually,', 0
  1077 00004F4D 726E206F6666207468- <1>
  1077 00004F56 6520636F6D70757465- <1>
  1077 00004F5F 72206D616E75616C6C- <1>
  1077 00004F68 792C00              <1>
  1078 00004F6B 6F7220707265737320- <1> 	.errormsg45	db 'or press OK to reboot.', 0
  1078 00004F74 4F4B20746F20726562- <1>
  1078 00004F7D 6F6F742E00          <1>
  1079 00004F82 4572726F7220656E61- <1> 	.errormsg5	db 'Error enabling power management.', 0
  1079 00004F8B 626C696E6720706F77- <1>
  1079 00004F94 6572206D616E616765- <1>
  1079 00004F9D 6D656E742E00        <1>
  1080                              <1> 	
  1081 00004FA3 417474656D7074696E- <1> 	.apmmsg		db 'Attempting shutdown through APM...', 13, 10, 0
  1081 00004FAC 672073687574646F77- <1>
  1081 00004FB5 6E207468726F756768- <1>
  1081 00004FBE 2041504D2E2E2E0D0A- <1>
  1081 00004FC7 00                  <1>
  1082                              <1> 	
  1083                              <1> 	
  1084 00004FC8 436865636B696E6720- <1> 	.dbgmsg1	db 'Checking APM...', 13, 10, 0
  1084 00004FD1 41504D2E2E2E0D0A00  <1>
  1085 00004FDA 446973636F6E6E6563- <1> 	.dbgmsg2	db 'Disconnecting any previous APM interface...', 13, 10, 0
  1085 00004FE3 74696E6720616E7920- <1>
  1085 00004FEC 70726576696F757320- <1>
  1085 00004FF5 41504D20696E746572- <1>
  1085 00004FFE 666163652E2E2E0D0A- <1>
  1085 00005007 00                  <1>
  1086 00005008 53657474696E672041- <1> 	.dbgmsg2_1	db 'Setting APM version to 1.2...', 13, 10, 0
  1086 00005011 504D2076657273696F- <1>
  1086 0000501A 6E20746F20312E322E- <1>
  1086 00005023 2E2E0D0A00          <1>
  1087 00005028 436F6E6E656374696E- <1> 	.dbgmsg3	db 'Connecting to APM...', 13, 10, 0
  1087 00005031 6720746F2041504D2E- <1>
  1087 0000503A 2E2E0D0A00          <1>
  1088 0000503F 456E61626C696E6720- <1> 	.dbgmsg4	db 'Enabling power management...', 13, 10, 0
  1088 00005048 706F776572206D616E- <1>
  1088 00005051 6167656D656E742E2E- <1>
  1088 0000505A 2E0D0A00            <1>
  1089 0000505E 5368757474696E6720- <1> 	.dbgmsg5	db 'Shutting down...', 13, 10, 0
  1089 00005067 646F776E2E2E2E0D0A- <1>
  1089 00005070 00                  <1>
  1090                              <1> 	
  1091 00005071 DAC4C4B3C4C4BF2020- <1> 	.logo0		db 218, 196, 196, 179, 196, 196, 191, '  Shut down the computer         ', 0
  1091 0000507A 5368757420646F776E- <1>
  1091 00005083 2074686520636F6D70- <1>
  1091 0000508C 757465722020202020- <1>
  1091 00005095 2020202000          <1>
  1092 0000509A B32020B32020B32020- <1> 	.logo1		db 179, 32, 32, 179, 32, 32, 179,     '  Soft reboot the computer       ', 0
  1092 000050A3 536F6674207265626F- <1>
  1092 000050AC 6F742074686520636F- <1>
  1092 000050B5 6D7075746572202020- <1>
  1092 000050BE 2020202000          <1>
  1093 000050C3 B32020202020B32020- <1> 	.logo2		db 179, 32, 32, 32, 32, 32, 179,      '  Go back                        ', 0
  1093 000050CC 476F206261636B2020- <1>
  1093 000050D5 202020202020202020- <1>
  1093 000050DE 202020202020202020- <1>
  1093 000050E7 2020202000          <1>
  1094 000050EC C0C4C4C4C4C4D900    <1> 	.logo3		db 192, 196, 196, 196, 196, 196, 217, 0
   827                                  
   828                                  ; ==================================================================
   829                                  ; END OF KERNEL
   830                                  ; ==================================================================
   831                                  
   832                                  os_kernel_end:
